<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<title>内存管理 - Yu</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://mvbbb.github.io/ldcb18/">
<link rel="icon" type="image/x-icon" href="/images/web.png">

<meta name="description" content="内存管理概念 覆盖, 交换, 连续分配算法 工作集: 某段时间间隔内, 实际访问的页面的集合  针对一个页表 逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成 物理地址: 具体的物理地址. 地址结构: 页表号+页内偏移量 页面/页/页框: 内存中的一小片 页面大小: 内存中一小片的大小 页表: 用于链接进程地址和实际物理地址 页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中">
<meta property="og:type" content="website">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="https://mvbbb.github.io/ldcb18/index.html">
<meta property="og:site_name" content="Yu">
<meta property="og:description" content="内存管理概念 覆盖, 交换, 连续分配算法 工作集: 某段时间间隔内, 实际访问的页面的集合  针对一个页表 逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成 物理地址: 具体的物理地址. 地址结构: 页表号+页内偏移量 页面/页/页框: 内存中的一小片 页面大小: 内存中一小片的大小 页表: 用于链接进程地址和实际物理地址 页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mvbbb.github.io/ldcb18/images/avatar.jpg">
<meta property="article:published_time" content="2020-10-21T05:51:37.000Z">
<meta property="article:modified_time" content="2021-02-03T04:20:59.433Z">
<meta property="article:author" content="Mvbbb">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mvbbb.github.io/ldcb18/images/avatar.jpg">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"url":"https://mvbbb.github.io","image":"https://mvbbb.github.io/images/avatar.jpg","description":"Who i am,who u are","author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"操作系统","url":"https://mvbbb.github.io/ldcb18/","headline":"内存管理","image":"https://mvbbb.github.io/images/avatar.jpg","datePublished":"2020-10-21T05:51:37.000Z","dateModified":"2021-02-03T04:20:59.433Z","keywords":"OS","description":"Who i am,who u are","publisher":{"@type":"Organization","name":"Yu","logo":{"@type":"ImageObject","url":"https://mvbbb.github.io/images/avatar.jpg"}},"author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mvbbb.github.io/ldcb18/"}}]</script><link rel="alternate" type="application/atom+xml" title="Yu" href="/rss2.xml">
<script async="" src="//www.googletagmanager.com/gtag/js?id=UA-160027215-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','UA-160027215-1');</script>
<meta name="theme-color" content=""><script type="application/json" is="state">{&q;api/bGRjYjE4.json&q;:{&q;title&q;:&q;内存管理&q;,&q;date&q;:&q;2020-10-21T05:51:37.000Z&q;,&q;date_formatted&q;:{&q;ll&q;:&q;Oct 21, 2020&q;,&q;L&q;:&q;10/21/2020&q;,&q;MM-DD&q;:&q;10-21&q;},&q;link&q;:&q;ldcb18&q;,&q;comments&q;:true,&q;tags&q;:[&q;OS&q;],&q;categories&q;:[&q;操作系统&q;],&q;updated&q;:&q;2021-02-03T04:20:59.433Z&q;,&q;content&q;:&q;&l;h1 id=\&q;内存管理概念\&q;&g;内存管理概念&l;a title=\&q;#内存管理概念\&q; href=\&q;#内存管理概念\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;覆盖, 交换, 连续分配算法&l;br&g;\n工作集: 某段时间间隔内, 实际访问的页面的集合&l;br&g;\n&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1605006818693-43861290-7c1c-40be-8cfc-70573a5d6a47.png#align=left&a;amp;display=inline&a;amp;height=276&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=552&a;amp;originWidth=997&a;amp;size=200038&a;amp;status=done&a;amp;style=none&a;amp;width=498.5\&q; alt=\&q;image.png\&q;&g;&l;/p&g;\n&l;h2 id=\&q;针对一个页表\&q;&g;针对一个页表&l;a title=\&q;#针对一个页表\&q; href=\&q;#针对一个页表\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成&l;br&g;\n物理地址: 具体的物理地址.&l;br&g;\n地址结构: 页表号+页内偏移量&l;br&g;\n页面/页/页框: 内存中的一小片&l;br&g;\n页面大小: 内存中一小片的大小&l;br&g;\n页表: 用于链接进程地址和实际物理地址&l;br&g;\n页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中实际的物理地址&l;br&g;\n页表项大小: 页面大小/页表项大小=页表项个数&l;/p&g;\n&l;p&g;页号: 页表项的编号, 从 0 开始&l;br&g;\n页内偏移量: 在一个页面内的偏移量, 最大值是页面大小&l;br&g;\n页表寄存器:   记录页表的起始长度和页表的大小&l;br&g;\n快表: 相联存储器, 记录访问过的页表号和内存号, 加快下次访问速度&l;/p&g;\n&l;h2 id=\&q;针对多级页表\&q;&g;针对多级页表&l;a title=\&q;#针对多级页表\&q; href=\&q;#针对多级页表\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;一级页表: 记录二级页表在内存中的内存块号&l;br&g;\n二级页表: 记录下一级页表在内存中的内存块号, 如果本身是最后一级页表, 就是记录的所需内存块号&l;br&g;\n一级/二级页表: 特指两级页表中, 称链接进程逻辑地址的那个页表为一级页表. 采用了多级页表之后, 逻辑地址结构也需要对应的进行修改, 原来只需要找到在一个页表中的某个页表号, 原来使用一个坐标就能定位, 现在者需要多个. 以二级页表为例, 逻辑地址结构修改为: 一级页号+二级页号+页内偏移&l;/p&g;\n&l;p&g;采用多级页表机制, 各级页表大小不能超过一个页面&l;/p&g;\n&l;h2 id=\&q;分段\&q;&g;分段&l;a title=\&q;#分段\&q; href=\&q;#分段\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;逻辑地址: 段号(前 16 位)+段内地址(后 16 位)&l;br&g;\n段号的位数决定了每个进程最多可以分几个端&l;br&g;\n段内地址位数决定了每个端的最大长度是多少&l;br&g;\n段表: 段号, 段长, 基址&l;br&g;\n段名: 在低级语言中, 进程被分为多个段, 可以为他们取单独的名称. 隐含的, 不占存储空间&l;br&g;\n段表项: 各个段表项的长度是相同的&l;br&g;\n段表长度: 段表项的个数&l;br&g;\n基址: 物理地址的开始地址&l;br&g;\n段长: 该段号对应的实际长度, 与页不同, 它的大小不固定, 在段内地址的合法性校验中会用到.&l;/p&g;\n&l;h2 id=\&q;段页式管理\&q;&g;段页式管理&l;a title=\&q;#段页式管理\&q; href=\&q;#段页式管理\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;逻辑地址: 段号(前 16 位)+页号(中间 4 位)+页内偏移量(后 12 位)&l;br&g;\n段号的位数决定了每个进程最多可以分几个段&l;br&g;\n页号的位数决定了每个段最多有多少页&l;br&g;\n页内偏移量决定了页面的大小, 内存块的大小是多少&l;br&g;\n&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1603260036963-a5740b21-f9c3-492f-91e3-4512da67d07c.png#align=left&a;amp;display=inline&a;amp;height=209&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=418&a;amp;originWidth=803&a;amp;size=69165&a;amp;status=done&a;amp;style=none&a;amp;width=401.5\&q; alt=\&q;image.png\&q;&g;&l;/p&g;\n&l;h1 id=\&q;虚拟存储概念\&q;&g;虚拟存储概念&l;a title=\&q;#虚拟存储概念\&q; href=\&q;#虚拟存储概念\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;虚拟内存的最大容量是由计算机的地址结构确定的&l;br&g;\n虚拟内存的实际容量 = min(内存+外存, CPU 的寻址范围)&l;br&g;\n请求调页: 将内存中缺失的页面调入内存&l;br&g;\n页面置换: 将暂时用不到的页面调出内存&l;br&g;\n请求分页存储的页表: 内存块号+状态位(是否已经调入内存)+访问字段(该页面被访问过几次/记录上一次访问这个页面的时间, 用于判断是否需要调出内存)+修改位(自从调入是否被修改过)+外存地址&l;br&g;\n改进型时钟置换算法: 优先考虑没有访问过的页面, 如果都被访问过, 就优先访问没有被修改过的, 如果都被修改过. 就选择最近访问过, 但是没有修改的, 最其次选择访问过而且被修改过的.&l;br&g;\n&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262350467-0f7f4918-b0e4-45de-be7e-df087092515e.png#align=left&a;amp;display=inline&a;amp;height=361&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=721&a;amp;originWidth=777&a;amp;size=148235&a;amp;status=done&a;amp;style=none&a;amp;width=388.5\&q; alt=\&q;image.png\&q;&g;&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262485196-75528ec8-0369-49df-ad5c-0fe443d72698.png#align=left&a;amp;display=inline&a;amp;height=297&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=594&a;amp;originWidth=487&a;amp;size=92586&a;amp;status=done&a;amp;style=none&a;amp;width=243.5\&q; alt=\&q;image.png\&q;&g;&l;/p&g;\n&l;h1 id=\&q;相关问题\&q;&g;相关问题&l;a title=\&q;#相关问题\&q; href=\&q;#相关问题\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;strong&g;为什么分页存储的地址空间是一维的，而分段存储的地址是二维的?&l;/strong&g;&l;br&g;\n短号和页号的来历是不同的，段号是程序员自己定义的，每个段都是有特定含义的，因此不同段的大小不同，代表的意义也不相同，因此要想找到某个数据或指令，&l;strong&g;需要指定段号和位移两个变量&l;/strong&g;。而页号是系统自动生成的，本身地址是线性连续的，&l;strong&g;当要访问特定地址时，只需要提供地址即可&l;/strong&g;。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此是一维的。&l;br&g;\n&l;strong&g;一维或者二维是相对于程序员来讲的&l;/strong&g;&l;/p&g;\n&l;blockquote&g;\n&l;p&g;转载自 &l;a href=\&q;https://blog.csdn.net/xiaotai1234/article/details/107427547\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://blog.csdn.net/xiaotai1234/article/details/107427547&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1604924358520-2e69ca06-b690-4c7c-8cd4-2ba3720c348a.png#align=left&a;amp;display=inline&a;amp;height=61&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=122&a;amp;originWidth=746&a;amp;size=41821&a;amp;status=done&a;amp;style=none&a;amp;width=373\&q; alt=\&q;image.png\&q;&g;&l;br&g;\n页目录号 = (LA&a;gt;&a;gt;22)&a;amp;1111111111, 页表索引 = (LA&a;gt;&a;gt;12)&a;amp;1111111111&l;/p&g;\n&l;p&g;页式存储中页表记录的是内存块号, 段式存储中记录的是内存始址&l;br&g;\n页面的大小 = 2^(逻辑地址的长度)&l;/p&g;\n&l;div&g;&l;h1 id=\&q;推荐文章\&q;&g;推荐文章&l;a title=\&q;#推荐文章\&q; href=\&q;%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\&q;&g;&l;/a&g;&l;/h1&g;&l;ul&g;&l;li&g;&l;a href=\&q;https://mvbbb.github.io/ognzg7/\&q;&g;经典进程同步问题&l;/a&g;&l;/li&g;&l;/ul&g;&l;/div&g;&q;,&q;prev&q;:{&q;title&q;:&q;Linux服务器安装 MySql 8.0并配置远程连接&q;,&q;link&q;:&q;sb74kg&q;},&q;next&q;:{&q;title&q;:&q;经典进程同步问题&q;,&q;link&q;:&q;ognzg7&q;},&q;plink&q;:&q;https://mvbbb.github.io/ldcb18/&q;,&q;toc&q;:[{&q;id&q;:&q;内存管理概念&q;,&q;title&q;:&q;内存管理概念&q;,&q;index&q;:&q;1&q;,&q;children&q;:[{&q;id&q;:&q;针对一个页表&q;,&q;title&q;:&q;针对一个页表&q;,&q;index&q;:&q;1.1&q;},{&q;id&q;:&q;针对多级页表&q;,&q;title&q;:&q;针对多级页表&q;,&q;index&q;:&q;1.2&q;},{&q;id&q;:&q;分段&q;,&q;title&q;:&q;分段&q;,&q;index&q;:&q;1.3&q;},{&q;id&q;:&q;段页式管理&q;,&q;title&q;:&q;段页式管理&q;,&q;index&q;:&q;1.4&q;}]},{&q;id&q;:&q;虚拟存储概念&q;,&q;title&q;:&q;虚拟存储概念&q;,&q;index&q;:&q;2&q;},{&q;id&q;:&q;相关问题&q;,&q;title&q;:&q;相关问题&q;,&q;index&q;:&q;3&q;},{&q;id&q;:&q;推荐文章&q;,&q;title&q;:&q;推荐文章&q;,&q;index&q;:&q;4&q;}],&q;copyright&q;:{&q;author&q;:&q;Mvbbb&q;,&q;link&q;:&q;&l;a href=\&q;https://mvbbb.github.io/ldcb18/\&q; title=\&q;内存管理\&q;&g;https://mvbbb.github.io/ldcb18/&l;/a&g;&q;,&q;license&q;:&q;Attribution-NonCommercial-NoDerivatives 4.0 International (&l;a href=\&q;https://creativecommons.org/licenses/by-nc-sa/4.0/\&q; rel=\&q;external nofollow noopener\&q; target=\&q;_blank\&q;&g;CC BY-NC-ND 4.0&l;/a&g;)&q;}}}</script></head><body lang="en"><div style="display:none"><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1279526637&amp;web_id=1279526637"></script></div>
<!-- hexo injector head_end start --><link href="//fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat" rel="stylesheet"><link href="/styles.43478ea7e28ed563c48b.css" rel="stylesheet">
<script src="/config.f667b9e14173c512056d.js"></script>

<link rel="stylesheet" href="/theme.6191587147d30da44d8f.css" is="theme">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0">
<!-- hexo injector body_begin start --><is-a class="φbm φk" ng-version="10.0.11"><is-l class="φeb φh"><div class="φel"><section class="φem"><header class="φec φf"><!----><is-c class="φed"><img draggable="false" class="φbw φw" src="images/avatar.jpg" alt="" title="" width="160" height="160"></is-c><!----><a href="" class="φef φa φu">Mvbbb</a><p class="φee">Who i am,who u are</p></header><div class="φeq φf"><a routerlink="/archives" class="φer φu" href="/archives"><span class="φd">45</span><span>Archives</span></a><a class="φer φu" href="/categories/Java"><span class="φd">14</span><span>Categories</span></a><!----><a routerlink="/tags" class="φer φu" href="/tags"><span class="φd">34</span><span>Tags</span></a><!----></div><!----><nav class="φen"><a class="φeo φbd φj φc φu φo" href="/">Home</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/about">About</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/search">Search</a><!----><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φeo φbd φj φc φu φo" href="https://www.yuque.com/u1296515/zb4bwb">Yuque</a><!----><!----><!----></nav><!----><!----></section><footer class="φeg φeh"><div class="φej"><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-email" href="mailto:3212618781@qq.com">email</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-feed" href="https://mvbbb.github.io/rss2.xml">feed</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-github" href="https://github.com/Mvbbb">github</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-myspace" href="/links">myspace</a><!----></div><!----><p class="φbk φz">© 2019-2021 ❤ <a href="https://github.com/Mvbbb">Mvbbb</a></p><!----><!----><!----></footer></div></is-l><div class="φbo"><div class="φbn"><div class="φbs φbe"><main class="φbr φbf"><router-outlet></router-outlet><is-s class="φfx φf"><header class="φgh φgi" style="background-image:;background-color:;"><div class="φgq"><h1 class="φgt">内存管理</h1><!----><p class="φgj φr"><span class="φgk φgo">Oct 21, 2020</span><a class="φgk φgm φu" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><!----><!----><!----></p><!----><!----></div></header><article itemscope="" itemtype="http://schema.org/Article" class="φga" data-title="内存管理"><div itemprop="articleBody" issnippet="" iszoomable="" class="φbk φh φz"><h1 id="内存管理概念">内存管理概念<a title="#内存管理概念" href="#内存管理概念"></a></h1>
<p>覆盖, 交换, 连续分配算法<br>
工作集: 某段时间间隔内, 实际访问的页面的集合<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1605006818693-43861290-7c1c-40be-8cfc-70573a5d6a47.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=552&amp;originWidth=997&amp;size=200038&amp;status=done&amp;style=none&amp;width=498.5" alt="image.png"></p>
<h2 id="针对一个页表">针对一个页表<a title="#针对一个页表" href="#针对一个页表"></a></h2>
<p>逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成<br>
物理地址: 具体的物理地址.<br>
地址结构: 页表号+页内偏移量<br>
页面/页/页框: 内存中的一小片<br>
页面大小: 内存中一小片的大小<br>
页表: 用于链接进程地址和实际物理地址<br>
页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中实际的物理地址<br>
页表项大小: 页面大小/页表项大小=页表项个数</p>
<p>页号: 页表项的编号, 从 0 开始<br>
页内偏移量: 在一个页面内的偏移量, 最大值是页面大小<br>
页表寄存器: &nbsp; 记录页表的起始长度和页表的大小<br>
快表: 相联存储器, 记录访问过的页表号和内存号, 加快下次访问速度</p>
<h2 id="针对多级页表">针对多级页表<a title="#针对多级页表" href="#针对多级页表"></a></h2>
<p>一级页表: 记录二级页表在内存中的内存块号<br>
二级页表: 记录下一级页表在内存中的内存块号, 如果本身是最后一级页表, 就是记录的所需内存块号<br>
一级/二级页表: 特指两级页表中, 称链接进程逻辑地址的那个页表为一级页表. 采用了多级页表之后, 逻辑地址结构也需要对应的进行修改, 原来只需要找到在一个页表中的某个页表号, 原来使用一个坐标就能定位, 现在者需要多个. 以二级页表为例, 逻辑地址结构修改为: 一级页号+二级页号+页内偏移</p>
<p>采用多级页表机制, 各级页表大小不能超过一个页面</p>
<h2 id="分段">分段<a title="#分段" href="#分段"></a></h2>
<p>逻辑地址: 段号(前 16 位)+段内地址(后 16 位)<br>
段号的位数决定了每个进程最多可以分几个端<br>
段内地址位数决定了每个端的最大长度是多少<br>
段表: 段号, 段长, 基址<br>
段名: 在低级语言中, 进程被分为多个段, 可以为他们取单独的名称. 隐含的, 不占存储空间<br>
段表项: 各个段表项的长度是相同的<br>
段表长度: 段表项的个数<br>
基址: 物理地址的开始地址<br>
段长: 该段号对应的实际长度, 与页不同, 它的大小不固定, 在段内地址的合法性校验中会用到.</p>
<h2 id="段页式管理">段页式管理<a title="#段页式管理" href="#段页式管理"></a></h2>
<p>逻辑地址: 段号(前 16 位)+页号(中间 4 位)+页内偏移量(后 12 位)<br>
段号的位数决定了每个进程最多可以分几个段<br>
页号的位数决定了每个段最多有多少页<br>
页内偏移量决定了页面的大小, 内存块的大小是多少<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1603260036963-a5740b21-f9c3-492f-91e3-4512da67d07c.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=803&amp;size=69165&amp;status=done&amp;style=none&amp;width=401.5" alt="image.png"></p>
<h1 id="虚拟存储概念">虚拟存储概念<a title="#虚拟存储概念" href="#虚拟存储概念"></a></h1>
<p>虚拟内存的最大容量是由计算机的地址结构确定的<br>
虚拟内存的实际容量 = min(内存+外存, CPU 的寻址范围)<br>
请求调页: 将内存中缺失的页面调入内存<br>
页面置换: 将暂时用不到的页面调出内存<br>
请求分页存储的页表: 内存块号+状态位(是否已经调入内存)+访问字段(该页面被访问过几次/记录上一次访问这个页面的时间, 用于判断是否需要调出内存)+修改位(自从调入是否被修改过)+外存地址<br>
改进型时钟置换算法: 优先考虑没有访问过的页面, 如果都被访问过, 就优先访问没有被修改过的, 如果都被修改过. 就选择最近访问过, 但是没有修改的, 最其次选择访问过而且被修改过的.<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262350467-0f7f4918-b0e4-45de-be7e-df087092515e.png#align=left&amp;display=inline&amp;height=361&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=721&amp;originWidth=777&amp;size=148235&amp;status=done&amp;style=none&amp;width=388.5" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262485196-75528ec8-0369-49df-ad5c-0fe443d72698.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=594&amp;originWidth=487&amp;size=92586&amp;status=done&amp;style=none&amp;width=243.5" alt="image.png"></p>
<h1 id="相关问题">相关问题<a title="#相关问题" href="#相关问题"></a></h1>
<p><strong>为什么分页存储的地址空间是一维的，而分段存储的地址是二维的?</strong><br>
短号和页号的来历是不同的，段号是程序员自己定义的，每个段都是有特定含义的，因此不同段的大小不同，代表的意义也不相同，因此要想找到某个数据或指令，<strong>需要指定段号和位移两个变量</strong>。而页号是系统自动生成的，本身地址是线性连续的，<strong>当要访问特定地址时，只需要提供地址即可</strong>。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此是一维的。<br>
<strong>一维或者二维是相对于程序员来讲的</strong></p>
<blockquote>
<p>转载自 <a href="https://blog.csdn.net/xiaotai1234/article/details/107427547" target="_blank" rel="external nofollow noopener">https://blog.csdn.net/xiaotai1234/article/details/107427547</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1604924358520-2e69ca06-b690-4c7c-8cd4-2ba3720c348a.png#align=left&amp;display=inline&amp;height=61&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=746&amp;size=41821&amp;status=done&amp;style=none&amp;width=373" alt="image.png"><br>
页目录号 = (LA&gt;&gt;22)&amp;1111111111, 页表索引 = (LA&gt;&gt;12)&amp;1111111111</p>
<p>页式存储中页表记录的是内存块号, 段式存储中记录的是内存始址<br>
页面的大小 = 2^(逻辑地址的长度)</p>
<div><h1 id="推荐文章">推荐文章<a title="#推荐文章" href="%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0"></a></h1><ul><li><a href="https://mvbbb.github.io/ognzg7/">经典进程同步问题</a></li></ul></div></div><is-f class="φcc φv φs"><!----><ul class="φcg"><li class="φce"><strong class="φcf">Author<span>:</span></strong><p class="φcd">Mvbbb</p></li><li class="φce"><strong class="φcf">Link<span>:</span></strong><p class="φcd"><a href="https://mvbbb.github.io/ldcb18/" title="内存管理">https://mvbbb.github.io/ldcb18/</a></p></li><li class="φce"><strong class="φcf">Copyright<span>:</span></strong><p class="φcd">Attribution-NonCommercial-NoDerivatives 4.0 International (<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener" target="_blank">CC BY-NC-ND 4.0</a>)</p></li><!----></ul><!----></is-f><!----><!----><!----></article><footer class="φgb φh"><div class="φgg"><is-m class="φet"><a class="φeu φs φq" href="/tags/OS">OS</a></is-m><!----></div><!----><div class="φgc"><a class="φgd φgf φu" href="/sb74kg">Linux服务器安装 MySql 8.0并配置远程连接</a><!----><a class="φgd φge φu" href="/ognzg7">经典进程同步问题</a><!----></div><!----></footer><is-e class="φbz φh"><div issnippet="" class="φbh"><div id="tcomment"></div>


</div><!----><!----><!----><!----></is-e><!----><!----><!----></is-s><!----></main><!----></div></div></div><is-g class="φch"><div class="φcq"><span class="φbg icon-up"></span><span class="φbg icon-down"></span><!----><span class="φbg icon-toc"></span><!----><span class="φbg icon-search"></span><!----></div><div class="φcj φck"><svg class="φcp"><defs><filter id="dp"><feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur></filter></defs><circle filter="url(#dp)" fill="rgba(0,0,0,.3)" cx="50%" cy="52%" r="44%"></circle><circle cx="50%" cy="50%" r="44%" class="φcl φbb"></circle><circle cx="50%" cy="50%" r="48%" class="φco φba" stroke-dasharray="0% 314.15926%"></circle><!----><g class="φcm"><circle r=".2rem" cx="0" cy="-.8rem"></circle><circle r=".2rem"></circle><circle r=".2rem" cx="0" cy=".8rem"></circle></g><!----></svg></div></is-g><is-n class="φev φf"><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">1 </span><!----><span class="φfc">内存管理概念</span></a><div class="φex"><a class="φfa φu"><span class="φfb φd">1.1 </span><!----><span class="φfc">针对一个页表</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">1.2 </span><!----><span class="φfc">针对多级页表</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">1.3 </span><!----><span class="φfc">分段</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">1.4 </span><!----><span class="φfc">段页式管理</span></a><!----></div><!----><!----><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">2 </span><!----><span class="φfc">虚拟存储概念</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">3 </span><!----><span class="φfc">相关问题</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">4 </span><!----><span class="φfc">推荐文章</span></a><!----></div><!----></is-n><!----><!----></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js"></script><script src="/runtime.b15aa7186c559b492b7d.js"></script><script src="/polyfills.824ff89b5f3ca4543a31.js"></script><script src="/main.03652fc423a687c817e8.js"></script><!-- hexo injector body_end end -->

</body></html>