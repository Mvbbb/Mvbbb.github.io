<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<title>经典进程同步问题 - Yu</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://mvbbb.github.io/ognzg7/">
<link rel="icon" type="image/x-icon" href="/images/web.png">

<meta name="description" content="一些比较经典的, 书上的进程同步问题 总结的解题思路:  画图理解题目 判断题目类型 分析进程数目, 填写进程模板 补充基本代码 补充 PV 代码 检查调整代码">
<meta property="og:type" content="website">
<meta property="og:title" content="经典进程同步问题">
<meta property="og:url" content="https://mvbbb.github.io/ognzg7/index.html">
<meta property="og:site_name" content="Yu">
<meta property="og:description" content="一些比较经典的, 书上的进程同步问题 总结的解题思路:  画图理解题目 判断题目类型 分析进程数目, 填写进程模板 补充基本代码 补充 PV 代码 检查调整代码">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mvbbb.github.io/ognzg7/images/avatar.jpg">
<meta property="article:published_time" content="2020-10-14T13:41:43.000Z">
<meta property="article:modified_time" content="2021-02-03T04:20:59.525Z">
<meta property="article:author" content="Mvbbb">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mvbbb.github.io/ognzg7/images/avatar.jpg">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"url":"https://mvbbb.github.io","image":"https://mvbbb.github.io/images/avatar.jpg","description":"Who i am,who u are","author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"操作系统","url":"https://mvbbb.github.io/ognzg7/","headline":"经典进程同步问题","image":"https://mvbbb.github.io/images/avatar.jpg","datePublished":"2020-10-14T13:41:43.000Z","dateModified":"2021-02-03T04:20:59.525Z","keywords":"OS","description":"一些比较经典的, 书上的进程同步问题\n总结的解题思路:\n\n画图理解题目\n判断题目类型\n分析进程数目, 填写进程模板\n补充基本代码\n补充 PV 代码\n检查调整代码\n","publisher":{"@type":"Organization","name":"Yu","logo":{"@type":"ImageObject","url":"https://mvbbb.github.io/images/avatar.jpg"}},"author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mvbbb.github.io/ognzg7/"}}]</script><link rel="alternate" type="application/atom+xml" title="Yu" href="/rss2.xml">
<script async="" src="//www.googletagmanager.com/gtag/js?id=UA-160027215-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','UA-160027215-1');</script>
<meta name="theme-color" content=""><script type="application/json" is="state">{&q;api/b2duemc3.json&q;:{&q;title&q;:&q;经典进程同步问题&q;,&q;date&q;:&q;2020-10-14T13:41:43.000Z&q;,&q;date_formatted&q;:{&q;ll&q;:&q;Oct 14, 2020&q;,&q;L&q;:&q;10/14/2020&q;,&q;MM-DD&q;:&q;10-14&q;},&q;link&q;:&q;ognzg7&q;,&q;comments&q;:true,&q;tags&q;:[&q;OS&q;],&q;categories&q;:[&q;操作系统&q;],&q;updated&q;:&q;2021-02-03T04:20:59.525Z&q;,&q;content&q;:&q;&l;p&g;一些比较经典的, 书上的进程同步问题&l;br&g;\n总结的解题思路:&l;/p&g;\n&l;ol&g;\n&l;li&g;&l;strong&g;画图理解题目&l;/strong&g;&l;/li&g;\n&l;li&g;判断题目类型&l;/li&g;\n&l;li&g;分析进程数目, 填写进程模板&l;/li&g;\n&l;li&g;补充基本代码&l;/li&g;\n&l;li&g;补充 PV 代码&l;/li&g;\n&l;li&g;检查调整代码&l;/li&g;\n&l;/ol&g;\n&l;a id=\&q;more\&q;&g;&l;/a&g;\n&l;h1 id=\&q;不同线程之间的同步问题\&q;&g;不同线程之间的同步问题&l;a title=\&q;#不同线程之间的同步问题\&q; href=\&q;#不同线程之间的同步问题\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;由于不同线程之间存在异步性, 两个线程的语句执行先后顺序无法确定.&l;br&g;\n使用信号量机制来实现不同线程之间的同步问题&l;br&g;\n&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740872722-0444194a-25a9-41c1-8237-1dc566f9199d.png#align=left&a;amp;display=inline&a;amp;height=258&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=515&a;amp;originWidth=1040&a;amp;size=190693&a;amp;status=done&a;amp;style=none&a;amp;width=520\&q; alt=\&q;image.png\&q;&g;&l;br&g;\n以此为延申, 如何实现拓扑排序&l;br&g;\n&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740921016-80a8c6c3-b480-4700-a694-4ba1411e5032.png#align=left&a;amp;display=inline&a;amp;height=299&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=597&a;amp;originWidth=1216&a;amp;size=173276&a;amp;status=done&a;amp;style=none&a;amp;width=608\&q; alt=\&q;image.png\&q;&g;&l;br&g;\n注意在线程同步中信号量初值为 0, 但是在线程互斥中信号量初值为 1&l;/p&g;\n&l;h1 id=\&q;生产者-消费者问题\&q;&g;生产者-消费者问题&l;a title=\&q;#生产者-消费者问题\&q; href=\&q;#生产者-消费者问题\&q;&g;&l;/a&g;&l;/h1&g;\n&l;h2 id=\&q;分析\&q;&g;分析&l;a title=\&q;#分析\&q; href=\&q;#分析\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;共享变量为缓存池里面的产品数&l;br&g;\n缓冲区满, 生产者必须等待. 缓冲区空, 消费者必须等待&l;br&g;\n因为缓冲区的数量是临界资源, 只使用一个互斥变量来实现线程互斥如何?&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore n = &l;span class=\&q;number\&q;&g;5&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore mutex=&l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;producer ()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(n);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// produce&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;consumer()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(n);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// consume&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;这个代码存在很严重的问题. 假设只有一个 consumer 进程先启动, 他顺利执行到 consume 操作. 但是此时的缓冲区中还没有商品.&l;br&g;\n我们对此进行分析一下.&l;/p&g;\n&l;ul&g;\n&l;li&g;如果缓冲区满，生产者是不能生产的，所以生产者进程受到消费者进程的制约；&l;/li&g;\n&l;li&g;如果缓冲区空，消费者是不能消费的，所以消费者进程受到生产者进程的制约。&l;/li&g;\n&l;/ul&g;\n&l;p&g;所以 P/C 问题不仅仅是线程互斥, 还包含了线程同步, 线程同步仅仅使用一个信号量是不够的.&l;br&g;\n&l;strong&g;因此我们需要额外设置两个信号量来实现线程的同步问题.&l;/strong&g;&l;br&g;\n生产者在乎的是剩余空间 empty. 消费者在乎的是占用空间 full.&l;br&g;\n&l;strong&g;生产者在生产商品之前应该 P(empty) , 消费者在消费商品之前应该 P(full).&l;/strong&g;&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1602744972535-bc2a1dd6-427e-4237-a934-7170cb571dc1.png#align=left&a;amp;display=inline&a;amp;height=129&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=257&a;amp;originWidth=1157&a;amp;size=47323&a;amp;status=done&a;amp;style=none&a;amp;width=578.5\&q; alt=\&q;image.png\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore mutex = &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore empty = n;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore full = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;producer()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(empty);  &l;span class=\&q;comment\&q;&g;// P消耗一个空闲缓冲区&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// produce&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(full);  &l;span class=\&q;comment\&q;&g;// V增加一个产品&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;consumer()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(full);  &l;span class=\&q;comment\&q;&g;// P消耗一个产品, 非缓冲区&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// consume&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(empty); &l;span class=\&q;comment\&q;&g;// V增加一个空闲缓冲区&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;是否可以交换 producer 或者 consumer 中的两个 P 操作呢?&l;br&g;\n我们交换 producer 里面的两个 P 操作&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;// producer&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;wait(empty);  &l;span class=\&q;comment\&q;&g;// P消耗一个空闲缓冲区&l;/span&g;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;假设此时缓冲区为满, empty = 0, full=n;&l;br&g;\nproducer 执行 P(mutex), mutex 变为 0, 执行 P(empty), 这个时候会被阻塞.&l;br&g;\n现在切换回 consumer 进程, 执行 wait(full) 没有问题, 执行 wait(mutex) 会被阻塞. 这样就会出现线程死锁.&l;br&g;\n因此实现互斥的 P 操作要在实现 同步的 P 操作之后执行&l;br&g;\n但是 V 操作的执行顺序不会导致线程.&l;/p&g;\n&l;h2 id=\&q;套路\&q;&g;套路&l;a title=\&q;#套路\&q; href=\&q;#套路\&q;&g;&l;/a&g;&l;/h2&g;\n&l;ol&g;\n&l;li&g;分析题目题型: 容器大小固定, 为 P/C 问题&l;/li&g;\n&l;li&g;分析进程数量: 不同个体对应不同的进程&l;/li&g;\n&l;li&g;分析每个进程关心的: 消费者只关心&l;strong&g;占用空间,&l;/strong&g; 生产者只关心&l;strong&g;剩余空间&l;/strong&g;&l;/li&g;\n&l;li&g;填写进程基本操作&l;/li&g;\n&l;li&g;补充 PV 代码&l;/li&g;\n&l;/ol&g;\n&l;h1 id=\&q;哲学家进餐问题\&q;&g;哲学家进餐问题&l;a title=\&q;#哲学家进餐问题\&q; href=\&q;#哲学家进餐问题\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;img src=\&q;https://cdn.nlark.com/yuque/0/2020/png/1552854/1602683081888-009a08f2-3d5f-4f1c-9d4e-ea4d4230ee95.png#align=left&a;amp;display=inline&a;amp;height=57&a;amp;margin=%5Bobject%20Object%5D&a;amp;name=image.png&a;amp;originHeight=113&a;amp;originWidth=1119&a;amp;size=49746&a;amp;status=done&a;amp;style=none&a;amp;width=559.5\&q; alt=\&q;image.png\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://www.bilibili.com/video/BV1YE411D7nH?p=27\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://www.bilibili.com/video/BV1YE411D7nH?p=27&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;h2 id=\&q;分析-1\&q;&g;分析&l;a title=\&q;#分析-1\&q; href=\&q;#分析-1\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;临界资源: 筷子&l;br&g;\n对哲学家进行编号, 第 i 位哲学家的活动可以描述为&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore chopstick[&l;span class=\&q;number\&q;&g;5&l;/span&g;]=&a;#123;&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;&a;#125;; &l;span class=\&q;comment\&q;&g;// 筷子的信号量&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;Pi()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]); &l;span class=\&q;comment\&q;&g;// 对左右筷子互斥访问&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;////&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//eat&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;////&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]); &l;span class=\&q;comment\&q;&g;// 释放&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;////&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//think&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;////&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;但是这样会导致一个问题, 哲学家们可能会同时拿起左边的筷子, 在去拿右边的筷子时会发生阻塞&l;br&g;\n解决方案&l;/p&g;\n&l;ol&g;\n&l;li&g;最多允许四个哲学家同时拿左边的筷子&l;/li&g;\n&l;li&g;只有当哲学家左右两边的筷子均可以使用时才允许拿筷子&l;/li&g;\n&l;li&g;奇数哲学家先拿左边, 再拿右边的筷子. 偶数哲学家相反&l;/li&g;\n&l;/ol&g;\n&l;h2 id=\&q;方案-1\&q;&g;方案 1&l;a title=\&q;#方案-1\&q; href=\&q;#方案-1\&q;&g;&l;/a&g;&l;/h2&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore chopstick[&l;span class=\&q;number\&q;&g;5&l;/span&g;]=&a;#123;&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;&a;#125;; &l;span class=\&q;comment\&q;&g;// 筷子的信号量&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore r=&l;span class=\&q;number\&q;&g;4&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 只允许4个哲学家进餐&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;Pi()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(r);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//eat&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(r);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;获得信号量 r 的哲学家最多只有 4 个&l;br&g;\n最少有一个哲学家可以 eat, 使用完之后释放两只筷子, 不会出现死锁和饿死&l;/p&g;\n&l;h2 id=\&q;方案-2\&q;&g;方案 2&l;a title=\&q;#方案-2\&q; href=\&q;#方案-2\&q;&g;&l;/a&g;&l;/h2&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore chopstick[&l;span class=\&q;number\&q;&g;5&l;/span&g;]=&a;#123;&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;&a;#125;; &l;span class=\&q;comment\&q;&g;// 筷子的信号量&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore mutex=&l;span class=\&q;number\&q;&g;1&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 互斥访问变量&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;Pi()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]); &l;span class=\&q;comment\&q;&g;//*&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// eat&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// think&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;使用一个互斥变量实现线程同步, 但是, 这其实也不是一个完美的方案&l;br&g;\n假如一个哲学家 x 拿起了左右两边的筷子, 他右边的哲学家 y 拿起了他左边的筷子, 想去拿右边的筷子时会发生阻塞, 阻塞在 * 位置. 这个情况下只能等 x 放下了 x 左边的筷子, y 才能继续进行.&l;br&g;\n不过比较好的是, 这个方案并不会产生死锁的问题&l;/p&g;\n&l;h2 id=\&q;方案-3\&q;&g;方案 3&l;a title=\&q;#方案-3\&q; href=\&q;#方案-3\&q;&g;&l;/a&g;&l;/h2&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore chopstick[&l;span class=\&q;number\&q;&g;5&l;/span&g;]=&a;#123;&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;Pi()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;number\&q;&g;1&l;/span&g;)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(i%&l;span class=\&q;number\&q;&g;2&l;/span&g;！=&l;span class=\&q;number\&q;&g;0&l;/span&g;)&a;#123;&l;span class=\&q;comment\&q;&g;//奇数号哲学家&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(chopstick[i]);&l;span class=\&q;comment\&q;&g;//拿左边的&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;span class=\&q;comment\&q;&g;//右边的&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g;&a;#123;&l;span class=\&q;comment\&q;&g;//偶数号哲学家&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;span class=\&q;comment\&q;&g;//右边的&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(chopstick[i]);&l;span class=\&q;comment\&q;&g;//左边的&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// eat&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[i]);&l;span class=\&q;comment\&q;&g;//释放筷子资源&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(chopstick[(i+&l;span class=\&q;number\&q;&g;1&l;/span&g;)%&l;span class=\&q;number\&q;&g;5&l;/span&g;]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;读者-写者问题\&q;&g;读者-写者问题&l;a title=\&q;#读者-写者问题\&q; href=\&q;#读者-写者问题\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;要求:&l;/p&g;\n&l;ol&g;\n&l;li&g;可以多个读者同时读&l;/li&g;\n&l;li&g;但是不允许多个写者同时写, 只允许一个写者写&l;/li&g;\n&l;li&g;不允许在写的时候读, 也不能有新的写者来写&l;/li&g;\n&l;li&g;写者执行写之前, 不应该有读者或写者在操作&l;/li&g;\n&l;/ol&g;\n&l;p&g;共享数据是文件&l;/p&g;\n&l;h2 id=\&q;分析-2\&q;&g;分析&l;a title=\&q;#分析-2\&q; href=\&q;#分析-2\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;&l;strong&g;两类进程:&l;/strong&g; 读, 写者进程&l;br&g;\n**互斥关系: **1. 读进程-写进程 2. 写进程-写进程&l;br&g;\n写进程与其他进程都互斥. 首先, 写进程与写进程之间 需要一个信号量 rw, 在写者操作共享文件前后加上 PV 操作&l;br&g;\n其次, 读进程与写进程也互斥, 因此也需要 PV 操作. 但是如果一个读者在读取共享文件之前进行了 P(rw) 操作, 会导致其他读者无法读取. 怎么解决?&l;br&g;\n**使用一个 count 变量来解决, 记录当前有多少读进程. **&l;br&g;\n假设刚开始 count = 0 , 进行 P(rw) 保证不会有写进程参与进来, 之后 count++, 说明现在有一个读进程.&l;br&g;\n此时有另外一个读进程参与进来, 由于 count!=0, 那么他就不会进行 P(rw) 操作, 而是直接 count++. 这样我们就解决了读者进程之间的非互斥执行问题&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore rw=&l;span class=\&q;number\&q;&g;1&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 对文件的互斥访问&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; count = &l;span class=\&q;number\&q;&g;0&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 记录当前读进程数&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;reader()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(count==&l;span class=\&q;number\&q;&g;0&l;/span&g;) &l;span class=\&q;comment\&q;&g;// 如果当前没有读者&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        count++;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// read file&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        count--;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(count==&l;span class=\&q;number\&q;&g;0&l;/span&g;) &l;span class=\&q;comment\&q;&g;// 如果当前没有读者&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            signal(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;writer()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// write file&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;还存在一个问题&l;/strong&g;, count 变量是共享变量, 设想这样一种情况, count=0 时, 读者 1 if 判断执行, 刚要执行 P(rw) 时, count 现在还是 0, 与此同时另外一位读者也通过了 if 判断. 那么, 在读者一获得了 rw 权限之后, 读者 2 就会被阻塞.&l;br&g;\n还需要一个互斥变量来保证一气呵成地操作 count 变量&l;/p&g;\n&l;figure class=\&q;highlight cpp\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;semaphore rw=&l;span class=\&q;number\&q;&g;1&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 对文件的互斥访问&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; count = &l;span class=\&q;number\&q;&g;0&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 记录当前读进程数&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;semaphore mutex = &l;span class=\&q;number\&q;&g;1&l;/span&g;; &l;span class=\&q;comment\&q;&g;// 对count 变量的互斥访问&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;reader()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(count==&l;span class=\&q;number\&q;&g;0&l;/span&g;) &l;span class=\&q;comment\&q;&g;// 如果当前没有读者&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            wait(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        count++;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// read file&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        count--;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(count==&l;span class=\&q;number\&q;&g;0&l;/span&g;) &l;span class=\&q;comment\&q;&g;// 如果当前没有读者&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            signal(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(mutex);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;writer()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;do&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        wait(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// write file&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        signal(rw);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;span class=\&q;keyword\&q;&g;while&l;/span&g;(&l;span class=\&q;literal\&q;&g;true&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;套路-1\&q;&g;套路&l;a title=\&q;#套路-1\&q; href=\&q;#套路-1\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;写者关心文件是否被占用.&l;br&g;\n**读者团: **&l;/p&g;\n&l;ul&g;\n&l;li&g;第一个读者关心文件是否被占有, 未被占有就占用.&l;/li&g;\n&l;li&g;中间读者只增加读者团人数.&l;/li&g;\n&l;li&g;最后一个读者释放文件.&l;/li&g;\n&l;/ul&g;\n&l;p&g;设置一个信号量表示资源是否被占有, 使用另外一个信号量表示读者团中读者的数量.&l;br&g;\n&l;strong&g;特征: 资源占用, 团体性&l;/strong&g;&l;/p&g;\n&l;div&g;&l;h1 id=\&q;推荐文章\&q;&g;推荐文章&l;a title=\&q;#推荐文章\&q; href=\&q;%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\&q;&g;&l;/a&g;&l;/h1&g;&l;ul&g;&l;li&g;&l;a href=\&q;https://mvbbb.github.io/ldcb18/\&q;&g;内存管理&l;/a&g;&l;/li&g;&l;/ul&g;&l;/div&g;&q;,&q;prev&q;:{&q;title&q;:&q;内存管理&q;,&q;link&q;:&q;ldcb18&q;},&q;next&q;:{&q;title&q;:&q;洛谷【搜索】暴力专项训练&q;,&q;link&q;:&q;lvkhi9&q;},&q;plink&q;:&q;https://mvbbb.github.io/ognzg7/&q;,&q;toc&q;:[{&q;id&q;:&q;不同线程之间的同步问题&q;,&q;title&q;:&q;不同线程之间的同步问题&q;,&q;index&q;:&q;1&q;},{&q;id&q;:&q;生产者-消费者问题&q;,&q;title&q;:&q;生产者-消费者问题&q;,&q;index&q;:&q;2&q;,&q;children&q;:[{&q;id&q;:&q;分析&q;,&q;title&q;:&q;分析&q;,&q;index&q;:&q;2.1&q;},{&q;id&q;:&q;套路&q;,&q;title&q;:&q;套路&q;,&q;index&q;:&q;2.2&q;}]},{&q;id&q;:&q;哲学家进餐问题&q;,&q;title&q;:&q;哲学家进餐问题&q;,&q;index&q;:&q;3&q;,&q;children&q;:[{&q;id&q;:&q;分析-1&q;,&q;title&q;:&q;分析&q;,&q;index&q;:&q;3.1&q;},{&q;id&q;:&q;方案-1&q;,&q;title&q;:&q;方案 1&q;,&q;index&q;:&q;3.2&q;},{&q;id&q;:&q;方案-2&q;,&q;title&q;:&q;方案 2&q;,&q;index&q;:&q;3.3&q;},{&q;id&q;:&q;方案-3&q;,&q;title&q;:&q;方案 3&q;,&q;index&q;:&q;3.4&q;}]},{&q;id&q;:&q;读者-写者问题&q;,&q;title&q;:&q;读者-写者问题&q;,&q;index&q;:&q;4&q;,&q;children&q;:[{&q;id&q;:&q;分析-2&q;,&q;title&q;:&q;分析&q;,&q;index&q;:&q;4.1&q;},{&q;id&q;:&q;套路-1&q;,&q;title&q;:&q;套路&q;,&q;index&q;:&q;4.2&q;}]},{&q;id&q;:&q;推荐文章&q;,&q;title&q;:&q;推荐文章&q;,&q;index&q;:&q;5&q;}],&q;copyright&q;:{&q;author&q;:&q;Mvbbb&q;,&q;link&q;:&q;&l;a href=\&q;https://mvbbb.github.io/ognzg7/\&q; title=\&q;经典进程同步问题\&q;&g;https://mvbbb.github.io/ognzg7/&l;/a&g;&q;,&q;license&q;:&q;Attribution-NonCommercial-NoDerivatives 4.0 International (&l;a href=\&q;https://creativecommons.org/licenses/by-nc-sa/4.0/\&q; rel=\&q;external nofollow noopener\&q; target=\&q;_blank\&q;&g;CC BY-NC-ND 4.0&l;/a&g;)&q;}}}</script></head><body lang="en"><div style="display:none"><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1279526637&amp;web_id=1279526637"></script></div>
<!-- hexo injector head_end start --><link href="//fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat" rel="stylesheet"><link href="/styles.43478ea7e28ed563c48b.css" rel="stylesheet">
<script src="/config.f667b9e14173c512056d.js"></script>

<link rel="stylesheet" href="/theme.6191587147d30da44d8f.css" is="theme">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0">
<!-- hexo injector body_begin start --><is-a class="φbm φk" ng-version="10.0.11"><is-l class="φeb φh"><div class="φel"><section class="φem"><header class="φec φf"><!----><is-c class="φed"><img draggable="false" class="φbw φw" src="images/avatar.jpg" alt="" title="" width="160" height="160"></is-c><!----><a href="" class="φef φa φu">Mvbbb</a><p class="φee">Who i am,who u are</p></header><div class="φeq φf"><a routerlink="/archives" class="φer φu" href="/archives"><span class="φd">45</span><span>Archives</span></a><a class="φer φu" href="/categories/Java"><span class="φd">14</span><span>Categories</span></a><!----><a routerlink="/tags" class="φer φu" href="/tags"><span class="φd">34</span><span>Tags</span></a><!----></div><!----><nav class="φen"><a class="φeo φbd φj φc φu φo" href="/">Home</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/about">About</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/search">Search</a><!----><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φeo φbd φj φc φu φo" href="https://www.yuque.com/u1296515/zb4bwb">Yuque</a><!----><!----><!----></nav><!----><!----></section><footer class="φeg φeh"><div class="φej"><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-email" href="mailto:3212618781@qq.com">email</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-feed" href="https://mvbbb.github.io/rss2.xml">feed</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-github" href="https://github.com/Mvbbb">github</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-myspace" href="/links">myspace</a><!----></div><!----><p class="φbk φz">© 2019-2021 ❤ <a href="https://github.com/Mvbbb">Mvbbb</a></p><!----><!----><!----></footer></div></is-l><div class="φbo"><div class="φbn"><div class="φbs φbe"><main class="φbr φbf"><router-outlet></router-outlet><is-s class="φfx φf"><header class="φgh φgi" style="background-image:;background-color:;"><div class="φgq"><h1 class="φgt">经典进程同步问题</h1><!----><p class="φgj φr"><span class="φgk φgo">Oct 14, 2020</span><a class="φgk φgm φu" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><!----><!----><!----></p><!----><!----></div></header><article itemscope="" itemtype="http://schema.org/Article" class="φga" data-title="经典进程同步问题"><div itemprop="articleBody" issnippet="" iszoomable="" class="φbk φh φz"><p>一些比较经典的, 书上的进程同步问题<br>
总结的解题思路:</p>
<ol>
<li><strong>画图理解题目</strong></li>
<li>判断题目类型</li>
<li>分析进程数目, 填写进程模板</li>
<li>补充基本代码</li>
<li>补充 PV 代码</li>
<li>检查调整代码</li>
</ol>
<a id="more"></a>
<h1 id="不同线程之间的同步问题">不同线程之间的同步问题<a title="#不同线程之间的同步问题" href="#不同线程之间的同步问题"></a></h1>
<p>由于不同线程之间存在异步性, 两个线程的语句执行先后顺序无法确定.<br>
使用信号量机制来实现不同线程之间的同步问题<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740872722-0444194a-25a9-41c1-8237-1dc566f9199d.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=1040&amp;size=190693&amp;status=done&amp;style=none&amp;width=520" alt="image.png"><br>
以此为延申, 如何实现拓扑排序<br>
<img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740921016-80a8c6c3-b480-4700-a694-4ba1411e5032.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=1216&amp;size=173276&amp;status=done&amp;style=none&amp;width=608" alt="image.png"><br>
注意在线程同步中信号量初值为 0, 但是在线程互斥中信号量初值为 1</p>
<h1 id="生产者-消费者问题">生产者-消费者问题<a title="#生产者-消费者问题" href="#生产者-消费者问题"></a></h1>
<h2 id="分析">分析<a title="#分析" href="#分析"></a></h2>
<p>共享变量为缓存池里面的产品数<br>
缓冲区满, 生产者必须等待. 缓冲区空, 消费者必须等待<br>
因为缓冲区的数量是临界资源, 只使用一个互斥变量来实现线程互斥如何?</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore n = <span class="number">5</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">producer (){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(mutex);</span><br><span class="line">        signal(n);</span><br><span class="line">        <span class="comment">// produce</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(n);</span><br><span class="line">        <span class="comment">// consume</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个代码存在很严重的问题. 假设只有一个 consumer 进程先启动, 他顺利执行到 consume 操作. 但是此时的缓冲区中还没有商品.<br>
我们对此进行分析一下.</p>
<ul>
<li>如果缓冲区满，生产者是不能生产的，所以生产者进程受到消费者进程的制约；</li>
<li>如果缓冲区空，消费者是不能消费的，所以消费者进程受到生产者进程的制约。</li>
</ul>
<p>所以 P/C 问题不仅仅是线程互斥, 还包含了线程同步, 线程同步仅仅使用一个信号量是不够的.<br>
<strong>因此我们需要额外设置两个信号量来实现线程的同步问题.</strong><br>
生产者在乎的是剩余空间 empty. 消费者在乎的是占用空间 full.<br>
<strong>生产者在生产商品之前应该 P(empty) , 消费者在消费商品之前应该 P(full).</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1602744972535-bc2a1dd6-427e-4237-a934-7170cb571dc1.png#align=left&amp;display=inline&amp;height=129&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=257&amp;originWidth=1157&amp;size=47323&amp;status=done&amp;style=none&amp;width=578.5" alt="image.png" class="φcx"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(empty);  <span class="comment">// P消耗一个空闲缓冲区</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="comment">// produce</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);  <span class="comment">// V增加一个产品</span></span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(full);  <span class="comment">// P消耗一个产品, 非缓冲区</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="comment">// consume</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty); <span class="comment">// V增加一个空闲缓冲区</span></span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>是否可以交换 producer 或者 consumer 中的两个 P 操作呢?<br>
我们交换 producer 里面的两个 P 操作</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// producer</span></span><br><span class="line">wait(mutex);</span><br><span class="line">wait(empty);  <span class="comment">// P消耗一个空闲缓冲区</span></span><br></pre></td></tr></tbody></table></figure>
<p>假设此时缓冲区为满, empty = 0, full=n;<br>
producer 执行 P(mutex), mutex 变为 0, 执行 P(empty), 这个时候会被阻塞.<br>
现在切换回 consumer 进程, 执行 wait(full) 没有问题, 执行 wait(mutex) 会被阻塞. 这样就会出现线程死锁.<br>
因此实现互斥的 P 操作要在实现 同步的 P 操作之后执行<br>
但是 V 操作的执行顺序不会导致线程.</p>
<h2 id="套路">套路<a title="#套路" href="#套路"></a></h2>
<ol>
<li>分析题目题型: 容器大小固定, 为 P/C 问题</li>
<li>分析进程数量: 不同个体对应不同的进程</li>
<li>分析每个进程关心的: 消费者只关心<strong>占用空间,</strong> 生产者只关心<strong>剩余空间</strong></li>
<li>填写进程基本操作</li>
<li>补充 PV 代码</li>
</ol>
<h1 id="哲学家进餐问题">哲学家进餐问题<a title="#哲学家进餐问题" href="#哲学家进餐问题"></a></h1>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1552854/1602683081888-009a08f2-3d5f-4f1c-9d4e-ea4d4230ee95.png#align=left&amp;display=inline&amp;height=57&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=113&amp;originWidth=1119&amp;size=49746&amp;status=done&amp;style=none&amp;width=559.5" alt="image.png" class="φcx"></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1YE411D7nH?p=27" target="_blank" rel="external nofollow noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=27</a></p>
</blockquote>
<h2 id="分析-1">分析<a title="#分析-1" href="#分析-1"></a></h2>
<p>临界资源: 筷子<br>
对哲学家进行编号, 第 i 位哲学家的活动可以描述为</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>}; <span class="comment">// 筷子的信号量</span></span><br><span class="line">Pi(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 对左右筷子互斥访问</span></span><br><span class="line">        <span class="comment">////</span></span><br><span class="line">        <span class="comment">//eat</span></span><br><span class="line">        <span class="comment">////</span></span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 释放</span></span><br><span class="line">        <span class="comment">////</span></span><br><span class="line">        <span class="comment">//think</span></span><br><span class="line">        <span class="comment">////</span></span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是这样会导致一个问题, 哲学家们可能会同时拿起左边的筷子, 在去拿右边的筷子时会发生阻塞<br>
解决方案</p>
<ol>
<li>最多允许四个哲学家同时拿左边的筷子</li>
<li>只有当哲学家左右两边的筷子均可以使用时才允许拿筷子</li>
<li>奇数哲学家先拿左边, 再拿右边的筷子. 偶数哲学家相反</li>
</ol>
<h2 id="方案-1">方案 1<a title="#方案-1" href="#方案-1"></a></h2>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>}; <span class="comment">// 筷子的信号量</span></span><br><span class="line">semaphore r=<span class="number">4</span>; <span class="comment">// 只允许4个哲学家进餐</span></span><br><span class="line">Pi(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(r);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">//eat</span></span><br><span class="line">        signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(r);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>获得信号量 r 的哲学家最多只有 4 个<br>
最少有一个哲学家可以 eat, 使用完之后释放两只筷子, 不会出现死锁和饿死</p>
<h2 id="方案-2">方案 2<a title="#方案-2" href="#方案-2"></a></h2>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>}; <span class="comment">// 筷子的信号量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">// 互斥访问变量</span></span><br><span class="line"></span><br><span class="line">Pi(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//*</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        <span class="comment">// eat</span></span><br><span class="line">        signal(chopstick);</span><br><span class="line">        signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">// think</span></span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用一个互斥变量实现线程同步, 但是, 这其实也不是一个完美的方案<br>
假如一个哲学家 x 拿起了左右两边的筷子, 他右边的哲学家 y 拿起了他左边的筷子, 想去拿右边的筷子时会发生阻塞, 阻塞在 * 位置. 这个情况下只能等 x 放下了 x 左边的筷子, y 才能继续进行.<br>
不过比较好的是, 这个方案并不会产生死锁的问题</p>
<h2 id="方案-3">方案 3<a title="#方案-3" href="#方案-3"></a></h2>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">Pi(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>！=<span class="number">0</span>){<span class="comment">//奇数号哲学家</span></span><br><span class="line">            wait(chopstick[i]);<span class="comment">//拿左边的</span></span><br><span class="line">            wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//右边的</span></span><br><span class="line">        }<span class="keyword">else</span>{<span class="comment">//偶数号哲学家</span></span><br><span class="line">            wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//右边的</span></span><br><span class="line">            wait(chopstick[i]);<span class="comment">//左边的</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// eat</span></span><br><span class="line">        signal(chopstick[i]);<span class="comment">//释放筷子资源</span></span><br><span class="line">        signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="读者-写者问题">读者-写者问题<a title="#读者-写者问题" href="#读者-写者问题"></a></h1>
<p>要求:</p>
<ol>
<li>可以多个读者同时读</li>
<li>但是不允许多个写者同时写, 只允许一个写者写</li>
<li>不允许在写的时候读, 也不能有新的写者来写</li>
<li>写者执行写之前, 不应该有读者或写者在操作</li>
</ol>
<p>共享数据是文件</p>
<h2 id="分析-2">分析<a title="#分析-2" href="#分析-2"></a></h2>
<p><strong>两类进程:</strong> 读, 写者进程<br>
**互斥关系: **1. 读进程-写进程 2. 写进程-写进程<br>
写进程与其他进程都互斥. 首先, 写进程与写进程之间 需要一个信号量 rw, 在写者操作共享文件前后加上 PV 操作<br>
其次, 读进程与写进程也互斥, 因此也需要 PV 操作. 但是如果一个读者在读取共享文件之前进行了 P(rw) 操作, 会导致其他读者无法读取. 怎么解决?<br>
**使用一个 count 变量来解决, 记录当前有多少读进程. **<br>
假设刚开始 count = 0 , 进行 P(rw) 保证不会有写进程参与进来, 之后 count++, 说明现在有一个读进程.<br>
此时有另外一个读进程参与进来, 由于 count!=0, 那么他就不会进行 P(rw) 操作, 而是直接 count++. 这样我们就解决了读者进程之间的非互斥执行问题</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 对文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前读进程数</span></span><br><span class="line"></span><br><span class="line">reader(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">// 如果当前没有读者</span></span><br><span class="line">            wait(rw);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// read file</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">// 如果当前没有读者</span></span><br><span class="line">            signal(rw);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">writer(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(rw);</span><br><span class="line">        <span class="comment">// write file</span></span><br><span class="line">        signal(rw);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>还存在一个问题</strong>, count 变量是共享变量, 设想这样一种情况, count=0 时, 读者 1 if 判断执行, 刚要执行 P(rw) 时, count 现在还是 0, 与此同时另外一位读者也通过了 if 判断. 那么, 在读者一获得了 rw 权限之后, 读者 2 就会被阻塞.<br>
还需要一个互斥变量来保证一气呵成地操作 count 变量</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">// 对文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前读进程数</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 对count 变量的互斥访问</span></span><br><span class="line">reader(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">// 如果当前没有读者</span></span><br><span class="line">            wait(rw);</span><br><span class="line">        count++;</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read file</span></span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">// 如果当前没有读者</span></span><br><span class="line">            signal(rw);</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">writer(){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        wait(rw);</span><br><span class="line">        <span class="comment">// write file</span></span><br><span class="line">        signal(rw);</span><br><span class="line">    }<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="套路-1">套路<a title="#套路-1" href="#套路-1"></a></h2>
<p>写者关心文件是否被占用.<br>
**读者团: **</p>
<ul>
<li>第一个读者关心文件是否被占有, 未被占有就占用.</li>
<li>中间读者只增加读者团人数.</li>
<li>最后一个读者释放文件.</li>
</ul>
<p>设置一个信号量表示资源是否被占有, 使用另外一个信号量表示读者团中读者的数量.<br>
<strong>特征: 资源占用, 团体性</strong></p>
<div><h1 id="推荐文章">推荐文章<a title="#推荐文章" href="%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0"></a></h1><ul><li><a href="https://mvbbb.github.io/ldcb18/">内存管理</a></li></ul></div></div><is-f class="φcc φv φs"><!----><ul class="φcg"><li class="φce"><strong class="φcf">Author<span>:</span></strong><p class="φcd">Mvbbb</p></li><li class="φce"><strong class="φcf">Link<span>:</span></strong><p class="φcd"><a href="https://mvbbb.github.io/ognzg7/" title="经典进程同步问题">https://mvbbb.github.io/ognzg7/</a></p></li><li class="φce"><strong class="φcf">Copyright<span>:</span></strong><p class="φcd">Attribution-NonCommercial-NoDerivatives 4.0 International (<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener" target="_blank">CC BY-NC-ND 4.0</a>)</p></li><!----></ul><!----></is-f><!----><!----><!----></article><footer class="φgb φh"><div class="φgg"><is-m class="φet"><a class="φeu φs φq" href="/tags/OS">OS</a></is-m><!----></div><!----><div class="φgc"><a class="φgd φgf φu" href="/ldcb18">内存管理</a><!----><a class="φgd φge φu" href="/lvkhi9">洛谷【搜索】暴力专项训练</a><!----></div><!----></footer><is-e class="φbz φh"><div issnippet="" class="φbh"><div id="tcomment"></div>


</div><!----><!----><!----><!----></is-e><!----><!----><!----></is-s><!----></main><!----></div></div></div><is-g class="φch"><div class="φcq"><span class="φbg icon-up"></span><span class="φbg icon-down"></span><!----><span class="φbg icon-toc"></span><!----><span class="φbg icon-search"></span><!----></div><div class="φcj φck"><svg class="φcp"><defs><filter id="dp"><feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur></filter></defs><circle filter="url(#dp)" fill="rgba(0,0,0,.3)" cx="50%" cy="52%" r="44%"></circle><circle cx="50%" cy="50%" r="44%" class="φcl φbb"></circle><circle cx="50%" cy="50%" r="48%" class="φco φba" stroke-dasharray="0% 314.15926%"></circle><!----><g class="φcm"><circle r=".2rem" cx="0" cy="-.8rem"></circle><circle r=".2rem"></circle><circle r=".2rem" cx="0" cy=".8rem"></circle></g><!----></svg></div></is-g><is-n class="φev φf"><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">1 </span><!----><span class="φfc">不同线程之间的同步问题</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">2 </span><!----><span class="φfc">生产者-消费者问题</span></a><div class="φex"><a class="φfa φu"><span class="φfb φd">2.1 </span><!----><span class="φfc">分析</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">2.2 </span><!----><span class="φfc">套路</span></a><!----></div><!----><!----><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">3 </span><!----><span class="φfc">哲学家进餐问题</span></a><div class="φex"><a class="φfa φu"><span class="φfb φd">3.1 </span><!----><span class="φfc">分析</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">3.2 </span><!----><span class="φfc">方案 1</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">3.3 </span><!----><span class="φfc">方案 2</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">3.4 </span><!----><span class="φfc">方案 3</span></a><!----></div><!----><!----><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">4 </span><!----><span class="φfc">读者-写者问题</span></a><div class="φex"><a class="φfa φu"><span class="φfb φd">4.1 </span><!----><span class="φfc">分析</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">4.2 </span><!----><span class="φfc">套路</span></a><!----></div><!----><!----><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">5 </span><!----><span class="φfc">推荐文章</span></a><!----></div><!----></is-n><!----><!----></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js"></script><script src="/runtime.b15aa7186c559b492b7d.js"></script><script src="/polyfills.824ff89b5f3ca4543a31.js"></script><script src="/main.03652fc423a687c817e8.js"></script><!-- hexo injector body_end end -->

</body></html>