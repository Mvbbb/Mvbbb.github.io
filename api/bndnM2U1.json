{"title":"Java 细节","date":"2020-09-06T10:58:03.000Z","date_formatted":{"ll":"Sep 6, 2020","L":"09/06/2020","MM-DD":"09-06"},"link":"nwg3e5","comments":true,"tags":["Java"],"categories":["Java","JavaSe"],"updated":"2021-02-03T04:21:00.497Z","content":"<p>主要是 Java 学习过程中的小知识点</p>\n<a id=\"more\"></a>\n<h1 id=\"集合\">集合<a title=\"#集合\" href=\"#集合\"></a></h1>\n<blockquote>\n<p>参考 <a href=\"https://blog.csdn.net/ThinkWon/article/details/104588551\" target=\"_blank\" rel=\"external nofollow noopener\">https://blog.csdn.net/ThinkWon/article/details/104588551</a></p>\n</blockquote>\n<ol>\n<li>HashSet, LinkedHashSet 实现的是 Collection 接口, 但是底层确是基于 HashMap</li>\n<li>实现 Collection 接口的集合的遍历: 可以随机访问的可以使用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</li>\n<li>数组与 List 之间的转换</li>\n</ol>\n<ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<ol start=\"4\">\n<li>线程不安全的情况下如何使用 ArrayList: 使用 Collections 提供的方法, 将 arrayList 转化为线程安全的</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>向 HashMap 中添加 K/V 对: HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V。</li>\n<li>两个对象有相同的 hashcode 值，它们不一定是相等的. HashMap 里面添加元素, 出现 key 的 hashcode 相同时会进一步调用 equals. 相同, 原 K/V 被替换. 不相同, 放入该位置的链表中.</li>\n<li>在 Java 中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</li>\n<li>JDK 1.7 与 JDK 1.8 中 HashMap 底层的区别</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599391994800-a8390d20-ac93-46ed-a8c6-13522634be6e.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=574&amp;originWidth=1006&amp;size=82795&amp;status=done&amp;style=none&amp;width=503\" alt=\"image.png\" class=\"φcx\"></p>\n<h1 id=\"类与对象\">类与对象<a title=\"#类与对象\" href=\"#类与对象\"></a></h1>\n<ol>\n<li>\n<p>Java 中主类是指 <s>**类名与文件名一致, **</s><strong>且包含 main 的类</strong></p>\n</li>\n<li>\n<p>公共类是指: <strong>public 修饰的类,该类名必须与文件名一致</strong></p>\n</li>\n<li>\n<p><strong>如果源文件中有多个类，这些类必须有一个 public 类</strong></p>\n</li>\n<li>\n<p>可以把任何一种数据类型的变量赋给 Object 类型的变量。</p>\n<blockquote>\n<p>基本数据类型会自动装箱</p>\n</blockquote>\n</li>\n<li>\n<p>包提供可见性控制机制.</p>\n</li>\n<li>\n<p>在类方法中调用本类的类方法时可直接调用, 不能使用 this</p>\n<blockquote>\n<p>本类的方法是指 static 方法</p>\n</blockquote>\n</li>\n<li>\n<p>调用指向 null 的对象的静态方法是可以正确运行的, 属于静态绑定</p>\n</li>\n<li>\n<p>i =  ++(i++); 编译错误</p>\n<blockquote>\n<p>++（  ）   括号里面必须是一个变量，而 i ++   是一个字面量。</p>\n</blockquote>\n</li>\n<li>\n<p>在使用匿名内部类的过程中，我们需要注意如下几点：</p>\n<ol>\n<li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li>\n<li>匿名内部类中是不能定义构造函数的。</li>\n<li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li>\n<li>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</li>\n<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n<blockquote>\n<p><a href=\"https://www.nowcoder.com/questionTerminal/9cbffe1607ff450580ae665d2625bce9\" target=\"_blank\" rel=\"external nofollow noopener\">https://www.nowcoder.com/questionTerminal/9cbffe1607ff450580ae665d2625bce9</a></p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>\n<p>Integer 的缓存区间是 [-128,127] , 在该区间内 120==120 true</p>\n</li>\n<li>\n<p>Java 在序列化时不会实例化 static 变量和 transient 修饰的变量，因为 static 代表类的成员，transient 代表对象的临时数据，被声明这两种类型的数据成员不能被序列化</p>\n</li>\n<li>\n<p>++/-- 优先级问题</p>\n</li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.nowcoder.com/test/question/done?tid=37584420&amp;qid=304925#summary\" target=\"_blank\" rel=\"external nofollow noopener\">https://www.nowcoder.com/test/question/done?tid=37584420&amp;qid=304925#summary</a></p>\n</blockquote>\n<ol start=\"13\">\n<li>Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素 1)事件源 2)事件对象 3)事件监听器</li>\n</ol>\n<h1 id=\"异常处理\">异常处理<a title=\"#异常处理\" href=\"#异常处理\"></a></h1>\n<ol>\n<li>不管有多少个 catch，只会匹配一个 catch</li>\n<li>finally 一定会在 return 之前执行，但是如果 finally 使用了 return 或者 throw 语句，将会使 trycatch 中的 return 或者 throw 失效</li>\n<li>SimpleDateFormat 是线程不安全的</li>\n<li>ConcurrentHashMap 使用 segment 来分段和管理锁，segment 继承自 ReentrantLock，因此 ConcurrentHashMap 使用 ReentrantLock 来保证线程安全。</li>\n</ol>\n<div><h1 id=\"推荐文章\">推荐文章<a title=\"#推荐文章\" href=\"%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\"></a></h1><ul><li><a href=\"https://mvbbb.github.io/cxnppw/\">使用 Java 实现简单的 WebServer</a></li><li><a href=\"https://mvbbb.github.io/hy5u9w/\">JDBC与mysql数据库交互</a></li><li><a href=\"https://mvbbb.github.io/sn0gdd/\">《码出高效》笔记</a></li><li><a href=\"https://kevin1061517.github.io/blog/posts/Java/8f30/\">Practical Java筆記</a></li></ul></div>","prev":{"title":"《码出高效》笔记","link":"sn0gdd"},"next":{"title":"博客配置修改","link":"qtd9qr"},"plink":"https://mvbbb.github.io/nwg3e5/","toc":[{"id":"集合","title":"集合","index":"1"},{"id":"类与对象","title":"类与对象","index":"2"},{"id":"异常处理","title":"异常处理","index":"3"},{"id":"推荐文章","title":"推荐文章","index":"4"}],"copyright":{"author":"Mvbbb","link":"<a href=\"https://mvbbb.github.io/nwg3e5/\" title=\"Java 细节\">https://mvbbb.github.io/nwg3e5/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}