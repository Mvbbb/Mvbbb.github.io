{"title":"经典进程同步问题","date":"2020-10-14T13:41:43.000Z","date_formatted":{"ll":"Oct 14, 2020","L":"10/14/2020","MM-DD":"10-14"},"link":"ognzg7","comments":true,"tags":["OS"],"categories":["操作系统"],"updated":"2021-02-03T04:20:59.525Z","content":"<p>一些比较经典的, 书上的进程同步问题<br>\n总结的解题思路:</p>\n<ol>\n<li><strong>画图理解题目</strong></li>\n<li>判断题目类型</li>\n<li>分析进程数目, 填写进程模板</li>\n<li>补充基本代码</li>\n<li>补充 PV 代码</li>\n<li>检查调整代码</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"不同线程之间的同步问题\">不同线程之间的同步问题<a title=\"#不同线程之间的同步问题\" href=\"#不同线程之间的同步问题\"></a></h1>\n<p>由于不同线程之间存在异步性, 两个线程的语句执行先后顺序无法确定.<br>\n使用信号量机制来实现不同线程之间的同步问题<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740872722-0444194a-25a9-41c1-8237-1dc566f9199d.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=1040&amp;size=190693&amp;status=done&amp;style=none&amp;width=520\" alt=\"image.png\"><br>\n以此为延申, 如何实现拓扑排序<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1602740921016-80a8c6c3-b480-4700-a694-4ba1411e5032.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=1216&amp;size=173276&amp;status=done&amp;style=none&amp;width=608\" alt=\"image.png\"><br>\n注意在线程同步中信号量初值为 0, 但是在线程互斥中信号量初值为 1</p>\n<h1 id=\"生产者-消费者问题\">生产者-消费者问题<a title=\"#生产者-消费者问题\" href=\"#生产者-消费者问题\"></a></h1>\n<h2 id=\"分析\">分析<a title=\"#分析\" href=\"#分析\"></a></h2>\n<p>共享变量为缓存池里面的产品数<br>\n缓冲区满, 生产者必须等待. 缓冲区空, 消费者必须等待<br>\n因为缓冲区的数量是临界资源, 只使用一个互斥变量来实现线程互斥如何?</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore n = <span class=\"number\">5</span>;</span><br><span class=\"line\">semaphore mutex=<span class=\"number\">1</span>;</span><br><span class=\"line\">producer ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        signal(n);</span><br><span class=\"line\">        <span class=\"comment\">// produce</span></span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">consumer()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        wait(n);</span><br><span class=\"line\">        <span class=\"comment\">// consume</span></span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个代码存在很严重的问题. 假设只有一个 consumer 进程先启动, 他顺利执行到 consume 操作. 但是此时的缓冲区中还没有商品.<br>\n我们对此进行分析一下.</p>\n<ul>\n<li>如果缓冲区满，生产者是不能生产的，所以生产者进程受到消费者进程的制约；</li>\n<li>如果缓冲区空，消费者是不能消费的，所以消费者进程受到生产者进程的制约。</li>\n</ul>\n<p>所以 P/C 问题不仅仅是线程互斥, 还包含了线程同步, 线程同步仅仅使用一个信号量是不够的.<br>\n<strong>因此我们需要额外设置两个信号量来实现线程的同步问题.</strong><br>\n生产者在乎的是剩余空间 empty. 消费者在乎的是占用空间 full.<br>\n<strong>生产者在生产商品之前应该 P(empty) , 消费者在消费商品之前应该 P(full).</strong></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1602744972535-bc2a1dd6-427e-4237-a934-7170cb571dc1.png#align=left&amp;display=inline&amp;height=129&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=257&amp;originWidth=1157&amp;size=47323&amp;status=done&amp;style=none&amp;width=578.5\" alt=\"image.png\" class=\"φcx\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;</span><br><span class=\"line\">semaphore empty = n;</span><br><span class=\"line\">semaphore full = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">producer()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(empty);  <span class=\"comment\">// P消耗一个空闲缓冲区</span></span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        <span class=\"comment\">// produce</span></span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\">        signal(full);  <span class=\"comment\">// V增加一个产品</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">consumer()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(full);  <span class=\"comment\">// P消耗一个产品, 非缓冲区</span></span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        <span class=\"comment\">// consume</span></span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\">        signal(empty); <span class=\"comment\">// V增加一个空闲缓冲区</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是否可以交换 producer 或者 consumer 中的两个 P 操作呢?<br>\n我们交换 producer 里面的两个 P 操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\">wait(mutex);</span><br><span class=\"line\">wait(empty);  <span class=\"comment\">// P消耗一个空闲缓冲区</span></span><br></pre></td></tr></table></figure>\n<p>假设此时缓冲区为满, empty = 0, full=n;<br>\nproducer 执行 P(mutex), mutex 变为 0, 执行 P(empty), 这个时候会被阻塞.<br>\n现在切换回 consumer 进程, 执行 wait(full) 没有问题, 执行 wait(mutex) 会被阻塞. 这样就会出现线程死锁.<br>\n因此实现互斥的 P 操作要在实现 同步的 P 操作之后执行<br>\n但是 V 操作的执行顺序不会导致线程.</p>\n<h2 id=\"套路\">套路<a title=\"#套路\" href=\"#套路\"></a></h2>\n<ol>\n<li>分析题目题型: 容器大小固定, 为 P/C 问题</li>\n<li>分析进程数量: 不同个体对应不同的进程</li>\n<li>分析每个进程关心的: 消费者只关心<strong>占用空间,</strong> 生产者只关心<strong>剩余空间</strong></li>\n<li>填写进程基本操作</li>\n<li>补充 PV 代码</li>\n</ol>\n<h1 id=\"哲学家进餐问题\">哲学家进餐问题<a title=\"#哲学家进餐问题\" href=\"#哲学家进餐问题\"></a></h1>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1602683081888-009a08f2-3d5f-4f1c-9d4e-ea4d4230ee95.png#align=left&amp;display=inline&amp;height=57&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=113&amp;originWidth=1119&amp;size=49746&amp;status=done&amp;style=none&amp;width=559.5\" alt=\"image.png\" class=\"φcx\"></p>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1YE411D7nH?p=27\" target=\"_blank\" rel=\"external nofollow noopener\">https://www.bilibili.com/video/BV1YE411D7nH?p=27</a></p>\n</blockquote>\n<h2 id=\"分析-1\">分析<a title=\"#分析-1\" href=\"#分析-1\"></a></h2>\n<p>临界资源: 筷子<br>\n对哲学家进行编号, 第 i 位哲学家的活动可以描述为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 筷子的信号量</span></span><br><span class=\"line\">Pi()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(chopstick[i]);</span><br><span class=\"line\">        wait(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]); <span class=\"comment\">// 对左右筷子互斥访问</span></span><br><span class=\"line\">        <span class=\"comment\">////</span></span><br><span class=\"line\">        <span class=\"comment\">//eat</span></span><br><span class=\"line\">        <span class=\"comment\">////</span></span><br><span class=\"line\">        signal(chopstick[i]);</span><br><span class=\"line\">        signal(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]); <span class=\"comment\">// 释放</span></span><br><span class=\"line\">        <span class=\"comment\">////</span></span><br><span class=\"line\">        <span class=\"comment\">//think</span></span><br><span class=\"line\">        <span class=\"comment\">////</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这样会导致一个问题, 哲学家们可能会同时拿起左边的筷子, 在去拿右边的筷子时会发生阻塞<br>\n解决方案</p>\n<ol>\n<li>最多允许四个哲学家同时拿左边的筷子</li>\n<li>只有当哲学家左右两边的筷子均可以使用时才允许拿筷子</li>\n<li>奇数哲学家先拿左边, 再拿右边的筷子. 偶数哲学家相反</li>\n</ol>\n<h2 id=\"方案-1\">方案 1<a title=\"#方案-1\" href=\"#方案-1\"></a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 筷子的信号量</span></span><br><span class=\"line\">semaphore r=<span class=\"number\">4</span>; <span class=\"comment\">// 只允许4个哲学家进餐</span></span><br><span class=\"line\">Pi()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(r);</span><br><span class=\"line\">        wait(chopstick[i]);</span><br><span class=\"line\">        wait(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//eat</span></span><br><span class=\"line\">        signal(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);</span><br><span class=\"line\">        signal(chopstick[i]);</span><br><span class=\"line\">        signal(r);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获得信号量 r 的哲学家最多只有 4 个<br>\n最少有一个哲学家可以 eat, 使用完之后释放两只筷子, 不会出现死锁和饿死</p>\n<h2 id=\"方案-2\">方案 2<a title=\"#方案-2\" href=\"#方案-2\"></a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 筷子的信号量</span></span><br><span class=\"line\">semaphore mutex=<span class=\"number\">1</span>; <span class=\"comment\">// 互斥访问变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">Pi()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        wait(chopstick[i]);</span><br><span class=\"line\">        wait(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]); <span class=\"comment\">//*</span></span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\">        <span class=\"comment\">// eat</span></span><br><span class=\"line\">        signal(chopstick);</span><br><span class=\"line\">        signal(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// think</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用一个互斥变量实现线程同步, 但是, 这其实也不是一个完美的方案<br>\n假如一个哲学家 x 拿起了左右两边的筷子, 他右边的哲学家 y 拿起了他左边的筷子, 想去拿右边的筷子时会发生阻塞, 阻塞在 * 位置. 这个情况下只能等 x 放下了 x 左边的筷子, y 才能继续进行.<br>\n不过比较好的是, 这个方案并不会产生死锁的问题</p>\n<h2 id=\"方案-3\">方案 3<a title=\"#方案-3\" href=\"#方案-3\"></a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">Pi()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>！=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//奇数号哲学家</span></span><br><span class=\"line\">            wait(chopstick[i]);<span class=\"comment\">//拿左边的</span></span><br><span class=\"line\">            wait(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);<span class=\"comment\">//右边的</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//偶数号哲学家</span></span><br><span class=\"line\">            wait(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);<span class=\"comment\">//右边的</span></span><br><span class=\"line\">            wait(chopstick[i]);<span class=\"comment\">//左边的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// eat</span></span><br><span class=\"line\">        signal(chopstick[i]);<span class=\"comment\">//释放筷子资源</span></span><br><span class=\"line\">        signal(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"读者-写者问题\">读者-写者问题<a title=\"#读者-写者问题\" href=\"#读者-写者问题\"></a></h1>\n<p>要求:</p>\n<ol>\n<li>可以多个读者同时读</li>\n<li>但是不允许多个写者同时写, 只允许一个写者写</li>\n<li>不允许在写的时候读, 也不能有新的写者来写</li>\n<li>写者执行写之前, 不应该有读者或写者在操作</li>\n</ol>\n<p>共享数据是文件</p>\n<h2 id=\"分析-2\">分析<a title=\"#分析-2\" href=\"#分析-2\"></a></h2>\n<p><strong>两类进程:</strong> 读, 写者进程<br>\n**互斥关系: **1. 读进程-写进程 2. 写进程-写进程<br>\n写进程与其他进程都互斥. 首先, 写进程与写进程之间 需要一个信号量 rw, 在写者操作共享文件前后加上 PV 操作<br>\n其次, 读进程与写进程也互斥, 因此也需要 PV 操作. 但是如果一个读者在读取共享文件之前进行了 P(rw) 操作, 会导致其他读者无法读取. 怎么解决?<br>\n**使用一个 count 变量来解决, 记录当前有多少读进程. **<br>\n假设刚开始 count = 0 , 进行 P(rw) 保证不会有写进程参与进来, 之后 count++, 说明现在有一个读进程.<br>\n此时有另外一个读进程参与进来, 由于 count!=0, 那么他就不会进行 P(rw) 操作, 而是直接 count++. 这样我们就解决了读者进程之间的非互斥执行问题</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore rw=<span class=\"number\">1</span>; <span class=\"comment\">// 对文件的互斥访问</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; <span class=\"comment\">// 记录当前读进程数</span></span><br><span class=\"line\"></span><br><span class=\"line\">reader()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>) <span class=\"comment\">// 如果当前没有读者</span></span><br><span class=\"line\">            wait(rw);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"comment\">// read file</span></span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>) <span class=\"comment\">// 如果当前没有读者</span></span><br><span class=\"line\">            signal(rw);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">writer()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(rw);</span><br><span class=\"line\">        <span class=\"comment\">// write file</span></span><br><span class=\"line\">        signal(rw);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>还存在一个问题</strong>, count 变量是共享变量, 设想这样一种情况, count=0 时, 读者 1 if 判断执行, 刚要执行 P(rw) 时, count 现在还是 0, 与此同时另外一位读者也通过了 if 判断. 那么, 在读者一获得了 rw 权限之后, 读者 2 就会被阻塞.<br>\n还需要一个互斥变量来保证一气呵成地操作 count 变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore rw=<span class=\"number\">1</span>; <span class=\"comment\">// 对文件的互斥访问</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; <span class=\"comment\">// 记录当前读进程数</span></span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>; <span class=\"comment\">// 对count 变量的互斥访问</span></span><br><span class=\"line\">reader()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>) <span class=\"comment\">// 如果当前没有读者</span></span><br><span class=\"line\">            wait(rw);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// read file</span></span><br><span class=\"line\"></span><br><span class=\"line\">        wait(mutex);</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>) <span class=\"comment\">// 如果当前没有读者</span></span><br><span class=\"line\">            signal(rw);</span><br><span class=\"line\">        signal(mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">writer()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        wait(rw);</span><br><span class=\"line\">        <span class=\"comment\">// write file</span></span><br><span class=\"line\">        signal(rw);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"套路-1\">套路<a title=\"#套路-1\" href=\"#套路-1\"></a></h2>\n<p>写者关心文件是否被占用.<br>\n**读者团: **</p>\n<ul>\n<li>第一个读者关心文件是否被占有, 未被占有就占用.</li>\n<li>中间读者只增加读者团人数.</li>\n<li>最后一个读者释放文件.</li>\n</ul>\n<p>设置一个信号量表示资源是否被占有, 使用另外一个信号量表示读者团中读者的数量.<br>\n<strong>特征: 资源占用, 团体性</strong></p>\n<div><h1 id=\"推荐文章\">推荐文章<a title=\"#推荐文章\" href=\"%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\"></a></h1><ul><li><a href=\"https://mvbbb.github.io/ldcb18/\">内存管理</a></li></ul></div>","prev":{"title":"内存管理","link":"ldcb18"},"next":{"title":"洛谷【搜索】暴力专项训练","link":"lvkhi9"},"plink":"https://mvbbb.github.io/ognzg7/","toc":[{"id":"不同线程之间的同步问题","title":"不同线程之间的同步问题","index":"1"},{"id":"生产者-消费者问题","title":"生产者-消费者问题","index":"2","children":[{"id":"分析","title":"分析","index":"2.1"},{"id":"套路","title":"套路","index":"2.2"}]},{"id":"哲学家进餐问题","title":"哲学家进餐问题","index":"3","children":[{"id":"分析-1","title":"分析","index":"3.1"},{"id":"方案-1","title":"方案 1","index":"3.2"},{"id":"方案-2","title":"方案 2","index":"3.3"},{"id":"方案-3","title":"方案 3","index":"3.4"}]},{"id":"读者-写者问题","title":"读者-写者问题","index":"4","children":[{"id":"分析-2","title":"分析","index":"4.1"},{"id":"套路-1","title":"套路","index":"4.2"}]},{"id":"推荐文章","title":"推荐文章","index":"5"}],"copyright":{"author":"Mvbbb","link":"<a href=\"https://mvbbb.github.io/ognzg7/\" title=\"经典进程同步问题\">https://mvbbb.github.io/ognzg7/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}