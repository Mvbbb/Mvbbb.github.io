{"title":"力扣-二叉树","date":"2020-08-04T16:02:51.000Z","date_formatted":{"ll":"Aug 4, 2020","L":"08/04/2020","MM-DD":"08-04"},"link":"zhme42","comments":true,"tags":["二叉树","回溯","树","算法与数据结构","递归"],"categories":["数据结构与算法","算法"],"updated":"2021-02-03T04:21:01.093Z","content":"<h1 id=\"遍历树叶\">遍历树叶<a title=\"#遍历树叶\" href=\"#遍历树叶\"></a></h1>\n<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<blockquote>\n<p><a href=\"https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624\" target=\"_blank\" rel=\"external nofollow noopener\">https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624</a></p>\n</blockquote>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200511224727.png#align=left&amp;display=inline&amp;height=867&amp;margin=%5Bobject%20Object%5D&amp;originHeight=867&amp;originWidth=1283&amp;status=done&amp;style=none&amp;width=1283\" alt=\"\" class=\"φcx\"></p>\n<h2 id=\"思路\">思路<a title=\"#思路\" href=\"#思路\"></a></h2>\n<ol>\n<li>题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历</li>\n<li>使用 <code>queue</code> 实现层序遍历</li>\n<li>利用数组来保存结点信息 [静态链表]</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>  left;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//层序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelTra</span><span class=\"params\">(node tree[], <span class=\"keyword\">int</span> root_index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; myqueue;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    myqueue.push(root_index);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!myqueue.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = myqueue.front();</span><br><span class=\"line\">        myqueue.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tree[T].left == <span class=\"number\">-1</span> &amp;&amp; tree[T].right == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; T;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; T;</span><br><span class=\"line\">            flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tree[T].left!=<span class=\"number\">-1</span>) myqueue.push( tree[T].left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tree[T].right!=<span class=\"number\">-1</span>) myqueue.push(tree[T].right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    node* tree=<span class=\"keyword\">new</span> node[n];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> left, right;</span><br><span class=\"line\">    <span class=\"comment\">//写入树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> root[<span class=\"number\">100</span>]&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">            tree[i].left = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tree[i].left = left - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            root[left-<span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"string\">&#x27;-&#x27;</span>)</span><br><span class=\"line\">            tree[i].right = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tree[i].right = right - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            root[right-<span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root_index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            root_index = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LevelTra(tree, root_index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"先序遍历顺序建立二叉树链表\">先序遍历顺序建立二叉树链表<a title=\"#先序遍历顺序建立二叉树链表\" href=\"#先序遍历顺序建立二叉树链表\"></a></h1>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121100.png#align=left&amp;display=inline&amp;height=488&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1164&amp;status=done&amp;style=none&amp;width=1164\" alt=\"\" class=\"φcx\"></p>\n<p><strong>代码实现:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    node*  left;</span><br><span class=\"line\">    node* right;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createBiTree</span><span class=\"params\">(node*&amp; T)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; ch;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ch == <span class=\"string\">&#x27;#&#x27;</span>) T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        T = <span class=\"keyword\">new</span> node;</span><br><span class=\"line\">        T-&gt;data = ch;</span><br><span class=\"line\">        createBiTree(T-&gt;left);</span><br><span class=\"line\">        createBiTree(T-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOders</span><span class=\"params\">(node* tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;中序遍历&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    node* T = tree;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;node*&gt; mystack;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T || !mystack.empty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T) &#123;</span><br><span class=\"line\">            mystack.push(T);</span><br><span class=\"line\">            T = T-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            T = mystack.top();</span><br><span class=\"line\">            mystack.pop();</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            T = T-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    node* tree = <span class=\"keyword\">new</span> node;</span><br><span class=\"line\">    createBiTree(tree);</span><br><span class=\"line\">    inOders(tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>    <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>测试案例:</strong> <code>ABC##DE#G##F###</code></p>\n<p><strong>建立结果:</strong><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121021.png#align=left&amp;display=inline&amp;height=374&amp;margin=%5Bobject%20Object%5D&amp;originHeight=374&amp;originWidth=374&amp;status=done&amp;style=none&amp;width=374\" alt=\"\"></p>\n<h1 id=\"复制二叉树\">复制二叉树<a title=\"#复制二叉树\" href=\"#复制二叉树\"></a></h1>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121055.png#align=left&amp;display=inline&amp;height=450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=450&amp;originWidth=1153&amp;status=done&amp;style=none&amp;width=1153\" alt=\"\" class=\"φcx\"></p>\n<p><strong>代码实现:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span><span class=\"params\">(node* T, node*&amp; newT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        newT = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        newT = <span class=\"keyword\">new</span> node;</span><br><span class=\"line\">        newT-&gt;data = T-&gt;data;</span><br><span class=\"line\">        Copy(T-&gt;left, newT-&gt;left);</span><br><span class=\"line\">        Copy(T-&gt;right, newT-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>测试案例:</strong> <code>ABC##DE#G##F###</code></p>\n<p><strong>打印结果:</strong> <img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513122702.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=146&amp;originWidth=699&amp;status=done&amp;style=none&amp;width=699\" alt=\"\"></p>\n<h1 id=\"计算二叉树的深度\">计算二叉树的深度<a title=\"#计算二叉树的深度\" href=\"#计算二叉树的深度\"></a></h1>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513160326.png#align=left&amp;display=inline&amp;height=335&amp;margin=%5Bobject%20Object%5D&amp;originHeight=335&amp;originWidth=1167&amp;status=done&amp;style=none&amp;width=1167\" alt=\"\" class=\"φcx\"></p>\n<p><strong>递龟实现</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Depth</span><span class=\"params\">(node* T)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = Depth(T-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = Depth(T-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m &gt; n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"统计二叉树中结点的个数\">统计二叉树中结点的个数<a title=\"#统计二叉树中结点的个数\" href=\"#统计二叉树中结点的个数\"></a></h1>\n<h1 id=\"二叉树的可视化\">二叉树的可视化<a title=\"#二叉树的可视化\" href=\"#二叉树的可视化\"></a></h1>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515192331.png#align=left&amp;display=inline&amp;height=197&amp;margin=%5Bobject%20Object%5D&amp;originHeight=197&amp;originWidth=253&amp;status=done&amp;style=none&amp;width=253\" alt=\"\" class=\"φcx\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output_impl</span><span class=\"params\">(Node* n, <span class=\"keyword\">bool</span> left, <span class=\"built_in\">string</span> <span class=\"keyword\">const</span>&amp; indent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        output_impl(n-&gt;right, <span class=\"literal\">false</span>, indent + (left ? <span class=\"string\">&quot;|     &quot;</span> : <span class=\"string\">&quot;      &quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; indent;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (left ? <span class=\"string\">&#x27;\\\\&#x27;</span> : <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;-----&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; n-&gt;data &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        output_impl(n-&gt;left, <span class=\"literal\">true</span>, indent + (left ? <span class=\"string\">&quot;      &quot;</span> : <span class=\"string\">&quot;|     &quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;左边在下面,右边在上面&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        output_impl(root-&gt;right, <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        output_impl(root-&gt;left, <span class=\"literal\">true</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的后序遍历\">二叉树的后序遍历<a title=\"#二叉树的后序遍历\" href=\"#二叉树的后序遍历\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>\n</blockquote>\n<p>递归方法很简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode* T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T) &#123;</span><br><span class=\"line\">            rec(T-&gt;left);</span><br><span class=\"line\">            rec(T-&gt;right);</span><br><span class=\"line\">            v1.push_back(T-&gt;val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于这样一颗树, 我们有三种情况会访问 A 结点, 1 第一次结果他访问他的左子树, 2 他的左子树访问完了开始访问他的右子树, 3 他的左右子树都访问完了,开始访问他本身.<br>\n使用栈迭代, 先把最左边的结点入栈.<br>\n第三种情况需要我们判断他的右子树是否已经访问,或者上他的右子树为空,满足条件之一我们就访问 A 结点.<br>\n使用一个指针来标记上一次完成访问的结点. 如果 A 的右子树不为空, 那么在 A 之前访问的结点一定是 A 的右子树. 如果 A 的右子树为空, 那么我们可以直接访问 A 结点.<br>\n如果上面的条件不满足, 证明 A 的右子树还没有访问我们进入他的右子树继续迭代</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; s;</span><br><span class=\"line\">        TreeNode* T = root, *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T || !s.empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (T)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s.push(T);</span><br><span class=\"line\">                T = T-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                T = s.top();</span><br><span class=\"line\">                s.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T-&gt;right != p &amp;&amp; T-&gt;right != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                    s.push(T);</span><br><span class=\"line\">                    T = T-&gt;right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    v.push_back(T-&gt;val);</span><br><span class=\"line\">                    p = T;</span><br><span class=\"line\">                    T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515223810.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;originHeight=163&amp;originWidth=818&amp;status=done&amp;style=none&amp;width=818\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"二叉树的最大深度\">二叉树的最大深度<a title=\"#二叉树的最大深度\" href=\"#二叉树的最大深度\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/</a></p>\n</blockquote>\n<p><strong>递归解法简单</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = maxDepth(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = maxDepth(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> depth = (m &gt; n ? m : n)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析:<br>\n时间复杂度 <img src=\"https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&amp;code=O%28n%29&amp;height=20&amp;width=36\" alt=\"\"></p>\n<h1 id=\"翻转二叉树\">翻转二叉树<a title=\"#翻转二叉树\" href=\"#翻转二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/submissions/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/invert-binary-tree/submissions/</a></p>\n</blockquote>\n<p><strong>递归简单</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode*&amp; T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!T) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* temp = T-&gt;left;</span><br><span class=\"line\">        T-&gt;left = T-&gt;right;</span><br><span class=\"line\">        T-&gt;right = temp;</span><br><span class=\"line\">        rec(T-&gt;left);</span><br><span class=\"line\">        rec(T-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的层序遍历\">二叉树的层序遍历<a title=\"#二叉树的层序遍历\" href=\"#二叉树的层序遍历\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n</blockquote>\n<p>和普通的层序遍历不太一样的是, 普通的层序遍历无法得知他的层数信息, 但是这个要返回一个二维数组</p>\n<p>从队列中取出一个结点, 把他的儿子结点 <code>push</code> 进去. 每次遍历一层我们都会把这一层的结点的儿子都 <code>push</code> 进来, <code>push</code> 进来的总数是儿子节点的总数.</p>\n<p>我们要一次性从队列里面取出这一层的全部结点. <code>queue.size()</code> 作为我们取出的个数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; vve;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root!=<span class=\"literal\">NULL</span>) qu.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!qu.empty()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = qu.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != size; i++) &#123;</span><br><span class=\"line\">                TreeNode* T = qu.front();</span><br><span class=\"line\">                temp.push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T-&gt;left)qu.push(T-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T-&gt;right)qu.push(T-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vve.push_back(temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这道题花了我很长时间, 不能直接用 <code>qu.size()</code> 作为循环条件, 因为 <code>size</code> 会变</p>\n<h1 id=\"二叉搜索树的范围和\">二叉搜索树的范围和<a title=\"#二叉搜索树的范围和\" href=\"#二叉搜索树的范围和\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/range-sum-of-bst/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/range-sum-of-bst/</a></p>\n</blockquote>\n<p>其实是二叉树中序遍历得到的序列, 在 L 和 R 之间的数求和</p>\n<p><strong>最简单的思路</strong></p>\n<ol>\n<li>使用迭代栈中序遍历</li>\n<li>使用 <code>falg</code> 判断该数是否在 L 和 R 之间</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; s;</span><br><span class=\"line\">        TreeNode* T = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T || !s.empty()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (T)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                s.push(T);</span><br><span class=\"line\">                T = T-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                T = s.top();</span><br><span class=\"line\">                s.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T-&gt;val == L) &#123;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">                    sum += T-&gt;val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T-&gt;val == R &amp;&amp; flag)</span><br><span class=\"line\">                    flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                T = T-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"n-叉树的后序遍历\">N 叉树的后序遍历<a title=\"#n-叉树的后序遍历\" href=\"#n-叉树的后序遍历\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p>\n</blockquote>\n<p><strong>递归方法很简单</strong></p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200516222301.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;originHeight=231&amp;originWidth=823&amp;status=done&amp;style=none&amp;width=823\" alt=\"\" class=\"φcx\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorder</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != root-&gt;children.size(); i++) &#123;</span><br><span class=\"line\">            rec(root-&gt;children[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        v.push_back(root-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>迭代思路</strong></p>\n<p>后序遍历，首先最简单的做法是 记住前序 翻转就实现 (直接利用 1.前序遍历 2.翻转)</p>\n<p>访问栈顶, val 放入到 ve 中, 将栈顶 pop 出来, 将其子树全部按照顺序地放入到栈中. 循环该过程</p>\n<p>循环结束的条件是栈空, 在访问完最后一个结点时栈肯定是空的, 其余情况栈肯定不为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorder</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> v;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">        s.push(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s.empty())&#123;</span><br><span class=\"line\">            Node* T=s.top();</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T)&#123;</span><br><span class=\"line\">                v.push_back(T-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=T-&gt;children.size();i++)&#123;</span><br><span class=\"line\">                     s.push(T-&gt;children[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(v.begin(),v.end());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517084030.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=312&amp;originWidth=794&amp;status=done&amp;style=none&amp;width=794\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"n-叉树的前序遍历\">N 叉树的前序遍历<a title=\"#n-叉树的前序遍历\" href=\"#n-叉树的前序遍历\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p>\n</blockquote>\n<p><strong>递归法很简单</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">preorder</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(Node* T)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        v.push_back(T-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=T-&gt;children.size();i++)&#123;</span><br><span class=\"line\">            rec(T-&gt;children[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>迭代法就相当于上一道题不用 <code>reverse(v.begin(),v.end());</code></p>\n<h1 id=\"将有序数组转换为二叉搜索树\">将有序数组转换为二叉搜索树<a title=\"#将有序数组转换为二叉搜索树\" href=\"#将有序数组转换为二叉搜索树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>\n</blockquote>\n<p>只有一个中序/后序/前序遍历序列无法唯一确定一颗平衡二叉搜索树</p>\n<p>给定了有序数组, 中序遍历时根结点一定处于有序数组的中间部分, 可以递归的每次选数组中间部分作为根结点</p>\n<p><strong>方法一：中序遍历：始终选择中间位置左边元素作为根节点</strong></p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517164034.png#align=left&amp;display=inline&amp;height=233&amp;margin=%5Bobject%20Object%5D&amp;originHeight=233&amp;originWidth=844&amp;status=done&amp;style=none&amp;width=844\" alt=\"\" class=\"φcx\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (left + right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode* T = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        T-&gt;left = helper(left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        T-&gt;right = helper(mid+<span class=\"number\">1</span>,right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> T;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;nums = nums;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>, nums.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：中序遍历：始终选择中间位置右边元素作为根节点</strong></p>\n<p><strong>方法三：中序遍历：选择任意一个中间位置元素作为根节点</strong></p>\n<h1 id=\"*特定深度节点链表\">*特定深度节点链表<a title=\"#*特定深度节点链表\" href=\"#*特定深度节点链表\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/list-of-depth-lcci/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/list-of-depth-lcci/</a></p>\n</blockquote>\n<p>很明显, 采取层次遍历, 每一层变成一条链表</p>\n<p>队列实现层次遍历, 链表的创建采取后插法, 函数返回一个数组, 数组元素是链表头指针</p>\n<h1 id=\"二叉树的中序遍历\">二叉树的中序遍历<a title=\"#二叉树的中序遍历\" href=\"#二叉树的中序遍历\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/</a></p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        TreeNode* T=root;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ve;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(T||!st.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T)&#123;</span><br><span class=\"line\">                st.push(T);</span><br><span class=\"line\">                T=T-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                T=st.top();</span><br><span class=\"line\">                st.pop();</span><br><span class=\"line\">                ve.push_back(T-&gt;val);</span><br><span class=\"line\">                T=T-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"祖父节点值为偶数的节点和\">祖父节点值为偶数的节点和<a title=\"#祖父节点值为偶数的节点和\" href=\"#祖父节点值为偶数的节点和\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/</a></p>\n</blockquote>\n<p>使用三元组来存储结点关系 <code>(grandparent, parent, node)</code> , 之后判断 <code>node.left</code>, <code>node.right</code></p>\n<p>官方思路还是比较普通的, 没我想的那么复杂</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* grandparent, TreeNode* parent, TreeNode* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!node)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grandparent-&gt;val % <span class=\"number\">2</span> == <span class=\"number\">0</span>)ans += node-&gt;val;</span><br><span class=\"line\">        <span class=\"comment\">//遍历下一层</span></span><br><span class=\"line\">        dfs(parent, node, node-&gt;left);</span><br><span class=\"line\">        dfs(parent, node, node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumEvenGrandparent</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            dfs(root, root-&gt;left, root-&gt;left-&gt;left);</span><br><span class=\"line\">            dfs(root, root-&gt;left, root-&gt;left-&gt;right);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">            dfs(root, root-&gt;right, root-&gt;right-&gt;left);</span><br><span class=\"line\">            dfs(root, root-&gt;right, root-&gt;right-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在上一种方法中, 由于根节点没有父结点, 他的根节点的子结点没有祖父结点, 因此我们是从 <code>root-&gt;left-&gt;right</code> 开始的, 因此我们必须使用<code>if (root-&gt;left != NULL)</code>来判断他有没有子结点. 我们可以简化这个过程, 根结点是没有父结点和祖父结点的, 但是我们可以假设他的父结点的值是 1 , 效果是一样的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> gp_val, <span class=\"keyword\">int</span> p_val, TreeNode* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (gp_val % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans += node-&gt;val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(p_val, node-&gt;val, node-&gt;left);</span><br><span class=\"line\">        dfs(p_val, node-&gt;val, node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumEvenGrandparent</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        dfs(<span class=\"number\">1</span>, <span class=\"number\">1</span>, root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518083648.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;originHeight=318&amp;originWidth=722&amp;status=done&amp;style=none&amp;width=722\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"根据前序和后序遍历构造二叉树\">根据前序和后序遍历构造二叉树<a title=\"#根据前序和后序遍历构造二叉树\" href=\"#根据前序和后序遍历构造二叉树\"></a></h1>\n<blockquote>\n<ul class=\"φcz\">\n<li><input type=\"checkbox\" disabled=\"\"><i></i><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></li>\n</ul>\n</blockquote>\n<p>只记得上课讲过, 知道是什么原理, 代码就是写不出来, 递归传哪些参数之类的拎不清</p>\n<p>祭上一段优美的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> pre_index=<span class=\"number\">0</span>, post_index=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class=\"line\">      TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre[pre_index++]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root-&gt;val != post[post_index])</span><br><span class=\"line\">          root-&gt;left = constructFromPrePost(pre, post);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root-&gt;val != post[post_index])</span><br><span class=\"line\">          root-&gt;right = constructFromPrePost(pre, post);</span><br><span class=\"line\">      post_index++;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518092242.png#align=left&amp;display=inline&amp;height=320&amp;margin=%5Bobject%20Object%5D&amp;originHeight=320&amp;originWidth=633&amp;status=done&amp;style=none&amp;width=633\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"二叉搜索树中的众数\">二叉搜索树中的众数<a title=\"#二叉搜索树中的众数\" href=\"#二叉搜索树中的众数\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p>\n</blockquote>\n<p>怎么说呢, 感觉这道题怪怪的</p>\n<p><strong>思路:</strong> 使用 <code>map</code> 来保存数和它出现的频率, 最后再将出现频率最高的数放到 <code>vector</code>, 里面</p>\n<p><code>map</code> 中 <code>value</code> 是出现频率, <code>key</code> 是某个数.</p>\n<p>回顾一下 <code>map</code> 的特性: <strong>使用 <code>[]</code> 访问不存在的 <code>key</code>, <code>map</code> 会把它自动添加进去, 并返回他的 <code>value</code></strong></p>\n<p>就懒得自己写了, 太恼人了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; mmp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        mmp[root-&gt;val]++;</span><br><span class=\"line\">        dfs(root-&gt;left);</span><br><span class=\"line\">        dfs(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">findMode</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\"></span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = mmp.begin(); it != mmp.end(); it++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it-&gt;second == maxn) &#123;</span><br><span class=\"line\">                v.push_back(it-&gt;first);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (it-&gt;second &gt; maxn) &#123;</span><br><span class=\"line\">                maxn = it-&gt;second;</span><br><span class=\"line\">                v.clear();</span><br><span class=\"line\">                v.push_back(it-&gt;first);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*恢复二叉搜索树\">*恢复二叉搜索树<a title=\"#*恢复二叉搜索树\" href=\"#*恢复二叉搜索树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/recover-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/recover-binary-search-tree/</a></p>\n</blockquote>\n<h1 id=\"路径总和\">路径总和<a title=\"#路径总和\" href=\"#路径总和\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/path-sum/</a></p>\n</blockquote>\n<p>哎呀, 不就是递归吗, 多简单啊, 轻轻松松的啦</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200519004054.png#align=left&amp;display=inline&amp;height=321&amp;margin=%5Bobject%20Object%5D&amp;originHeight=321&amp;originWidth=610&amp;status=done&amp;style=none&amp;width=610\" alt=\"\" class=\"φcx\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遍历每一条路径,求和</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;sum=sum;</span><br><span class=\"line\">        rec(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode* T,<span class=\"keyword\">int</span> pre_sum)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        pre_sum+=T-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre_sum==sum&amp;&amp;T-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;T-&gt;right==<span class=\"literal\">NULL</span>)flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        rec(T-&gt;left,pre_sum);</span><br><span class=\"line\">        rec(T-&gt;right,pre_sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不过相较于别人的代码还是过于臃肿</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val==sum&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*二叉树的最近公共祖先\">*二叉树的最近公共祖先<a title=\"#*二叉树的最近公共祖先\" href=\"#*二叉树的最近公共祖先\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>\n</blockquote>\n<p>嗅到了递归的气息,   回溯算法</p>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment</a> &gt; <a href=\"https://www.youtube.com/watch?v=xzKrRf-SLqM\" target=\"_blank\" rel=\"external nofollow noopener\">https://www.youtube.com/watch?v=xzKrRf-SLqM</a></p>\n</blockquote>\n<p>犯糊涂了, 之前以为必须是两个结点的直接祖先, 题没看清楚, 不过肯定逃不了递归思路</p>\n<p>公共祖先 situation:</p>\n<ol>\n<li>p q 在 roo 的左右两边</li>\n<li>1=root, p 在左边或者右边</li>\n<li>p=root, q 在左边或者右边</li>\n</ol>\n<p>时间复杂度<br>\n<img src=\"https://g.yuque.com/gr/latex?O(n)#card=math&amp;code=O%28n%29\" alt=\"\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>||root==q||root==p) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class=\"line\">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"literal\">NULL</span> &amp;&amp; right != <span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left == <span class=\"literal\">NULL</span> ? right : left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为是递归，使用函数后可认为左右子树已经算出结果</p>\n</blockquote>\n<h1 id=\"*出现次数最多的子树元素和\">*出现次数最多的子树元素和<a title=\"#*出现次数最多的子树元素和\" href=\"#*出现次数最多的子树元素和\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/most-frequent-subtree-sum/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/most-frequent-subtree-sum/</a></p>\n</blockquote>\n<h1 id=\"二叉搜索树的第-k-大节点\">二叉搜索树的第 k 大节点<a title=\"#二叉搜索树的第-k-大节点\" href=\"#二叉搜索树的第-k-大节点\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a>)</p>\n</blockquote>\n<p>还是比较简单的</p>\n<p>二叉搜索树的特点: <strong>中序遍历序列递增</strong></p>\n<p>思路: 访问结点, 放入<code>vector</code> ,最后返回 <code>vector</code> 里面倒数第 <code>k</code> 个数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ve;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kthLargest</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ve[ve.size()-k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode* T)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        rec(T-&gt;left);</span><br><span class=\"line\">        ve.push_back(T-&gt;val);</span><br><span class=\"line\">        rec(T-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"从上到下打印二叉树-ii\">从上到下打印二叉树 II<a title=\"#从上到下打印二叉树-ii\" href=\"#从上到下打印二叉树-ii\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a>)</p>\n</blockquote>\n<p>噗, 又是层序遍历</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; vve;</span><br><span class=\"line\">        qu.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!qu.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size=qu.size();</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=size;i++)&#123;</span><br><span class=\"line\">                TreeNode* T=qu.front();</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                temp.push_back(T-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;left)qu.push(T-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;right)qu.push(T-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vve.push_back(temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"平衡二叉树\">平衡二叉树<a title=\"#平衡二叉树\" href=\"#平衡二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        rec(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode* T)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=rec(T-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=rec(T-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(m-n)&gt;=<span class=\"number\">2</span>) flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=m&gt;n?m:n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"从上到下打印二叉树\">从上到下打印二叉树<a title=\"#从上到下打印二叉树\" href=\"#从上到下打印二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p>\n</blockquote>\n<p>迷惑性题目, 未免太过简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ve;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> ve;</span><br><span class=\"line\">        qu.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!qu.empty())&#123;</span><br><span class=\"line\">            TreeNode* T=qu.front();</span><br><span class=\"line\">            qu.pop();</span><br><span class=\"line\">            ve.push_back(T-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T-&gt;left) qu.push(T-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T-&gt;right)   qu.push(T-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意下 <code>root</code> 为空直接返回就是了</p>\n<h1 id=\"*前序和中序序列构造二叉树\">*前序和中序序列构造二叉树<a title=\"#*前序和中序序列构造二叉树\" href=\"#*前序和中序序列构造二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p>\n</blockquote>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518090828.png#align=left&amp;display=inline&amp;height=423&amp;margin=%5Bobject%20Object%5D&amp;originHeight=423&amp;originWidth=1224&amp;status=done&amp;style=none&amp;width=1224\" alt=\"\" class=\"φcx\"></p>\n<p>直接写的不太好, 还是直接看别人的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buildTree(preorder, pos, inorder, <span class=\"number\">0</span>, inorder.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; preorder, <span class=\"keyword\">int</span>&amp; pos, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &gt;= preorder.size()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = left;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt;= right; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inorder[i] == preorder[pos])</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode* node = <span class=\"keyword\">new</span> TreeNode(preorder[pos]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= i<span class=\"number\">-1</span>) node-&gt;left = buildTree(preorder, ++pos, inorder, left, i<span class=\"number\">-1</span>);  <span class=\"comment\">// 左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i+<span class=\"number\">1</span> &lt;= right) node-&gt;right = buildTree(preorder, ++pos, inorder, i + <span class=\"number\">1</span>, right); <span class=\"comment\">// 右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>map</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; pos;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; preorder, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = preorder.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            pos[inorder[i]] = i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(preorder, inorder, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; pre, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; inor, <span class=\"keyword\">int</span> pl, <span class=\"keyword\">int</span> pr, <span class=\"keyword\">int</span> il, <span class=\"keyword\">int</span> ir)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pl &gt; pr) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = pos[pre[pl]] - il;</span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre[pl]);</span><br><span class=\"line\">        root -&gt; left = dfs(pre, inor, pl + <span class=\"number\">1</span>, pl + k, il, il + k - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root -&gt; right = dfs(pre, inor, pl + k + <span class=\"number\">1</span>, pr, il + k + <span class=\"number\">1</span>, ir);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的右视图\">二叉树的右视图<a title=\"#二叉树的右视图\" href=\"#二叉树的右视图\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n</blockquote>\n<p><strong>我的思路:</strong> 使用区分层数的层序遍历, 只打印每一层的最后一个结点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ve;</span><br><span class=\"line\">        TreeNode* T=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        qu.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!qu.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size=qu.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=size;i++)&#123;</span><br><span class=\"line\">                T=qu.front();</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==size<span class=\"number\">-1</span>)</span><br><span class=\"line\">                    ve.push_back(T-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;left) qu.push(T-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;right) qu.push(T-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>缺点:</strong> 将左子树的不必要的部分存储进了队列, 浪费内存</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520154638.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=629&amp;status=done&amp;style=none&amp;width=629\" alt=\"\" class=\"φcx\"></p>\n<p><strong>复杂度分析:</strong> 每个结点都入队出队了一次, 所以时间复杂度是 <img src=\"https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&amp;code=O%28n%29&amp;height=20&amp;width=36\" alt=\"\"></p>\n<p><strong>思路二:</strong>   使用深度优先搜索, 先 <strong>根节点-&gt;右子树-&gt;左子树</strong>, 与先序遍历顺序相反<br>\n只加入每一层第一次被访问的结点, 使用 <code>ve.size()</code> 来判断层数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ve;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        dfs(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ve;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* T,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(!T) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(depth==ve.size())</span><br><span class=\"line\">             ve.push_back(T-&gt;val);</span><br><span class=\"line\">         ++depth;</span><br><span class=\"line\">         dfs(T-&gt;right,depth);</span><br><span class=\"line\">         dfs(T-&gt;left,depth);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不过速度好像更慢了</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520161245.png#align=left&amp;display=inline&amp;height=311&amp;margin=%5Bobject%20Object%5D&amp;originHeight=311&amp;originWidth=636&amp;status=done&amp;style=none&amp;width=636\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"*把二叉搜索树转换为累加树\">*把二叉搜索树转换为累加树<a title=\"#*把二叉搜索树转换为累加树\" href=\"#*把二叉搜索树转换为累加树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p>\n</blockquote>\n<p>二叉搜索树的特点:</p>\n<ol>\n<li>左子树所有结点小于根结点</li>\n<li>右子树所有节点大于根结点</li>\n</ol>\n<p><strong>根据这个特点, 我们可以得出:</strong> 对于一个结点, 他的值变为 = 原来的结点值 + 他右子树的所有结点的值 + 他所有祖先节点与组先结点的右子树的所有结点的值</p>\n<p><strong>对于这道题:</strong> 我们中序递归遍历: 右子树-&gt;根结点-&gt;左子树, 每个结点值变为 左子树结点和+本身</p>\n<p>算了写不出来, 脑子不够用, 看看别人的正确代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">convertBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        convertBST(root-&gt;right);</span><br><span class=\"line\">        root-&gt;val+=num;</span><br><span class=\"line\">        num=root-&gt;val;<span class=\"comment\">//记录这一次的和</span></span><br><span class=\"line\">        convertBST(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>我的思维误区</strong> 第一: 误以为需要递归函数返回右子树的和, 其实使用一个全局变量就可以了 第二: 每个结点只需要遍历一次就够了</p>\n<h1 id=\"*二叉树的直径\">*二叉树的直径<a title=\"#*二叉树的直径\" href=\"#*二叉树的直径\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>\n</blockquote>\n<p>一道标注简单的题做起来不简单</p>\n<h1 id=\"*左子叶之和\">*左子叶之和<a title=\"#*左子叶之和\" href=\"#*左子叶之和\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p>\n</blockquote>\n<p>西巴, 不会, 虽然说看起来挺简单的</p>\n<p>首先, 不可以使用普通的前序遍历, 因为它无法分辨遍历到的结点是不是右结点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left!=<span class=\"literal\">NULL</span>&amp;&amp;root-&gt;left-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;root-&gt;left-&gt;right==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">             temp=root-&gt;left-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp+sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"叶子相似的树\">叶子相似的树<a title=\"#叶子相似的树\" href=\"#叶子相似的树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/leaf-similar-trees/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/leaf-similar-trees/</a></p>\n</blockquote>\n<p>**我的思路: ** 应该是最简单的思路了, 前序遍历两棵树, 判断结点是不是叶节点, 使用 vector 存储, 最后比较两个 vector 是否相同</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1,v2;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">leafSimilar</span><span class=\"params\">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class=\"line\">        rec(root1,<span class=\"number\">1</span>);</span><br><span class=\"line\">        rec(root2,<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v1.size()!=v2.size())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=v1.size();i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(v1[i]!=v2[i])</span><br><span class=\"line\">                    flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rec</span><span class=\"params\">(TreeNode* T,<span class=\"keyword\">int</span> tag)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;T-&gt;right==<span class=\"literal\">NULL</span>&amp;&amp;tag==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            v1.push_back(T-&gt;val);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(T-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;T-&gt;right==<span class=\"literal\">NULL</span>&amp;&amp;tag==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            v2.push_back(T-&gt;val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rec(T-&gt;left,tag);</span><br><span class=\"line\">        rec(T-&gt;right,tag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>优化方法, 使用 <code>string</code> 来存储遍历到的叶节点值, 最后使用 <code>.equal()</code> 就可以了, 不过记得在结点值中间增加分隔符</p>\n<h1 id=\"二叉树的堂兄弟节点\">二叉树的堂兄弟节点<a title=\"#二叉树的堂兄弟节点\" href=\"#二叉树的堂兄弟节点\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/cousins-in-binary-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/cousins-in-binary-tree/</a></p>\n</blockquote>\n<p><strong>堂兄弟的条件:</strong> 不同父结点, 相同的深度</p>\n<p>看了看别人的解法, 没有啥惊艳的解法</p>\n<p>**我的思路: ** <s>使用层序遍历, 遍历到一个结点就将它</s> <strong>不做了</strong></p>\n<h1 id=\"验证二叉搜索树\">验证二叉搜索树<a title=\"#验证二叉搜索树\" href=\"#验证二叉搜索树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>\n</blockquote>\n<p>判断一颗二叉树是不是二叉搜索树.</p>\n<p>二叉搜索树的特点:</p>\n<ol>\n<li>左子树所有结点值小于根结点</li>\n<li>右子树所有结点值大于根结点</li>\n<li>中序遍历得到的序列递增</li>\n</ol>\n<p><strong>我的错误思路:</strong> 中序递归遍历, 对于一个结点, 判断他的左结点是否比他小,右节点的值是否比他大</p>\n<p><strong>错误原因:</strong> 在这种情况下, 按照我的思路无法判断</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521120921.png#align=left&amp;display=inline&amp;height=282&amp;margin=%5Bobject%20Object%5D&amp;originHeight=282&amp;originWidth=379&amp;status=done&amp;style=none&amp;width=379\" alt=\"\" class=\"φcx\"></p>\n<p><strong>大佬的思路:</strong> 中序遍历为升序</p>\n<p><strong>经过改进:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> prev= LONG_MIN;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        TreeNode* T=root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(T||!st.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T)&#123;</span><br><span class=\"line\">                st.push(T);</span><br><span class=\"line\">                T=T-&gt;left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                T = st.top();</span><br><span class=\"line\">                st.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;val&lt;=prev)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                prev=T-&gt;val;</span><br><span class=\"line\">                T=T-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"填充每个节点的下一个右侧节点指针\">填充每个节点的下一个右侧节点指针<a title=\"#填充每个节点的下一个右侧节点指针\" href=\"#填充每个节点的下一个右侧节点指针\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p>\n</blockquote>\n<p><strong>我的起初思路:</strong> 想使用层序遍历, 但是层序遍历需要使用额外的队列空间, 大小由最后一层的结点树数量决定.</p>\n<p><strong>观察给出的样例:</strong></p>\n<ol>\n<li>左子树结点 next 指向他的兄弟结点(父结的右儿子)</li>\n<li>右子树结点 next 指向父结点的 next 的左儿子, 特别的, 如果父结点的 next 是 NULL 的话, 直接指向 NULL</li>\n</ol>\n<p>**我的实现方法: ** 中序递归遍历, 先对于每一个结点:</p>\n<ol>\n<li>该结点不是叶节点, 把他的左儿子 next 指向他的右儿子, 把他的右儿子 next 指向他的 next</li>\n<li>该节点是叶节点就什么什么都不做</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        helper(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(Node* T)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>||(T-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;T-&gt;right==<span class=\"literal\">NULL</span>)) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        T-&gt;left-&gt;next=T-&gt;right;</span><br><span class=\"line\">        T-&gt;right-&gt;next= T-&gt;next==<span class=\"literal\">NULL</span>? <span class=\"literal\">NULL</span>:T-&gt;next-&gt;left;</span><br><span class=\"line\">        helper(T-&gt;left);</span><br><span class=\"line\">        helper(T-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>卧槽, 一次过, 有点激动</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521141703.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;originHeight=256&amp;originWidth=630&amp;status=done&amp;style=none&amp;width=630\" alt=\"\" class=\"φcx\"></p>\n<p>优化方法, 这里可以不用 <code>helper</code> 函数, 一个函数内<code>return root</code></p>\n<h1 id=\"*二叉搜索树迭代器\">*二叉搜索树迭代器<a title=\"#*二叉搜索树迭代器\" href=\"#*二叉搜索树迭代器\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/</a></p>\n</blockquote>\n<p>**我的思路: ** 因为是二叉搜索树, 所以中序遍历序列是递增序列. 因为每一次使用 next ,数就减少一个, 很容易联想到栈或队列. 因此我们使用队列来保存中序遍历序列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        helper(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode* T)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        helper(T-&gt;left);</span><br><span class=\"line\">        st.push(T-&gt;val);</span><br><span class=\"line\">        helper(T-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x=st.front();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>效果很差</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521144009.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=312&amp;originWidth=640&amp;status=done&amp;style=none&amp;width=640\" alt=\"\" class=\"φcx\"></p>\n<p><strong>更好的方法:</strong></p>\n<p>模拟递归的过程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSTIterator</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class=\"line\">    BSTIterator(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            stk.push(root);</span><br><span class=\"line\">            root=root-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** @return the next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TreeNode *p =stk.top();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res= p-&gt;val;</span><br><span class=\"line\">        stk.pop();</span><br><span class=\"line\">        p =p-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            stk.push(p);</span><br><span class=\"line\">            p=p-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** @return whether we have a next smallest number */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !stk.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*树的子结构\">*树的子结构<a title=\"#*树的子结构\" href=\"#*树的子结构\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>\n</blockquote>\n<p><strong>我的思路:</strong> 先序遍历 A 树, 判断该结点的值是否与 B 的根结点相同</p>\n<ol>\n<li>相同: 记下这个结点的位置, 两棵树同时向下比较, , 当 B 树被遍历完了, 就 return true, 否者回到原来被记下的位置, 继续先序遍历</li>\n<li>不同, A 向下遍历</li>\n</ol>\n<p>算了写不下去了, 错误代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSubStructure</span><span class=\"params\">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class=\"line\">        helper(A,B);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode* A,TreeNode* B)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A==<span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A-&gt;val==B-&gt;val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            TreeNode* pa=A;</span><br><span class=\"line\">            TreeNode* pb=B;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>&lt;TreeNode*&gt; sa,sb;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((pa||!sa.empty())&amp;&amp;(pb||!sb.empty()))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pa&amp;&amp;pb)&#123;</span><br><span class=\"line\">                    sa.push(pa);</span><br><span class=\"line\">                    sb.push(pb);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(pa-&gt;val!=pb-&gt;val)</span><br><span class=\"line\">                        flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                    pa=pa-&gt;left;</span><br><span class=\"line\">                    pb=pb-&gt;left;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    pa=sa.top(); sa.pop();</span><br><span class=\"line\">                    pb=sb.top(); sb.pop();</span><br><span class=\"line\">                    pa=pa-&gt;right;</span><br><span class=\"line\">                    pb=pb-&gt;right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pb!=<span class=\"literal\">NULL</span>) flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag==<span class=\"literal\">true</span>) <span class=\"keyword\">this</span>-&gt;flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        helper(A-&gt;left,B);</span><br><span class=\"line\">        helper(A-&gt;right,B);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>看看别人的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSubStructure</span><span class=\"params\">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (A != <span class=\"literal\">NULL</span> &amp;&amp; B != <span class=\"literal\">NULL</span>) &amp;&amp; (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">recur</span><span class=\"params\">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A == <span class=\"literal\">NULL</span> || A-&gt;val != B-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>卧槽, 简直了, 优美简短</p>\n<p><strong>别人的思路:</strong></p>\n<h1 id=\"二叉树的最小深度\">二叉树的最小深度<a title=\"#二叉树的最小深度\" href=\"#二叉树的最小深度\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m=minDepth(root-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n=minDepth(root-&gt;right);</span><br><span class=\"line\">            <span class=\"comment\">//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1</span></span><br><span class=\"line\">            <span class=\"comment\">//2.如果都不为空，返回较小深度+1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root-&gt;left==<span class=\"literal\">NULL</span>||root-&gt;right==<span class=\"literal\">NULL</span>? (m+n+<span class=\"number\">1</span>):(m&gt;n?n:m)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"斐波那契数列\">斐波那契数列<a title=\"#斐波那契数列\" href=\"#斐波那契数列\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/fibonacci-number/description/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/fibonacci-number/description/</a></p>\n</blockquote>\n<p>虽然我知道直接递归不太好, 但是我实在是真看不出这道题和树有什么联系</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(N==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(N==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(N<span class=\"number\">-1</span>)+fib(N<span class=\"number\">-2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最大二叉树\">最大二叉树<a title=\"#最大二叉树\" href=\"#最大二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-binary-tree/description/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/maximum-binary-tree/description/</a></p>\n</blockquote>\n<p>一看就是递归, 我又不会…</p>\n<p>写了一段半残的代码, 思路比较普通, 也比较好理解, 就是边界控制始终不到位</p>\n<p>还是去看大佬的代码去了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//垃圾代码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=findMax(nums,<span class=\"number\">0</span>,nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(nums,<span class=\"number\">0</span>,max,nums.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMax</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=INT_MIN,res=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;=max)&#123;</span><br><span class=\"line\">                max=nums[i];</span><br><span class=\"line\">                res=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> max,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&gt;right) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        TreeNode* root=<span class=\"keyword\">new</span> TreeNode(nums[max]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left_max=findMax(nums,left,max<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right_max=findMax(nums,max+<span class=\"number\">1</span>,right);</span><br><span class=\"line\">        root-&gt;left=helper(nums,left,left_max,max<span class=\"number\">-1</span>);</span><br><span class=\"line\">        root-&gt;right=helper(nums,max+<span class=\"number\">1</span>,right_max,right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>别人的好代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> construct(nums.begin(), nums.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode * <span class=\"title\">construct</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator l, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = max_element(l, r);</span><br><span class=\"line\">        TreeNode *tn = <span class=\"keyword\">new</span> TreeNode(*it);</span><br><span class=\"line\">        tn-&gt;left  = construct(l, it);</span><br><span class=\"line\">        tn-&gt;right = construct(it + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>**总结一下: ** 使用 <code>vector</code> 迭代器, 比较好</p>\n<ol>\n<li>递归结束的条件是左迭代器与右迭代器重合</li>\n<li>使用 <code>STL max_element()</code> , 让代码看起来比较简洁, 还需要积累库算法的使用经验</li>\n<li>注意左右分递归时的细节. 左边递归的右边界是 <code>it</code>. 右边递归的左边界是 <code>it+1</code> ,右边界是 r</li>\n</ol>\n<h1 id=\"合并二叉树\">合并二叉树<a title=\"#合并二叉树\" href=\"#合并二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/description/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/merge-two-binary-trees/description/</a></p>\n</blockquote>\n<p>好的, 我又看出来了, 这是一道递归的题目, 可是卵用</p>\n<p>冷静分析, 有要接一颗树的情形, 因此递归得返回正在处理的二叉树, 方便对接</p>\n<p>如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!t1) <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!t2 ) <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        t1-&gt;val+=t2-&gt;val;</span><br><span class=\"line\">        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class=\"line\">        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>思路是挺清晰, 就是内存消耗有点大</p>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200526000011.png#align=left&amp;display=inline&amp;height=319&amp;margin=%5Bobject%20Object%5D&amp;originHeight=319&amp;originWidth=736&amp;status=done&amp;style=none&amp;width=736\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"*对称二叉树\">*对称二叉树<a title=\"#*对称二叉树\" href=\"#*对称二叉树\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/description/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/symmetric-tree/description/</a></p>\n</blockquote>\n<p>反正就是遍历的问题, 算了不会</p>\n<p>理一下思路: 如何判断一颗树是否是对称二叉搜索树?</p>\n<p>如果根节点是<code>NULL</code>,  <code>true</code><br>\n如果根结点不是<code>NULL</code>, 判断 左子树的左儿子和右子树的右儿子 &amp;&amp; 左子树的右儿子和右子树的左儿子</p>\n<p>左子树的左儿子和右子树的右儿子(左子树的右儿子和右子树的左儿子)</p>\n<ol>\n<li><strong>都为空</strong> <code>return true</code></li>\n<li><strong>有一个是 <code>NULL</code></strong> , 有一个不是 <code>NULL</code></li>\n<li><strong>都不为空</strong>, 判断他们的值是否相同, 并且继续向下递归判断</li>\n</ol>\n<p>这样递归关系就清晰可见了</p>\n<p>代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  helper(root-&gt;left,root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode* l,TreeNode* r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l==<span class=\"literal\">NULL</span>&amp;&amp;r==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l==<span class=\"literal\">NULL</span>||r==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r-&gt;val==l-&gt;val   &amp;&amp; helper(l-&gt;left,r-&gt;right)&amp;&amp;helper(l-&gt;right,r-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>代码优化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isMirror(root, root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMirror</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> &amp;&amp; t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> || t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (t1.val == t2.val)</span><br><span class=\"line\">        &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class=\"line\">        &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*路径总和- ⅲ\">*路径总和  Ⅲ<a title=\"#*路径总和- ⅲ\" href=\"#*路径总和- ⅲ\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii/description/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/path-sum-iii/description/</a></p>\n</blockquote>\n<p>难度不小, 有点东西</p>\n<p><s>思路一: 使用 vector 存储遍历到的路径的值的和, 最后数容器中有几个 sum</s></p>\n<p>算了不会, 别折腾自己, 看答案了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum -= root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"number\">0</span> == sum ? <span class=\"number\">1</span> : <span class=\"number\">0</span>) + dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);</span><br><span class=\"line\">        <span class=\"comment\">/*这条路径和是否是sum, 继续递归左边和右边*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解释: <code>pathSum</code> 前序遍历递归每一个结点. <code>dfs</code> 对于每一   个结点递归遍历他的左右子树.<br>\n对于一个结点我们怎么判断他有几条向下的路径和为 sum 呢? 前序遍历, 向下递归</p>\n<h1 id=\"二叉搜索树中的搜索\">二叉搜索树中的搜索<a title=\"#二叉搜索树中的搜索\" href=\"#二叉搜索树中的搜索\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p>\n</blockquote>\n<p>我的最初递归方法,不知道还没有更好的方法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val==val)<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode* l=searchBST(root-&gt;left,val);</span><br><span class=\"line\">        TreeNode* r=searchBST(root-&gt;right,val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l==<span class=\"literal\">NULL</span>?r:l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>适当优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>||root-&gt;val==val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode* l=searchBST(root-&gt;left,val);</span><br><span class=\"line\">        TreeNode* r=searchBST(root-&gt;right,val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l==<span class=\"literal\">NULL</span>?r:l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当然我们也可以使用层序遍历或者非递归遍历来实现.</p>\n<p>观察了一会儿, 恍然大悟, 这是一颗二叉搜索树, 我们可以利用它的性质来优化代码. 但是提交结果显示效率还是不高</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>||root-&gt;val==val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode* res=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val&gt;val)</span><br><span class=\"line\">            res=searchBST(root-&gt;left,val);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            res=searchBST(root-&gt;right,val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200530114156.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;originHeight=301&amp;originWidth=675&amp;status=done&amp;style=none&amp;width=675\" alt=\"\" class=\"φcx\"></p>\n<h1 id=\"二叉搜索树中的插入操作\">二叉搜索树中的插入操作<a title=\"#二叉搜索树中的插入操作\" href=\"#二叉搜索树中的插入操作\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>\n</blockquote>\n<p>Awesome! 一次过</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span> )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val&gt;val)</span><br><span class=\"line\">            root-&gt;left=insertIntoBST(root-&gt;left,val);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            root-&gt;right=insertIntoBST(root-&gt;right,val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*二叉树展开为链表\">*二叉树展开为链表<a title=\"#*二叉树展开为链表\" href=\"#*二叉树展开为链表\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>\n</blockquote>\n<p>题干的关键是原地展开, 不能新建一颗二叉树.</p>\n<p>递龟问题, 我们根结点的左子树被插入到根结点与右子树中间</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-ming-zhi-/\" target=\"_blank\" rel=\"external nofollow noopener\">别人的思路</a>对于一个递归函数, 我们不用管函数内部是怎样实现的, 我只看函数的作用以及输入输出.</p>\n<p>对于<code>flatten</code> 来说</p>\n<ol>\n<li>函数作用: 是将一个二叉树展开为链表</li>\n<li>输入: 树的根结点</li>\n<li>输出: 无</li>\n</ol>\n<p>我的思维误区: 其实叶节点也可以当作是一颗左子树和右子树都是 <code>NULL</code> 的树</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">我们每次把原来的右子树接到现在右子树的末尾都使用了一个 `while` 循环来找到现在右子树最右边的结点</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        flatten(root-&gt;left);</span><br><span class=\"line\">        flatten(root-&gt;right);</span><br><span class=\"line\">        TreeNode*temp=root-&gt;right;</span><br><span class=\"line\">        root-&gt;right = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left=<span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;right!=<span class=\"literal\">nullptr</span>)root=root-&gt;right;</span><br><span class=\"line\">        root-&gt;right=temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另外一种思路: 向右边的后序遍历, 逆向思维, 难懂</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TreeNode* last = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        flatten(root-&gt;right);</span><br><span class=\"line\">        flatten(root-&gt;left);</span><br><span class=\"line\">        root-&gt;right = last;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        last = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"*二叉树的所有路径\">*二叉树的所有路径<a title=\"#*二叉树的所有路径\" href=\"#*二叉树的所有路径\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>\n</blockquote>\n<p>很久没做题了, 手感生疏了, 简单题也头痛了. 虽然说之前也不怎么会 🤣</p>\n<p>来看看这道题. 不会</p>\n<p>对于一个结点, 分情况</p>\n<ol>\n<li>他的左儿子或右儿子有一个不为空, 到他的 path += “val-&gt;”</li>\n<li>他是叶节点, path+= “val”, 将到他的 path push 到容器</li>\n</ol>\n<p>递龟结束的条件是碰到 NULL 了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"built_in\">string</span> path;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">binaryTreePaths</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left==<span class=\"literal\">NULL</span>&amp;&amp;root-&gt;right==<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//叶节点</span></span><br><span class=\"line\">            path+=to_string(root-&gt;val);</span><br><span class=\"line\">            res.push_back(path);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            path+=to_string(root-&gt;val)+<span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> temp=path;<span class=\"comment\">//使用一个temp来保存到即将进入左边递龟的结点的路径</span></span><br><span class=\"line\">            binaryTreePaths(root-&gt;left);</span><br><span class=\"line\">            path=temp;<span class=\"comment\">//将路径恢复为进入左边递龟之前的路径</span></span><br><span class=\"line\">            binaryTreePaths(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"找树左下角的值\">找树左下角的值<a title=\"#找树左下角的值\" href=\"#找树左下角的值\"></a></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\" target=\"_blank\" rel=\"external nofollow noopener\">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>\n</blockquote>\n<p>又是层序遍历, 仔细想一下很简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res;</span><br><span class=\"line\">        qu.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!qu.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size=qu.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i!=size;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> T=qu.front();</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)</span><br><span class=\"line\">                res=T-&gt;val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;left)qu.push(T-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T-&gt;right)qu.push(T-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div><h1 id=\"推荐文章\">推荐文章<a title=\"#推荐文章\" href=\"%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\"></a></h1><ul><li><a href=\"https://mvbbb.github.io/iixrxk/\">排序算法</a></li><li><a href=\"https://mvbbb.github.io/gggq6t/\">Leetbook 初级算法</a></li><li><a href=\"http://www.b5mang.com/hasSubtree.html\">二叉树系列-二叉树子结构</a></li></ul></div>","prev":{"title":"排序算法","link":"iixrxk"},"next":{"title":"Leetbook 初级算法","link":"gggq6t"},"plink":"https://mvbbb.github.io/zhme42/","toc":[{"id":"遍历树叶","title":"遍历树叶","index":"1","children":[{"id":"题目描述","title":"题目描述","index":"1.1"},{"id":"思路","title":"思路","index":"1.2"}]},{"id":"先序遍历顺序建立二叉树链表","title":"先序遍历顺序建立二叉树链表","index":"2"},{"id":"复制二叉树","title":"复制二叉树","index":"3"},{"id":"计算二叉树的深度","title":"计算二叉树的深度","index":"4"},{"id":"统计二叉树中结点的个数","title":"统计二叉树中结点的个数","index":"5"},{"id":"二叉树的可视化","title":"二叉树的可视化","index":"6"},{"id":"二叉树的后序遍历","title":"二叉树的后序遍历","index":"7"},{"id":"二叉树的最大深度","title":"二叉树的最大深度","index":"8"},{"id":"翻转二叉树","title":"翻转二叉树","index":"9"},{"id":"二叉树的层序遍历","title":"二叉树的层序遍历","index":"10"},{"id":"二叉搜索树的范围和","title":"二叉搜索树的范围和","index":"11"},{"id":"n-叉树的后序遍历","title":"N 叉树的后序遍历","index":"12"},{"id":"n-叉树的前序遍历","title":"N 叉树的前序遍历","index":"13"},{"id":"将有序数组转换为二叉搜索树","title":"将有序数组转换为二叉搜索树","index":"14"},{"id":"*特定深度节点链表","title":"*特定深度节点链表","index":"15"},{"id":"二叉树的中序遍历","title":"二叉树的中序遍历","index":"16"},{"id":"祖父节点值为偶数的节点和","title":"祖父节点值为偶数的节点和","index":"17"},{"id":"根据前序和后序遍历构造二叉树","title":"根据前序和后序遍历构造二叉树","index":"18"},{"id":"二叉搜索树中的众数","title":"二叉搜索树中的众数","index":"19"},{"id":"*恢复二叉搜索树","title":"*恢复二叉搜索树","index":"20"},{"id":"路径总和","title":"路径总和","index":"21"},{"id":"*二叉树的最近公共祖先","title":"*二叉树的最近公共祖先","index":"22"},{"id":"*出现次数最多的子树元素和","title":"*出现次数最多的子树元素和","index":"23"},{"id":"二叉搜索树的第-k-大节点","title":"二叉搜索树的第 k 大节点","index":"24"},{"id":"从上到下打印二叉树-ii","title":"从上到下打印二叉树 II","index":"25"},{"id":"平衡二叉树","title":"平衡二叉树","index":"26"},{"id":"从上到下打印二叉树","title":"从上到下打印二叉树","index":"27"},{"id":"*前序和中序序列构造二叉树","title":"*前序和中序序列构造二叉树","index":"28"},{"id":"二叉树的右视图","title":"二叉树的右视图","index":"29"},{"id":"*把二叉搜索树转换为累加树","title":"*把二叉搜索树转换为累加树","index":"30"},{"id":"*二叉树的直径","title":"*二叉树的直径","index":"31"},{"id":"*左子叶之和","title":"*左子叶之和","index":"32"},{"id":"叶子相似的树","title":"叶子相似的树","index":"33"},{"id":"二叉树的堂兄弟节点","title":"二叉树的堂兄弟节点","index":"34"},{"id":"验证二叉搜索树","title":"验证二叉搜索树","index":"35"},{"id":"填充每个节点的下一个右侧节点指针","title":"填充每个节点的下一个右侧节点指针","index":"36"},{"id":"*二叉搜索树迭代器","title":"*二叉搜索树迭代器","index":"37"},{"id":"*树的子结构","title":"*树的子结构","index":"38"},{"id":"二叉树的最小深度","title":"二叉树的最小深度","index":"39"},{"id":"斐波那契数列","title":"斐波那契数列","index":"40"},{"id":"最大二叉树","title":"最大二叉树","index":"41"},{"id":"合并二叉树","title":"合并二叉树","index":"42"},{"id":"*对称二叉树","title":"*对称二叉树","index":"43"},{"id":"*路径总和- ⅲ","title":"*路径总和  Ⅲ","index":"44"},{"id":"二叉搜索树中的搜索","title":"二叉搜索树中的搜索","index":"45"},{"id":"二叉搜索树中的插入操作","title":"二叉搜索树中的插入操作","index":"46"},{"id":"*二叉树展开为链表","title":"*二叉树展开为链表","index":"47"},{"id":"*二叉树的所有路径","title":"*二叉树的所有路径","index":"48"},{"id":"找树左下角的值","title":"找树左下角的值","index":"49"},{"id":"推荐文章","title":"推荐文章","index":"50"}],"copyright":{"author":"Mvbbb","link":"<a href=\"https://mvbbb.github.io/zhme42/\" title=\"力扣-二叉树\">https://mvbbb.github.io/zhme42/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}