{"title":"《码出高效》笔记","date":"2020-09-08T02:43:20.000Z","date_formatted":{"ll":"Sep 8, 2020","L":"09/08/2020","MM-DD":"09-08"},"link":"sn0gdd","comments":true,"tags":["Java","读书笔记"],"categories":["Java","JavaSe"],"updated":"2021-02-03T04:21:00.457Z","content":"<p>one more flag!<br>\n感觉这本书比较的基础, 阅读难度不大, 但是干货很多. 可以说是极其不错的一本 BeginnerFriendlyBook<br>\n适合人群: 学完 Java 语法基础, 想要学习部分底层知识的人群.<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599666600088-927f07f2-f137-44f1-9a67-8ffb7b256020.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=378409&amp;status=done&amp;style=none&amp;width=960\" alt=\"image.png\"></p>\n<a id=\"more\"></a>\n<h1 id=\"第一章-计算机基础\">第一章 计算机基础<a title=\"#第一章-计算机基础\" href=\"#第一章-计算机基础\"></a></h1>\n<p>暂时跳过</p>\n<h1 id=\"第二章-面向对象\">第二章 面向对象<a title=\"#第二章-面向对象\" href=\"#第二章-面向对象\"></a></h1>\n<h2 id=\"oop-理念\">OOP 理念<a title=\"#oop-理念\" href=\"#oop-理念\"></a></h2>\n<ol>\n<li>慎用 Object 类的 clone() 方法来拷贝对象, 因为对象的 clone() 方法默认是浅拷贝, 若想实现深拷贝需要覆写 clone() 方法实现引用对象的深度遍历式拷贝</li>\n<li>里氏代换原则 LSP: 任何父类出现的地方, 子类都能够出现. 实际代码环境中, 如果父类引用直接使用子类对象的引用来替代, 可以正确的编译执行, 说明两个类之间符合 LSP 原则, 可以使用继承关系</li>\n<li>继承树过高可能会产生方法爆炸, 所以提倡使用组合优先的原则来扩展类的能力, 即优先采用组合或聚合的类关系来复用其他类的能力, 而不是继承.</li>\n<li>严格意义上来说, 多态并不是面向对象的一种特性, 而是一种由继承衍生而来的一种能力</li>\n</ol>\n<h2 id=\"初始-java\">初始 Java<a title=\"#初始-java\" href=\"#初始-java\"></a></h2>\n<p>Java 很优秀 :)</p>\n<h2 id=\"类\">类<a title=\"#类\" href=\"#类\"></a></h2>\n<ol>\n<li>getter/setter 方法一般放在类方法最后</li>\n<li>接口与抽象类的区别 详见 p54<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599534269595-cc9e5eaa-f62c-41cb-98e5-9776d62e5362.png#align=left&amp;display=inline&amp;height=303&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=605&amp;originWidth=1125&amp;size=458786&amp;status=done&amp;style=none&amp;width=562.5\" alt=\"image.png\"></li>\n<li>当纠结定义接口还是抽象类的时候, 优先推荐定义为接口, 遵循接口隔离原则, 按照某个维度划分为多个接口, 然后用抽象类去实现某些接口, 这样做可以方便后续的扩展和重构</li>\n<li>内部类本身是类的一个属性, 与其他属性定义方式一致<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599534698957-facbf3df-ee94-401c-aa0d-5e3331ddf0a4.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=688&amp;originWidth=1123&amp;size=887060&amp;status=done&amp;style=none&amp;width=561.5\" alt=\"image.png\"></li>\n<li>使用静态内部类的好处\n<ol>\n<li>作用域不会扩散到包外</li>\n<li>可以使用 外部类.内部类 的方式直接访问</li>\n<li>内部类可以访问外部类的所有静态属性和方法</li>\n</ol>\n</li>\n<li>访问权限控制 详见 p59<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599535095189-ed7add95-3ade-4c14-827b-f051ab57bf7e.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=1140&amp;size=265169&amp;status=done&amp;style=none&amp;width=570\" alt=\"image.png\"></li>\n<li>权限从严<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599543820455-8b83dec0-218c-42fa-bb08-89b68458aa39.png#align=left&amp;display=inline&amp;height=225&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=449&amp;originWidth=989&amp;size=508430&amp;status=done&amp;style=none&amp;width=494.5\" alt=\"image.png\"></li>\n<li>如果子类调用父类的某个构造方法, super 就会不断往上回溯, 如果没有指定, 则默认调用 super(), 如果父类没有提供默认构造的方法, 子类在继承的时候会报错.<br>\n如果父类坚持不提供默认的无参构造方法, 必须在本类的误餐构造方法中显式的使用 super 调用父类的有参构造方法</li>\n<li>super 与 this 的异同点<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599560010152-8043cb8d-71bd-4771-91a4-779afe7a9e12.png#align=left&amp;display=inline&amp;height=271&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=1047&amp;size=697955&amp;status=done&amp;style=none&amp;width=523.5\" alt=\"image.png\"></li>\n<li>类之间的关系<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599560100335-ca5d86af-82f1-4898-93f6-bce0d8e7cda0.png#align=left&amp;display=inline&amp;height=474&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=947&amp;originWidth=907&amp;size=502455&amp;status=done&amp;style=none&amp;width=453.5\" alt=\"image.png\"></li>\n<li>常见的序列化方法\n<ol>\n<li>Java 原生序列化: 实现 Serializable 接口(不推荐使用)</li>\n<li>Hessian 序列化: 将复杂对象的所有属性存储在一个 Map 中进行序列化</li>\n<li>JSON 序列化: 将数据对象转化为 JSON 字符串</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"方法\">方法<a title=\"#方法\" href=\"#方法\"></a></h2>\n<ol>\n<li>JVM 标识方法的唯一索引: 方法签名, 包括方法名称和参数列表. 可以解释为什么返回类型不能作为函数重载判断元素的原因</li>\n<li>(函数风格约定)函数传参过程中: 每一个逗号后面都必须要一个空格</li>\n<li>Java 中只有值传递</li>\n<li>尽量不要使用可变参数编程</li>\n<li>函数参数的规约 p70 页</li>\n<li>类定义时提供了一个默认的无参构造函数, 但是假如我们定义了一个有参构造函数, 则无参构造函数会被覆盖. 若还想拥有必须显示定义</li>\n<li>类在创建的过程中会先执行父类和子类的静态代码块, 之后再执行父类和子类构造函数. 静态代码块之后被执行一次</li>\n<li>当字节码文件 .class 被加载之后, 实例方法并不会被分配方法入口地址, 只有在对象创建之后才会分配. 实例方法可以调用静态变量和静态方法.</li>\n<li>调用静态方法时尽量使用 <code>类名.静态方法</code> , 提高运行效率</li>\n<li>静态方法中不能使用实例成员变量和实例方法</li>\n<li>静态方法中不能使用 this.super 关键字, 这两个关键字指代的都是需要被创建出来的对象</li>\n<li>工具类的静态方法与单例模式相伴而生</li>\n<li>非静态代码块 (局部代码块) 不推荐使用</li>\n<li>静态代码块不能包含于任何方法体中</li>\n<li>类中方法的定义顺序: 公有方法或保护方法&gt;私有方法&gt;getter/setter 方法</li>\n<li>getter/setter 方法容易出现的问题\n<ol>\n<li>getter/setter 中添加业务逻辑</li>\n<li>同时定义 isXxx() 和 getXxx() 方法: iBATIS 的反射机制会筛选出以 get 和 is 开头的方法, 但是只会保留一个, 容易造成业务冲突</li>\n<li>相同的属性名容易带来歧义: 对于非 getter/setter 方法参数名称不能和成员变量相同</li>\n</ol>\n</li>\n<li>如果某个类覆写了父类的某个方法, 则方法表中的方法指向引用会指向子类的实现处. 这是实现多态的重要因素.</li>\n<li>向上转型通过父类引用调用子类的方法需要注意的几点</li>\n</ol>\n<ul>\n<li>无法调用子类中存在而父类中不存在的方法</li>\n<li>可以调用到子类中覆写的父类的方法, 这是一种多态实现</li>\n</ul>\n<ol start=\"19\">\n<li>想要成功覆写父类的方法需要注意一下几点:</li>\n</ol>\n<ul>\n<li>访问权限不能变小</li>\n<li>返回类型能够向上转型为父类的返回类型</li>\n<li>异常也要能向上转型成为父类的异常 方法名,参数个数, 参数类型必须全部一致</li>\n<li>覆写只能针对非静态, 非 final, 非构造方法</li>\n</ul>\n<h2 id=\"重载\">重载<a title=\"#重载\" href=\"#重载\"></a></h2>\n<ol>\n<li>JVM 在重载方法中的选择优先级\n<ol>\n<li>精确匹配</li>\n<li>如果是基本数据类型, 自动转型为更大表示范围的基本类型</li>\n<li>通过自动拆箱与装箱</li>\n<li>通过子类向上转型路径依次匹配</li>\n<li>通过可变参数匹配</li>\n</ol>\n</li>\n<li>重载又被称为静态绑定</li>\n</ol>\n<h2 id=\"泛型\">泛型<a title=\"#泛型\" href=\"#泛型\"></a></h2>\n<ol>\n<li>尖括号里面的每一个元素都指代一种未知类型. <String> 与 String 指代的是不同的</li>\n<li>尖括号的位置非常讲究, 必须在类名之后, 或者方法返回值之前</li>\n<li>泛型在定义处只具备执行 Object 方法的能力</li>\n<li>对于编译之后的字节码文件, 其实没有花头花脑的方法签名, 充分说明了泛型只是一种编写代码时的语法检查</li>\n<li>使用泛型的好处\n<ol>\n<li>类型安全</li>\n<li>提升可读性</li>\n<li>代码重用</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"数据类型\">数据类型<a title=\"#数据类型\" href=\"#数据类型\"></a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599563970707-d2a5638c-6cca-4158-9dc9-0ba0f2019e76.png#align=left&amp;display=inline&amp;height=347&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=694&amp;originWidth=1126&amp;size=484766&amp;status=done&amp;style=none&amp;width=563\" alt=\"image.png\" class=\"φcx\"></p>\n<ol>\n<li>引用变量均占 4b 空间, 实际对象初始的分配空间至少是 16b</li>\n<li>对象头最小占用空间为 12b</li>\n<li>对象分为 3 块存储区域<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599564405165-e457f022-04ed-4408-b06c-debf387f980e.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=511&amp;originWidth=853&amp;size=429297&amp;status=done&amp;style=none&amp;width=426.5\" alt=\"image.png\"></li>\n<li>Integer 会缓存 -127 到 128 之间的值. 推荐包装类之间的比较全部通过 .equals() 方法</li>\n<li>选择包装类还是基本数据类型, 推荐如下方法<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599565020866-f3cac7d4-71b8-4092-af26-bcd662c17741.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=155&amp;originWidth=1148&amp;size=171804&amp;status=done&amp;style=none&amp;width=574\" alt=\"image.png\"></li>\n</ol>\n<h1 id=\"第三章-代码风格\">第三章 代码风格<a title=\"#第三章-代码风格\" href=\"#第三章-代码风格\"></a></h1>\n<ol>\n<li>在 Java 中, 所有的变量均不能以 ‘_’ 开始或者结尾</li>\n<li>类名一般采用大驼峰式命名</li>\n<li>方法名, 变量(参数,成员变量) 一般采用小驼峰式命名</li>\n<li>全局常量和类常量的命名: 全部大写, 字母之间使用下划线连接</li>\n<li>局部常量使用小驼峰式命名</li>\n<li>包名统一使用小写, 使用单数形式, 但是如果类名有复数含义, 则可以使用复数形式</li>\n<li>抽象类名采用 Abstract/Base 开头, 异常类使用 Exception 结尾, 测试类使用 被测试的类名+Test</li>\n<li>数组定义: int[] a</li>\n<li>枚举类名带上 Enum 后缀, 枚举成员名称需要全部大写, 单词之间使用下划线分割</li>\n<li>不要在代码中直接使用 “魔法值”</li>\n<li>使用 4 个空格代替 tab</li>\n<li>空格的使用规约<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599608787700-0ff5ea94-590d-496b-a9c3-205337f57627.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=1023&amp;size=355169&amp;status=done&amp;style=none&amp;width=511.5\" alt=\"image.png\"></li>\n<li>单个方法的长度不要超过 80 行</li>\n<li>换行规约<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599609069840-fbda279d-a75f-4e1b-8e53-2e69838d54e5.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=444&amp;originWidth=1085&amp;size=440779&amp;status=done&amp;style=none&amp;width=542.5\" alt=\"image.png\"></li>\n<li>if-else. 即使只有一条语句也需要 {}</li>\n<li>在条件表达式中不能出现赋值运算, 也不允许在条件表达式中出现复杂的逻辑组合</li>\n<li>多层嵌套不要超过 3 次</li>\n<li>避免使用逻辑取反 ! 运算符</li>\n<li>对枚举的注释<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599609426899-ab0acd02-afe9-4722-a962-0b1051a09ba9.png#align=left&amp;display=inline&amp;height=157&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=313&amp;originWidth=1060&amp;size=285229&amp;status=done&amp;style=none&amp;width=530\" alt=\"image.png\"></li>\n</ol>\n<h1 id=\"第四章-走进-jvm\">第四章 走进 JVM<a title=\"#第四章-走进-jvm\" href=\"#第四章-走进-jvm\"></a></h1>\n<blockquote>\n<p>在我能力范围之外了, 难<br>\n之后再回过头来翻阅吧, 现在看的迷迷糊糊的</p>\n</blockquote>\n<h2 id=\"字节码\">字节码<a title=\"#字节码\" href=\"#字节码\"></a></h2>\n<ol>\n<li>\n<p>字节码是 Java 程序运行的中间文件, JVM 将字节码文件解释执行, 屏蔽对底层操作系统的依赖</p>\n</li>\n<li>\n<p>字节码文件的主要指令</p>\n<ol>\n<li>加载或者存储指令\n<ol>\n<li>将局部变量加载在操作栈</li>\n<li>将操作栈存储到局部变量表</li>\n<li>将常量加载到操作栈顶, 这是极其高频的使用指令</li>\n</ol>\n</li>\n<li>运算指令: 对两个操作栈帧进行运算, 并将结果写入操作栈顶</li>\n<li>类型转换指令: 显示地转换两种不同的数据类型</li>\n<li>对象的创建与访问指令: 根据类进行对象的创建, 初始化, 方法调用相关指令</li>\n<li>操作栈管理指令\n<ol>\n<li>出栈操作</li>\n<li>复制栈顶元素并压入栈</li>\n</ol>\n</li>\n<li>方法调用与返回指令: 调用对象的实例方法, 调用静态方法, 返回 VOID 类型, 调用实例初始化方法,私有方法,父类方法等.</li>\n<li>同步指令</li>\n</ol>\n</li>\n<li>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599617749037-94c06f7b-34cf-47b6-8b72-a446c09ff92e.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=495&amp;originWidth=1061&amp;size=280211&amp;status=done&amp;style=none&amp;width=530.5\" alt=\"image.png\"><br>\n词法解析形成 token 信息流, 语法解析时将 token 信息流按照语法组装成一颗语法树, 在语义分析阶段需要检查关键词的使用是否合理, 类型是否匹配等, 语义分析完成之后即可生成字节码</p>\n</li>\n<li>\n<p>JIT 的作用: 将字节码多态编译成可以直接发送给处理器指令执行的机器码<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599636063030-91f9af12-1cd8-48fd-aaa9-b3ee9ece150d.png#align=left&amp;display=inline&amp;height=262&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=523&amp;originWidth=1091&amp;size=264587&amp;status=done&amp;style=none&amp;width=545.5\" alt=\"image.png\"></p>\n</li>\n<li>\n<p>字节码的执行模式: (1) 解释执行 (2) JIT 编译执行 (3) JIT 编译与解释混合执行(主流 JVM 默认方式)</p>\n</li>\n<li>\n<p>混合执行的优势: 在解释器启动的时候先解释执行, 省去编译的时间, 之后 JVM 通过热点代码统计分析, 基于 JIT 多态编译技术, 将热点代码转换为机器码, 交给 CPU 执行</p>\n</li>\n</ol>\n<h2 id=\"类加载过程\">类加载过程<a title=\"#类加载过程\" href=\"#类加载过程\"></a></h2>\n<ol>\n<li>ClassLoader 的任务是提前加载 .class 字节码文件到内存中</li>\n<li>加载类时使用的是 双亲委派模型</li>\n<li>类加载: 将 .class 字节码文件实例化为 Class 对象并进行初始化的过程.</li>\n<li>类加载过程\n<ol>\n<li>Load 阶段: 读取类文件产生二进制文件, 进行初步校验, 之后创建对应类的 Class 实例</li>\n<li>Link 阶段: 验证, 准备, 解析三个步骤. 验证是进行更加详细的检查. 准备阶段为静态变量分配内存, 设定默认值. 解析类和方法确保类与类之间相互引用的正确性,完成内存结构布局</li>\n<li>Init 阶段执行类构造器 <clinit> 方法</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599636499457-5ef6fa1a-0ece-486f-a4c8-cbe807a2a7ad.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=552&amp;originWidth=1063&amp;size=376328&amp;status=done&amp;style=none&amp;width=531.5\" alt=\"image.png\" class=\"φcx\"></p>\n<ol start=\"5\">\n<li>Class 是所有 class 的类</li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599637527261-2b9a45d4-c1f7-4bc5-9787-e327798bc601.png#align=left&amp;display=inline&amp;height=161&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=322&amp;originWidth=1081&amp;size=262851&amp;status=done&amp;style=none&amp;width=540.5\" alt=\"image.png\" class=\"φcx\"></li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599637875607-8e659d3e-bb58-482b-972a-4ee9f6b9e8b8.png#align=left&amp;display=inline&amp;height=366&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=732&amp;originWidth=1037&amp;size=531352&amp;status=done&amp;style=none&amp;width=518.5\" alt=\"image.png\" class=\"φcx\"></li>\n<li>针对某个类, 底层次的类加载器只有在高层次的类加载器加载了该类之后才能加载该类. 逐级向上询问是否已经加载该类, 之后逐级向下尝试是否可以加载该类</li>\n<li>需要自定义类加载器的情形:\n<ol>\n<li>隔离加载类</li>\n<li>修改类加载方式: 除了 Bootstrap 之外其他的加载不一定非要引入</li>\n<li>扩展加载源</li>\n<li>防止源码外泄</li>\n</ol>\n</li>\n<li>实现自定义类加载器的步骤: 继承 ClassLoader, 重写 finalClass() 方法, 调用 defineClass() 方法</li>\n</ol>\n<h2 id=\"内存布局\">内存布局<a title=\"#内存布局\" href=\"#内存布局\"></a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599650448509-b3251305-8f33-49b4-b85e-cca61a223ddf.png#align=left&amp;display=inline&amp;height=275&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=549&amp;originWidth=1311&amp;size=1036709&amp;status=done&amp;style=none&amp;width=655.5\" alt=\"image.png\" class=\"φcx\"></p>\n<ol>\n<li>堆区存储着几乎所有的实例对象, 堆由垃圾收集器自动回收, 堆区由各子线程共享</li>\n<li>堆分为两大块: 新生代和老年代. 新生代=1 个 Eden 区+2 个 Survivor 区</li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599651059015-23b7d05e-672a-44fa-ac9b-1d922b1db8bf.png#align=left&amp;display=inline&amp;height=459&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=917&amp;originWidth=1203&amp;size=570859&amp;status=done&amp;style=none&amp;width=601.5\" alt=\"image.png\" class=\"φcx\"></li>\n<li>元空间在本地内存中分配, JDK8 中, 除了字符串常量移至堆内存, 其他内容包括类元信息, 字段, 静态属性, 方法, 常量等都移动至元空间内</li>\n<li>JVM 是基于栈结构的运行环境.</li>\n<li>在活动线程中只有栈顶的帧才是有效的, 称为当前帧. 正在运行的方法称为当前方法, 栈帧是方法运行的基本结构<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599651901957-ab5e2709-beb1-4734-9043-4db8f1c21dc9.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=688&amp;originWidth=1233&amp;size=600692&amp;status=done&amp;style=none&amp;width=616.5\" alt=\"image.png\"></li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599652269172-18daaa75-9fee-47f8-b914-f4421be05a52.png#align=left&amp;display=inline&amp;height=340&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=680&amp;originWidth=1293&amp;size=548595&amp;status=done&amp;style=none&amp;width=646.5\" alt=\"image.png\" class=\"φcx\"></li>\n</ol>\n<h2 id=\"对象实例化\">对象实例化<a title=\"#对象实例化\" href=\"#对象实例化\"></a></h2>\n<p>后补</p>\n<h2 id=\"垃圾回收\">垃圾回收<a title=\"#垃圾回收\" href=\"#垃圾回收\"></a></h2>\n<p>后补</p>\n<h1 id=\"第五章-异常与日志\">第五章 异常与日志<a title=\"#第五章-异常与日志\" href=\"#第五章-异常与日志\"></a></h1>\n<p>throw 用在方法内部, throws 用在方法签名处</p>\n<h2 id=\"异常分类\">异常分类<a title=\"#异常分类\" href=\"#异常分类\"></a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599652938342-0d627604-b70f-4852-adf8-72102e8a1007.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=516&amp;originWidth=1269&amp;size=418781&amp;status=done&amp;style=none&amp;width=634.5\" alt=\"image.png\" class=\"φcx\"></p>\n<p>| 可预测异常<br>\n| 空指针异常, 边界条件有误 |<br>\n| — | — |<br>\n| 需捕捉的异常 | 链接超时, 可以尝试重试, 或者降级处理 |<br>\n| 可透出异常 | 使用框架时产生的异常, 并且框架可以处理 |<br>\n| 引起注意型 | 不可避免,需要由开发者处理 |<br>\n| 坦然处理型 | 授权失败, 重新授权 |</p>\n<h2 id=\"try-代码块\">try 代码块<a title=\"#try-代码块\" href=\"#try-代码块\"></a></h2>\n<ol>\n<li>finally 语句没有执行的原因:</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599653741067-b81066fc-5d4c-448b-b5d1-41291cd046c0.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=161&amp;originWidth=1296&amp;size=79968&amp;status=done&amp;style=none&amp;width=648\" alt=\"image.png\"><br>\n注意 finally 语句在 return 语句之后执行, 先将 return 的结果暂存下来, 即使 finally 中改变了 return 的值, 返回值仍然不会变, 为之前暂存的值</p>\n<ol start=\"2\">\n<li>不要在 finally 语句中使用 return 语句</li>\n<li>对象加锁应该在 try 代码块之前, 不然即使加锁失败也会触发 finally 执行解锁, 会抛出异常</li>\n</ol>\n<h2 id=\"异常的抛与接\">异常的抛与接<a title=\"#异常的抛与接\" href=\"#异常的抛与接\"></a></h2>\n<ol>\n<li>远程服务调用中推荐使用 Result 对象封装异常信息</li>\n</ol>\n<h2 id=\"日志\">日志<a title=\"#日志\" href=\"#日志\"></a></h2>\n<p>后补</p>\n<h1 id=\"第六章-数据结构与集合\">第六章 数据结构与集合<a title=\"#第六章-数据结构与集合\" href=\"#第六章-数据结构与集合\"></a></h1>\n<h2 id=\"集合框架图\">集合框架图<a title=\"#集合框架图\" href=\"#集合框架图\"></a></h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599654447466-282974e5-15d1-4a79-8f80-e39a8303fd00.png#align=left&amp;display=inline&amp;height=422&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=843&amp;originWidth=1279&amp;size=753849&amp;status=done&amp;style=none&amp;width=639.5\" alt=\"image.png\" class=\"φcx\"></p>\n<ol>\n<li>Queue 由于其本身的 FIFO 的特性和阻塞操作的特点, 经常被作为 Buffer 使用</li>\n<li>Map 类提供三种 Collection 视图: values(), entrySet(), keySet()</li>\n<li>多线程环境中推荐使用 ConcurrentHashMap, 而不是 HashMap</li>\n</ol>\n<h2 id=\"集合初始化\">集合初始化<a title=\"#集合初始化\" href=\"#集合初始化\"></a></h2>\n<p>bookmark 154<br>\nArrayList 扩容机制</p>\n<ol>\n<li>第一次 add , 发现数组大小等于待填入的数组索引, 使用 grow 扩容得到一个大小为 10 (由 newCapacity 判断数组为空) 的数组</li>\n<li>扩容公式: newCapacity=oldCapacity+(oldCapacity&gt;&gt;1). 如果 newCapacity 发生 int 溢出, 如果 newCapacity 大小比 minCapacity (2147483639) 要小的话, 就返回 newCapacity , 否则返回值为 size+1 的 minCapacity</li>\n</ol>\n<p>HashMap 中有两个比较重要的参数 Capacity(容量) 和 Load Factor(填充比例,一般为 0.75)<br>\n参数 threshold = Capacity* Loadfactor 表示 HashMap 中可以放入的元素个数<br>\n在第一次 put 时完成创建<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1599816144415-caa5d0ba-364c-41f3-9e48-dfeee8f5c361.png#align=left&amp;display=inline&amp;height=154&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=1111&amp;size=264344&amp;status=done&amp;style=none&amp;width=555.5\" alt=\"image.png\"><br>\nHashMap 的默认值大小为 16, ArrayList 大小为 10</p>\n<h2 id=\"数组与集合\">数组与集合<a title=\"#数组与集合\" href=\"#数组与集合\"></a></h2>\n<p>使用 Arrays.adList() 之后, 它会把数组变成一个集合, 但是不可以使用 LIst 中修改集合相关的方法. set()是允许的, 但是 add(), remove() 是错误的. 这是适配器模式, List 的底层仍然是该数组, asList() 的返回对象是一个 Arrays 的内部类, 该类并没有实现集合个数修改的相关方法. 该类继承至抽象类 AbstractList , 但是只实现了一部分功能, 所以在使用有些 ArrayList 方法时会抛出异常<br>\n解决方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Integer&gt; arrayList1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;));</span><br></pre></td></tr></table></figure>\n<p>使用 集合.toArray() 会导致泛型丢失<br>\n关于 toArray() 方法 Arr 分析参见 162 页<br>\n使用集合的 toArray(T[] array) 方法, 转换为数组时, 注意需要传入类型完全一样的数组, 并且它的容量为 list.size();<br>\nBookMark161</p>\n<h2 id=\"集合与泛型\">集合与泛型<a title=\"#集合与泛型\" href=\"#集合与泛型\"></a></h2>\n<div><h1 id=\"推荐文章\">推荐文章<a title=\"#推荐文章\" href=\"%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\"></a></h1><ul><li><a href=\"https://mvbbb.github.io/cxnppw/\">使用 Java 实现简单的 WebServer</a></li><li><a href=\"https://mvbbb.github.io/hy5u9w/\">JDBC与mysql数据库交互</a></li><li><a href=\"https://mvbbb.github.io/nwg3e5/\">Java 细节</a></li><li><a href=\"https://lailin.xyz/post/go-training-week4-clean-arch.html\">Go工程化(一) 架构整洁之道阅读笔记</a></li></ul></div>","prev":{"title":"D(la)P(ji)","link":"vf5dyb"},"next":{"title":"Java 细节","link":"nwg3e5"},"plink":"https://mvbbb.github.io/sn0gdd/","toc":[{"id":"第一章-计算机基础","title":"第一章 计算机基础","index":"1"},{"id":"第二章-面向对象","title":"第二章 面向对象","index":"2","children":[{"id":"oop-理念","title":"OOP 理念","index":"2.1"},{"id":"初始-java","title":"初始 Java","index":"2.2"},{"id":"类","title":"类","index":"2.3"},{"id":"方法","title":"方法","index":"2.4"},{"id":"重载","title":"重载","index":"2.5"},{"id":"泛型","title":"泛型","index":"2.6"},{"id":"数据类型","title":"数据类型","index":"2.7"}]},{"id":"第三章-代码风格","title":"第三章 代码风格","index":"3"},{"id":"第四章-走进-jvm","title":"第四章 走进 JVM","index":"4","children":[{"id":"字节码","title":"字节码","index":"4.1"},{"id":"类加载过程","title":"类加载过程","index":"4.2"},{"id":"内存布局","title":"内存布局","index":"4.3"},{"id":"对象实例化","title":"对象实例化","index":"4.4"},{"id":"垃圾回收","title":"垃圾回收","index":"4.5"}]},{"id":"第五章-异常与日志","title":"第五章 异常与日志","index":"5","children":[{"id":"异常分类","title":"异常分类","index":"5.1"},{"id":"try-代码块","title":"try 代码块","index":"5.2"},{"id":"异常的抛与接","title":"异常的抛与接","index":"5.3"},{"id":"日志","title":"日志","index":"5.4"}]},{"id":"第六章-数据结构与集合","title":"第六章 数据结构与集合","index":"6","children":[{"id":"集合框架图","title":"集合框架图","index":"6.1"},{"id":"集合初始化","title":"集合初始化","index":"6.2"},{"id":"数组与集合","title":"数组与集合","index":"6.3"},{"id":"集合与泛型","title":"集合与泛型","index":"6.4"}]},{"id":"推荐文章","title":"推荐文章","index":"7"}],"copyright":{"author":"Mvbbb","link":"<a href=\"https://mvbbb.github.io/sn0gdd/\" title=\"《码出高效》笔记\">https://mvbbb.github.io/sn0gdd/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}