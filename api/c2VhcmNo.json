[{"title":"Python与算法竞赛以及常用模板","date":"2021-02-02T11:17:54.000Z","date_formatted":{"ll":"Feb 2, 2021","L":"02/02/2021","MM-DD":"02-02"},"updated":"2021-02-03T04:20:57.149Z","content":"tags:[Python,算法]\ncategories:[教程与记录]\n\n多花点时间在算法上, instead of framework\n\n输入输出\n读入空格分隔的数据\n输入样例\n172 101 108 108 111 44\n模板代码\n123456a,b,c = map(int,input().split())#这种方式输入了3个int型的数字，split()代表以空格隔开。print(a,b,c)index = list(map(int,input().split()))#这种方式可以输入任意个int型的数字，在这里采用列表来存储。print(index)\n读取多行数据\n样例输入\n1272 101 108 108 111 4432 119 111 114 108 100 33\n模板代码\n1234567import syswhile True:    line=sys.stdin.readline()    if not line:        break    for i in line.split():        print((int(i)),end=&quot; &quot;)\n数字操作\n123456789101112131415import mathmath.ceil(x) #返回大于x或等于x的最小整数。math.floor(x)#返回小于x或等于x的最大整数。math.sqrt(x) #返回x的平方根。math.log(x[,底数]) #这种方式会返回一个以基数为底的x的对数，如果省略底数就是以2为底。math.pow(10,3) # 幂运算 1000.0round(3.5) #内置函数求四舍五入# 保留小数输出print(&#x27;保留2位小数格式为:%.2f&#x27;% mydigit)\nmath 库中的函数只适用于整数和浮点数, 涉及到复数运算需要用到 cmath 库\nASCII 与 CHAR 转换\n12chr(34)  #获取ASCII为34的字符ord(&#x27;*&#x27;) #获取*的ASCII码\n数据结构\n字典\n类似与 STL 中的 map\n1234567891011121314151617181920212223242526# 创建一个字典mydict = &#123;&#125;# 根据key取出value, 假如key不存在的话会抛出异常value = mydict[key]# 根据key取出value, default为未找到的情况下的默认返回值mydict.get(key,default)# 判断字典中是否存在keyif key in mydict# 清空字典中的元素mydict.clear()# 字典中添加key-valuemydict[key]=value# 删除字典中的元素del mydict[key]# 如果键在字典中，则移除它并返回其值，否则返回默认值。如果未给定默认值且键不在字典中，则会引发键错误。mydict.pop(key,default)# 修改value: 直接覆盖mydict[key]=value\n值得一提的是, 还有一种字典在竞赛中适用面更广\n二维数组\n定义方法\n1234# 定义一个七列七行的二维数组my_list = [[0 for i in range(7)] for j in range(7)]my_list = [[0]*7 for j in range(7)]board=[[0]*(N+1)]*(N+1)\n集合及其运算\n集合定义\n12345678910# 集合结构my_set = &#123;元素1,元素2,元素3&#125;myset=set()# 清空集合del my_set# remove()方法是移除指定元素，而pop()方法是直接删除集合中的第一个元素并输出my_set.pop() #会删除并输出第一个元素my_set.remove(6) #直接指定删除6\n集合运算\n交集\n1234567891011# 方法1——使用‘&amp;’运算符：&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A &amp; B&#123;&#x27;英语&#x27;, &#x27;语文&#x27;, &#x27;数学&#x27;&#125;# 方法2——使用intersection()方法：&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A.intersection(B)&#123;&#x27;英语&#x27;, &#x27;语文&#x27;, &#x27;数学&#x27;&#125;\n并集\n1234567891011#  方法1——使用‘|’运算符&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A | B&#123;&#x27;英语&#x27;, &#x27;物理&#x27;, &#x27;语文&#x27;, &#x27;政治&#x27;, &#x27;化学&#x27;, &#x27;数学&#x27;, &#x27;生物&#x27;, &#x27;地理&#x27;, &#x27;历史&#x27;&#125;#  方法2——使用union()方法&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A.union(B)&#123;&#x27;英语&#x27;, &#x27;物理&#x27;, &#x27;语文&#x27;, &#x27;政治&#x27;, &#x27;化学&#x27;, &#x27;数学&#x27;, &#x27;生物&#x27;, &#x27;地理&#x27;, &#x27;历史&#x27;&#125;\n差集\n123456789101112131415# 方法1——使用‘-’运算符&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A - B&#123;&#x27;物理&#x27;, &#x27;生物&#x27;, &#x27;化学&#x27;&#125;&gt;&gt;&gt; B - A&#123;&#x27;政治&#x27;, &#x27;历史&#x27;, &#x27;地理&#x27;&#125;# 方法2——使用difference()方法&gt;&gt;&gt; A = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;物理&#x27;,&#x27;化学&#x27;,&#x27;生物&#x27;&#125;&gt;&gt;&gt; B = &#123;&#x27;数学&#x27;,&#x27;语文&#x27;,&#x27;英语&#x27;,&#x27;政治&#x27;,&#x27;地理&#x27;,&#x27;历史&#x27;&#125;&gt;&gt;&gt; A.difference(B)&#123;&#x27;物理&#x27;, &#x27;生物&#x27;, &#x27;化学&#x27;&#125;&gt;&gt;&gt; B.difference(A)&#123;&#x27;政治&#x27;, &#x27;历史&#x27;, &#x27;地理&#x27;&#125;\n字符串\n列表转字符串\n12ls = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]str= &quot;&quot;.join(ls)\n字符串中字符的查找,统计,替换\n12345678910111213141516# 指定字符求个数my_str.count(x)# 找到指定字符, find方法来检索字符串中是否包含指定元素，# 如果包含该元素则返回该元素第一次出现的索引位置，如果不存在该字符则返回-1my_str.find(x)# index()方法和find()方法类似，index()方法在检索到指定字符的时候也会返回该字符第一次出现的索引位置，# 但是如果检索不到就会抛出异常my_str.index(x)# 指定区间的求字符个数, find和index同理my_str.count(&#x27;w&#x27;,0,5)#统计w在0-4之间存在的次数# 替代方法——replace(), 需要接收返回的副本 str = my_str.replace(old,new)\n字符串大小写转换\n1234# 大小写转换, 注意字符串是不可变对象需要接收返回的副本# lower()方法和upper()方法str = my_str.upper()#将字符串全部大写str = my_str.lower()#将字符串全部小写\n字符串子串查找\n12345678#  endswith()方法my_str.endswith(substring)# startswith()方法my_str.startswith(substring)# 查找子串, 不存在的话返回-1index = S.find(&#x27;SPAM&#x27;)\n切片和序列\nhttps://www.dotcpp.com/course/237\n参考文档\nC 语言网-Python 入门\n","plink":"https://mvbbb.github.io/nmmxgt/"},{"title":"关于PageHelper 分页插件的使用以及其中的坑","date":"2021-02-01T10:05:47.000Z","date_formatted":{"ll":"Feb 1, 2021","L":"02/01/2021","MM-DD":"02-01"},"updated":"2021-02-03T04:20:57.253Z","content":"categories:[Java,Spring]\ntags:[mybatis,SpringBoot,MySql]\n\n如何使用\n直接导入依赖\n123456&lt;!--分页插件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.2.13&lt;/version&gt;&lt;/dependency&gt;\n常见的使用方式\n123456public PageInfo findPage(int pageNum,int pageSize)&#123;      PageHelper.startPage(pageNum,pageSize);      List&lt;User&gt; list=userDao.selectAll();      PageInfo pageInfo = new PageInfo(list);      return pageInfo; &#125;\n说明\n\nstartPage()  方法调用后必须紧跟 MyBatis 查询方法\nstartPage()  方法是静态方法, 只需要传入 pageNum  和 pageSize  两个参数\n我们不需要对查询 SQL 做修改就可以达到分页的效果\nPageInfo 里面包含了一整个页面的信息\nPageInfo 构造函数传入的参数必须是 startPage()  后的那个方法得到的对象（原因下文解释）\n\nPageInfo 中的参数说明\n123456789101112131415161718192021222324252627282930313233343536public class PageInfo&lt;T&gt; extends PageSerializable&lt;T&gt; &#123;    // 当前页的页码    private int pageNum;    // 页大小, 为分页时提供的参数    private int pageSize;    // 当前页的记录条数    private int size;    // 由第几条开始(数据库行号)    private int startRow;    // 第几条结束(数据库行号)    private int endRow;    // 一共有多少页    private int pages;    // 前一页的页号, 如果没有前一页就是为0    private int prePage;    // 后一页的页号, 如果没有前一页就是为0    private int nextPage;    // 是否是第一页    private boolean isFirstPage;    // 是否是最后一页    private boolean isLastPage;    // 是否有前一页    private boolean hasPreviousPage;    // 是否有后一页    private boolean hasNextPage;    // 每页显示的页码个数, 在构造方法里面被默认设置为8    private int navigatePages;    // 页码数    private int[] navigatepageNums;    // 首页    private int navigateFirstPage;    // 尾页    private int navigateLastPage;    // 方法省略&#125;\n另外它还继承自 PageSerializable``&lt;``T``&gt;\n123456789public class PageSerializable&lt;T&gt; implements Serializable &#123;    private static final long serialVersionUID = 1L;    // 当前页的记录条数    protected long total;    // 当前页的每一条记录    protected List&lt;T&gt; list;    // 方法省略&#125;\nPageHelper 使用中的坑\n需求描述\n出于安全性的考虑, 我想要查询到的 POJO 映射到 VO 类中，VO 类相比 POJO 类缺少了某些私密属性， 将 VO 作为基本元素封装到 PageInfo 中, 于是我写出来如下代码\n123456789101112131415PageInfo&lt;PostItemVO&gt; selectAll() &#123;    // 开启分页 （PageNum,PageSize）    PageHelper.startPage(1, 2);    List&lt;Post&gt; posts = postMapper.selectAll();    // 属性拷贝    List&lt;PostItemVO&gt; postItemVOS = new ArrayList&lt;&gt;();    for (Post post : posts) &#123;        PostItemVO postItemVO = new PostItemVO();        BeanUtils.copyProperties(post,postItemVO);        postItemVOS.add(postItemVO);    &#125;    // PageInfo 封装    PageInfo&lt;PostItemVO&gt; pageInfo = new PageInfo&lt;PostItemVO&gt;(postItemVOS);    return pageInfo;&#125;\nPost 是我的 POJO, PostVO 是对应的 VO 类。数据库中查询得到 Post 集合，将其属性拷贝到 PostVO 集合。\n乍一看其实写的不存在问题，但是我们在查询时就会出现问题\n数据库表如下, 共有四条记录\n\n得到的 PageInfo 如下\n\n数据库中共有 4 条记录, 但是查询得到的 total 只有 2 条, 除此之外 nextPage , endRow....  字段都出现了问题。\n解决方法\n方法一\n先直接将查询结果封装到一个 PageInfo 中, 之后将将该 PageInfo 的 list 取出来做改造\n123456789101112131415PageInfo&lt; selectAll() &#123;\t\tPageHelper.startPage(1, 2);\t\tList&lt;Post&gt; posts = postMapper.selectAll();\t\t// 直接将Post封装\t\tPageInfo pageInfo = new PageInfo&lt;&gt;(posts);\t\t// 取出List进行数据转移\t\tArrayList&lt;PostItemVO&gt; postItemVOS = new ArrayList&lt;&gt;();\t\tpageInfo.getList().forEach(post-&gt;&#123;\t\t\tPostItemVO postItemVO = new PostItemVO();\t\t\tBeanUtils.copyProperties(post,postItemVO);\t\t\tpostItemVOS.add(postItemVO);\t\t&#125;);\t\tpageInfo.setList(postItemVOS);\t\treturn pageInfo;\t&#125;\n查询结果如下\n\n方法二 推荐\n更加优雅的方式, 我们对查询语句进行改造, 使其直接返回一个 VO 集合，也就是说数据库表直接映射到 VO 上, 之后直接将该 List 封装在 PageInfo 之后, 直接返回就行了.\n1 需要对 PostMapper.xml  进行修改\n1234567891011121314151617&lt;!--结果映射--&gt;&lt;resultMap id=&quot;ItemMap&quot; type=&quot;im.yzh.mymyblog.model.vo.PostItemVO&quot;&gt;  &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;  &lt;result column=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;title&quot; /&gt;  &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;  &lt;result column=&quot;published&quot; jdbcType=&quot;BIT&quot; property=&quot;published&quot; /&gt;  &lt;result column=&quot;category_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;categoryId&quot; /&gt;&lt;/resultMap&gt;&lt;!--一共有哪些字段--&gt;&lt;sql id=&quot;Item_Column_List&quot;&gt;  id, title, update_time, published, category_id&lt;/sql&gt;&lt;!--查询SQL--&gt;&lt;select id=&quot;selectAllItem&quot; resultMap=&quot;ItemMap&quot;&gt;  select &lt;include refid=&quot;Item_Column_List&quot;/&gt;  from post order by update_time desc&lt;/select&gt;\n2 在 PostMapper 接口中添加相关方法\n1List&lt;PostItemVO&gt; selectAllItem();\n3 编写测试\n123456PageInfo&lt;PostItemVO&gt; selectAllItem() &#123;    PageHelper.startPage(1, 2);    List&lt;PostItemVO&gt; posts = postMapper.selectAllItem();    PageInfo&lt;PostItemVO&gt; pageInfo = new PageInfo&lt;PostItemVO&gt;(posts);    return pageInfo;&#125;\n\n如果你有更好的解决方法欢迎留言评论\n原因分析\ntotal 字段为例, 为什么正确的查询结果是 4, 但是用之前的错误查询方法的结果是 2。\n先分析之前的错误查询方法的代码。\n打个断点，我们发现，在 startPage()  调用之后, 随后的一个查询被进行了分页, 查询结果被封装为了一个 Page 对象：\n\n查看 com.github.pagehelper.``Page 源代码, Page 对象中包含了之后被封装到 PageInfo 中的信息：\n\n也就是说, 我们的查询结果就已经包含了 PageInfo 之后需要的信息。查询得到的是一个 Page 实例，而不仅仅是一个 List， 所以说， 只对 posts 进行 POJO 的拷贝是不够的, 这会丢失我们的分页信息。\n对正确的查询过程进行调试分析：\n1 被分页之后得到一个 Page 对象：\n\n2 调用 PageInfo 构造函数会执行一个方法判断传入的参数是否为 Page 对象：\n\n假如是之前的那种错误方法, 我们传入的是 List 对象, 那么 this.total  就被初始化为了 List 的长度。 这就解释了为什么错误的方法得到的分页对象的 total 为 2\n参考资料\n官方文档-如何使用分页插件\nCSDN-PageHelper，从 pageinfo 中取到的 total 不正确的处理。\n","plink":"https://mvbbb.github.io/wwi0un/"},{"title":"mybatis-generator-maven插件与lombok的引入","date":"2021-01-28T13:48:46.000Z","date_formatted":{"ll":"Jan 28, 2021","L":"01/28/2021","MM-DD":"01-28"},"updated":"2021-02-03T04:20:57.297Z","content":"插件介绍\nmybatis 通过 xml 配置文件将 java 工程中的对象与数据库建立联系, 但是当数据库中的表过多之后, 编写 xml 就是一件令人头疼的事. 使用 mybatis-generator  插件可以减去编写 xml,pojo,dao 的烦恼.\n该插件的特点:\n\n生成 pojo 与 数据库结构对应. 每个 pojo 类对应数据库中的一张表, 每个字段对应表中的一个属性\n会为每个 pojo 自动生成 getter/setter 方法\n自动生成 mapper.xml , 提供了一些基础的 CRUD sql 语句\n会为每个 pojo 生成对应的 dao, 并提供一些最基本的 CRUD 操作\n\n\n使用方法\n1 引入依赖\n12345678910111213141516# dependencies 节点下&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;  &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt;# plugins 节点下&lt;plugin&gt;  &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;  &lt;version&gt;1.3.7&lt;/version&gt;  &lt;configuration&gt;    &lt;verbose&gt;true&lt;/verbose&gt;    &lt;overwrite&gt;true&lt;/overwrite&gt;  &lt;/configuration&gt;&lt;/plugin&gt;\n2 编写配置文件 generatorConfig.xml , 在生成代码的时候插件会读取配置文件\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!-- 配置文件，放在resource目录下即可 --&gt;    &lt;!--数据库驱动个人配置--&gt;    &lt;classPathEntry            location=&quot;E:\\JavaProject\\mysql-connector-java-8.0.18.jar&quot;/&gt;    &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;        &lt;!--可以使用``包括字段名，避免字段名与sql保留字冲突报错--&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库链接地址账号密码--&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/myblog?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!--生成Model类存放位置--&gt;        &lt;javaModelGenerator targetPackage=&quot;im.yzh.mymyblog.model.pojo&quot;                            targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--生成mapper映射文件存放位置--&gt;        &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!--生成Dao类存放位置--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;im.yzh.mymyblog.model.dao&quot;                             targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!--生成对应表及类名--&gt;        &lt;table schema=&quot;root&quot; tableName=&quot;post&quot; domainObjectName=&quot;Post&quot;               enableCountByExample=&quot;false&quot;               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;        &lt;table tableName=&quot;comment&quot; domainObjectName=&quot;Comment&quot; enableCountByExample=&quot;false&quot;               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n3 点击 generator 即可生成\n\n4 生成的效果参考\n\n存在的问题: 假如我们想要在 pojo 中使用 lombok 怎么办? 生成的时候只带了 getter/setter, 一个个的删除再添加 lombok 好像也不是明智的行为? 而且 generatorConfig  中并不提供 lombok 的配置项.\n如何引入 lombok\n我们需要对 mybatis-generator  插件本身源文件进行修改来达到引入 lombok 的效果.\n1 编写插件, 自己的 LombokPlugin插件：\n注意包名不能修改。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.mybatis.generator.plugins;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.PluginAdapter;import org.mybatis.generator.api.dom.java.Interface;import org.mybatis.generator.api.dom.java.Method;import org.mybatis.generator.api.dom.java.TopLevelClass;public class LombokPlugin extends PluginAdapter &#123;\t@Override\tpublic boolean validate(List&lt;String&gt; list) &#123;\t\treturn true;\t&#125;\t@Override\tpublic boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123;\t\t//添加domain的import\t\ttopLevelClass.addImportedType(&quot;lombok.Data&quot;);\t\ttopLevelClass.addImportedType(&quot;lombok.Builder&quot;);\t\ttopLevelClass.addImportedType(&quot;lombok.NoArgsConstructor&quot;);\t\ttopLevelClass.addImportedType(&quot;lombok.AllArgsConstructor&quot;);\t\t//添加domain的注解\t\ttopLevelClass.addAnnotation(&quot;@Data&quot;);\t\ttopLevelClass.addAnnotation(&quot;@Builder&quot;);\t\ttopLevelClass.addAnnotation(&quot;@NoArgsConstructor&quot;);\t\ttopLevelClass.addAnnotation(&quot;@AllArgsConstructor&quot;);\t\t//添加domain的注释\t\ttopLevelClass.addJavaDocLine(&quot;/**&quot;);\t\ttopLevelClass.addJavaDocLine(&quot;* Created by Mybatis Generator on &quot; + date2Str(new Date()));\t\ttopLevelClass.addJavaDocLine(&quot;*/&quot;);\t\treturn true;\t&#125;\t@Override\tpublic boolean clientGenerated(Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123;\t\t//Mapper文件的注释\t\tinterfaze.addJavaDocLine(&quot;/**&quot;);\t\tinterfaze.addJavaDocLine(&quot;* Created by Mybatis Generator on &quot; + date2Str(new Date()));\t\tinterfaze.addJavaDocLine(&quot;*/&quot;);\t\treturn true;\t&#125;\t@Override\tpublic boolean modelSetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) &#123;\t\t//不生成getter\t\treturn false;\t&#125;\t@Override\tpublic boolean modelGetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) &#123;\t\t//不生成setter\t\treturn false;\t&#125;\tprivate String date2Str(Date date) &#123;\t\tSimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);\t\treturn sdf.format(date);\t&#125;&#125;\n2 编译得到 class 文件，将该文件复制到 mybatis-generator-core-1.3.7.jar  下的 org\\mybatis\\generator\\plugins\\  目录下，该 jar 包存放在 maven 本地仓库中\n\n\n假如你嫌麻烦的话可以直接使用我生成好的 class 文件, 下载之后重命名为 LombokPlugin.class 放到对应文件夹下。\nhttps://gitee.com/Mvbbb/pichost/raw/master/20210128233054.class\n\n3 修改 generatorConfig.xml  ， 在 context  节点下， property  子节点后添加\n1234&lt;!--添加lombok插件配置项--&gt;&lt;plugin type=&quot;org.mybatis.generator.plugins.LombokPlugin&quot;&gt;  &lt;property name=&quot;hasLombok&quot; value=&quot;true&quot;/&gt;&lt;/plugin&gt;\n最终的 generatorConfig.xml 参考\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!-- 配置文件，放在resource目录下即可 --&gt;    &lt;!--数据库驱动个人配置--&gt;    &lt;classPathEntry            location=&quot;E:\\JavaLearning\\mybatis-generator-lombok-test\\mysql-connector-java-8.0.18.jar&quot;/&gt;    &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;        &lt;!--可以使用``包括字段名，避免字段名与sql保留字冲突报错--&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!--添加lombok插件配置项--&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.LombokPlugin&quot;&gt;            &lt;property name=&quot;hasLombok&quot; value=&quot;true&quot;/&gt;        &lt;/plugin&gt;        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库链接地址账号密码--&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/myblog?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!--生成Model类存放位置--&gt;        &lt;javaModelGenerator targetPackage=&quot;com.example.mybatisgeneratorlomboktest.pojo&quot;                            targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--生成mapper映射文件存放位置--&gt;        &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!--生成Dao类存放位置--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.example.mybatisgeneratorlomboktest.dao&quot;                             targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!--生成对应表及类名--&gt;        &lt;table schema=&quot;root&quot; tableName=&quot;post&quot; domainObjectName=&quot;Post&quot;               enableCountByExample=&quot;false&quot;               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;        &lt;table tableName=&quot;comment&quot; domainObjectName=&quot;Comment&quot; enableCountByExample=&quot;false&quot;               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n生成的 pojo 效果参考\n12345678910111213@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Comment &#123;    private Long id;    private String nickname;    private String email;    private String content;&#125;推荐文章静态资源映射","plink":"https://mvbbb.github.io/iq1x0p/"},{"title":"静态资源映射","date":"2021-01-20T09:00:44.000Z","date_formatted":{"ll":"Jan 20, 2021","L":"01/20/2021","MM-DD":"01-20"},"updated":"2021-02-03T04:20:57.353Z","content":"前言：\nSpringBoot 默认将 resources  目录下的/static,/public,/resources,/META-INF/resources设置为静态资源路径\n场景一: 所有的静态资源访问都通过一个特定的前缀, 以区分静态请求或者动态请求\n\n配置:\n123spring:  mvc:    static-path-pattern: /res/**\n效果: 原来存放在静态资源目录中的 text.txt  文件的访问链接由 localhost/text.txt   变成 localhost/res/text.txt\n场景二: 我想要使某个文件夹中的内容成为可以被访问的静态资源\n方法一:\n配置:\n123456spring:  web:    resources:      static-locations:        - classpath:/haha/        - file:E:/JavaProject/mvc/files/\n效果:\n\n可通过 localhost/text2.txt  访问位于 E:\\JavaProject\\mvc\\files\\  下的 text2.txt  文件\n可以通过 localhost/text.txt  访问位于 resources\\haha\\  下的 text.txt  文件\n\n方法二:\n编写配置类\n123456789101112/** * 描述：配置地址映射 */@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        //将以 /images/ 开头的请求映射到本地的 FILE_DIR 目录下        registry.addResourceHandler(&quot;/images/**&quot;).                addResourceLocations(&quot;file:&quot;+ Constant.FILE_DIR);    &#125;&#125;\n场景三: 我想要实现首页效果, 也就是访问地址默认显示 index.html, 但是地址栏里面没有 index.html\n做法: 直接将 index.html 放在静态资源路径下\n场景四: 我想要显示网页图标\n做法: 直接将 favicon.ico 放在静态资源路径下\n推荐文章mybatis-generator-maven插件与lombok的引入","plink":"https://mvbbb.github.io/mbrk53/"},{"title":"【网络协议】TCP分段与IP分片","date":"2021-01-04T13:23:50.000Z","date_formatted":{"ll":"Jan 4, 2021","L":"01/04/2021","MM-DD":"01-04"},"updated":"2021-02-03T04:20:57.357Z","content":"https://blog.csdn.net/ns_code/article/details/30109789\nhttps://www.jianshu.com/p/f9a5b07d99a2\n\n","plink":"https://mvbbb.github.io/olnngo/"},{"title":"准备迁移了","date":"2021-01-04T11:15:50.000Z","date_formatted":{"ll":"Jan 4, 2021","L":"01/04/2021","MM-DD":"01-04"},"updated":"2021-02-03T04:20:57.377Z","content":"今天遇到一个特别恼火的事儿，写了一篇有点长的文章，然后通过的 coding 的自动部署老是部署失败。初步判断是由于 yuque-hexo 插件在生成文章时用时过长，被判定超时导致的。\n\n\n加之 coding 打算逐步下线他免费提供的静态网页托管，代之的是腾讯云提供的存储桶托管，虽说稳定性是提高了，但是 COS 是要付费的，不能白嫖了。\n准备弃用 Coding 的持续集成功能了，并将博客部署到 GitHub，以后使用 GitHub action 了。\n\nGithub Action 的使用者基数大，出现问题更容易找到解决方案\n逛 GitHub 项目的时候发现许多项目都使用到了 GitHub action，需要进一步了解一下。\n\n虽说部署到 GitHub 之后虽然说访问速度会下降，但是影响也不算大，用梯子就行了。\n放假之后再迁移，现在先复习。\n\n","plink":"https://mvbbb.github.io/qwgn6n/"},{"title":"计算机网络学习总结[转载][2]","date":"2021-01-04T08:52:50.000Z","date_formatted":{"ll":"Jan 4, 2021","L":"01/04/2021","MM-DD":"01-04"},"updated":"2021-02-03T04:20:58.269Z","content":"本篇包含\n\n网络层\n数据链路层\n物理层\n\n\n网络层\n网络层概述\n在当今我们是使用无连接的方式的。网络提供数据报服务，无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。\nIP 协议\nIP 的概述\nIP 协议对应的是 IP 地址，那么什么是 IP 地址呢？\n维基百科上是这样解释的：\n\nIP 地址（英语：IP Address, 全称：Internet Protocol Address），又译为网际协议地址、互联网协议地址。当设备连接网络，设备将被分配一个 IP 地址，用作标识。通过 IP 地址，设备间可以互相通讯，如果没有 IP 地址，我们将无法知道哪个设备是发送方，无法知道哪个是接收方。[2] IP 地址有两个主要功能：标识设备或网络 和 寻址（英语：location addressing）。\n\n上面的一堆文字其实无非解释了两个点，总结如下：\n\nIP 地址是用来标记主机的地址，没有 IP 地址就无法识别主机。（标志主机）\n因为唯一标记主机，所以可以用来在网络中查找主机。（寻址）\n\n现在想一下前面我们说到的 MAC 地址，MAC 地址是一台主机的身份象征。一台主机从出厂以后，MAC 地址就唯一确定了，无法更改（当然也可以通过软件修改，但是必须得确保同一局域网下不能有两台 MAC 地址相同的主机）。\n那么，为什么有了 MAC 地址，还需要 IP 地址？或者说是有了 IP 地址，还需要 MAC 地址？\n看完上面两篇文章，我总结如下：\n\n历史原因： 以太网诞生于因特网之前，在 IP 地址之前 MAC 地址就已经在使用了。两者结合使用，是为了不影响已存在的协议\n分层实现： 对网路协议进行分层以后，数据链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考数据链路层的影响。\n分工合作： IP 地址是会随着主机接入网络的不同而发生改变的，而 MAC 一般不会改变。这样的话，我们可以使用 IP 地址进行寻址，当数据报和目的主机处于同一网络时，就使用 MAC 地址进行数据交付。\n\nIP 数据报\nIP 数据的样子是这样的：\n\n有几个重要的东西必须得进行说明一下：\n\n版本号：占用 4 位二进制数，表示该 IP 数据报使用的 IP 协议版本。目前 Internet 中使用的主要是 TCP/IP 协议族中版本号为 4 的 IP 协议。\n头长度：占用 4 位二进制位，此域指出整个报头的长度（包括选项），该长度是以 32 位二进制数为一个计数单位的，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通 IP 数据报（没有任何选项）该字段的值是 5（即 20 个字节的长度）。\n服务类型：服务类型（TOS、type of service）：占用 8 位二进制位，用于规定本数据报的处理方式。\n生存时间（TTL，Time To Live）：占用 8 位二进制位，它指定了数据报可以在网络中传输的最长时间。实际应用中把生存时间字段设置成了数据报可以经过的最大路由器数。TTL 的初始值由源主机设置（通常为 32、64、128 或 256），一旦经过一个处理它的路由器，它的值就减 1。当该字段为 0 时，数据报就丢弃，并发送 ICMP 报文通知源主机，因此可以防止进入一个循环回路时，数据报无休止地传输下去。\n上层协议标识：占用 8 位二进制位，IP 协议可以封装多种上层协议 PDU，目标端根据协议标识就可以把收到的 IP 数据报送到 TCP 或 UDP 等处理此报文的上层协议了。\n\n首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。IP 数据报首部的可变部分，从 1 个字节到 40 个字节不等，取决于所选择的项目。有了可变部分可以增加 IP 数据报的功能，但是往往不常用。\nIP 数据报分组转发流程\n\n\nIP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。\n\n\n当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。\n\n\n网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器\n\n\n在路由表中，对每一条路由，最主要的是（目的网络地址，下一跳地址）\n\n\nIP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。\n\n\n只有到达最后一个路由器时，才试图向目的主机进行直接交付。\n\n\n虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即为特定的目的主机指明一个路由。\n采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。\n默认路由：\n\n路由器分组转发算法：\n(1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。\n(2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。\n(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。\n(4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。\n(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。\n(6)   报告转发分组出错。\nIP 数据报分片\n为什么要对 IP 数据报进行分片？\nIP 协议理论上允许的最大 IP 数据报为 65535 字节（16 位来表示包总长）。但是因为协议栈网络层下面的数据链路层一般允许的帧长远远小于这个值，例如以太网的 MTU（即 Maximum Transmission Unit，最大传输单元）通常在 1500 字节左右。所以较大的 IP 数据包会被分片传递给数据链路层发送，分片的 IP 数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的重组，将其还原为一个完整的 IP 数据报，再提交给上层协议处理。\n怎样对 IP 数据报进行分片？\n过程：\n\n\n一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。\n\n\n因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。\n\n\n于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。\n\n\n原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。(片偏移字段）\n\n\n片偏移是以 8 个字节为单位来进行偏移的，因此要除以 8\n\n\nIP 地址的划分与分类\n分类编址的 IP 地址\n\n网络号和主机号取特殊值时代表的含义\n\n划分子网的 IPv4 地址\n\n\n无分类的 IPv4 地址 CIDR 与路由聚合**\n无分类 CIDR 提出的背景\n划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：\n\n\nB 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！\n\n\n互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。\n\n\n整个 IPv4 的地址空间最终将全部耗尽\n\n\n\nCIDR 干了什么\n\n\nCIDR消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。\n\n\nCIDR 使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。\n\n\nIP 地址从三级编址（使用子网掩码）又回到了两级编址。\n\n\nCIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如： 220.78.168.0/24\n\n\nCIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。\n\n\n对于 /20   地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中 1 的个数。\n128.14.32.0/20 表示的地址块共有 212 个地址**（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。**\n\n\n\n\n在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。\n\n\n128.14.32.0/20 地址块的最小地址：128.14.32.0\n\n\n128.14.32.0/20 地址块的最大地址：128.14.47.255\n\n\n全 0 和全 1 的主机号地址一般不使用。\n\n\n\n路由聚合\n\n\n一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。\n\n\n路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。\n\n\n前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C   类地址。\n\n\n这些 C 类地址合起来就构成了超网\n\n\nCIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。\n\n\n通过一个网络号就可以查找 ISP 了，非常方便。\n**\n\n最长匹配\n\n\n使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果\n\n\n应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配 (longest-prefix matching)。\n\n\n网络前缀越长，其地址块就越小，因而路由就越具体 (more specific) 。\n\n\n\nNAT 协议\nNAT 技术其非常简单，那么 NAT 它的作用是什么呢？使在专用网上使用专用地址的主机与互联网上的主机通信\n这种方法需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做NAT 路由器，它至少有一个有效的外部全球 IP 地址。这样，所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和因特网连接。另外，这种通过使用少量的公有 IP 地址代表较多的私有 IP 地址的方式，将有助于减缓可用的 IP 地址空间的枯竭。\n转换过程：\n\n\n内部主机 A 用本地地址 IPA 和互联网上主机 B 通信所发送的数据报必须经过 NAT 路由器。\n\n\nNAT 路由器将数据报的源地址 IPA 转换成全球地址 IPG，并把转换结果记录到 NAT 地址转换表中，目的地址 IPB 保持不变，然后发送到互联网。\n\n\nNAT 路由器收到主机 B 发回的数据报时，知道数据报中的源地址是 IPB 而目的地址是 IPG。\n\n\n根据 NAT 转换表，NAT 路由器将目的地址IPG 转换为 IPA，转发给最终的内部主机 A。\n\n\n\n简单来说，NAT 技术就是实现局域网与互联网通信的一项协议。 NAT 又可以分为三种不同的类型：\n\n\n静态 NAT(Static NAT)： 静态 NAT 设置起来最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。当一个内部主机必须被作为一个固定的外部地址访问时，通过静态 NAT 实现。\n\n\n动态地址 NAT(Pooled NAT)： 动态 NAT 则是在外部网络中定 义了一系列的合法地址（地址池），采用动态分配的方法映射到内部网络。动态 NAT 转换的工作过程是这样的，当有一个内部主机需要访问外网时，从公用 IP 地址池中取出一个可用的地址分配给该主机使用。当通信完成后，所获取的公用 IP 地址也被释放回地址池中。外部公用 IP 在被分配给一个内部主机通信使用时，该地址不能不能再次被分配给其他内部主机使用。\n\n\n网络地址端口转换 NAPT（Port－Level NAT）： NAPT 是把内部地址映射到外部网络的一个 IP 地址的不同端口上。NAPT（Network Address Port Translation），即网络端口地址转换，可将多个内部地址映射为一个合法公网地址，但以不同的协议端口号与不同的内部地址相对应，也就是&lt;内部地址+内部端口&gt;与&lt;外部地址+外部端口&gt;之间的转换。\n\n\n在内部主机与外部主机通信时，在 NAT 路由器上发生了两次地址转换：\n\n离开专用网时：替换源地址，将内部地址替换为全球地址；\n进入专用网时：替换目的地址，将全球地址替换为内部地址；\n\nARP 协议\n前面说到 IP 地址用来寻址，当目的地址和数据报处于同一网络时，MAC 地址用来交付数据报。现在有一个问题，主机 A 要给主机 B 发送消息，消息经过一系列地转发，终于找到了主机 B 的 IP 地址。但是，我们都知道，数据在链路层的传输是需要 MAC 地址的，仅仅知道 B 的 IP 地址是无法进行通信的。请看下面这张图：\n\n这个时候，ARP 协议就派上用场了。ARP 全称是地址解析协议（Address Resolution Protocol），**其基本功能为透过目标设备的 IP 地址，查询目标设备的 MAC 地址，**以保证通信的顺利进行，它是 IPv4 中网络层必不可少的协议。\n如同交换机工作在数据链路层一样，路由器是工作在网络层的。交换机有 CAM 表，路由器也有路由表。\n现在路由器要给主机 B 发送一条消息，必须得知道主机 B 的 MAC 地址才能进行通信。这个时候路由器会发送一个 ARP 请求，该请求是以广播的形式发送的,以太网帧的目的地址全为 1，每一台连接到该路由器的主机都收到得到这条消息。但是只有主机 B 检查到自己的 IP 地址符合要求。于是主机 B 发送给路由器一条 ARP 响应，把自己的 MAC 的地址告诉了路由器。就像下面图示的那样：\n\n每次路由器发送一个 ARP 请求的时候，就会增加一条数据，这一条数据记录了 IP 地址对应的 MAC 地址，这样路由器下次再给该主机发送消息的时候就不用广播了。当然如同交换机的 CAM 表中的数据有生存了时间一样，路由表中的数据也有生存时间。试想一下，如果数据一直存在，那么路由器岂不是需要花大量的存储空间来缓存已经失效的数据。\n使用 ARP 的 4 种情况\n\n\n发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。\n\n\n发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。\n\n\n发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。\n\n\n发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。\n\n\n路由\n路由原理\n当 IP 子网中的一台主机发送 IP 分组数据给同一 IP 子网的另一台主机时，它将直接把 IP 分组数据送到网络上，对方就能收到。\n送给不同 IP 子网上的主机时，它要选择一个能到达目的子网上的路由器，把 IP 分组数据送给该路由器，\n由路由器负责把 IP 分组送到目的地。\n如果没有找到这样的路由器，主机就把 IP 分组送给一个称为 “缺省网关（default gateway）”的路由器上。\n“缺省网关”是每台主机上的一个配置参数，它是接在同一个网络上的某个路由器端口的 IP 地址。\n网关：问路由器的 IP，其他的电脑必须和网关一个 IP 段才能访问路由器。\n路由选择方式\n典型的路由选择方式有两种：静态路由和动态路由。  \n静态路由是由网络管理员手工配置的路由信息：\n\n除非网络管理员干预，否则静态路由不会发生变化。\n由于静态路由不能对网络的改变作出反映，一般用于网络规模不大、拓扑结构固定的网络中。\n\n静态路由的优点是简单、高效、可靠。在所有的路由中，静态路由优先级最高。当动态路由与静态路由发生冲突时，以静态路由为准。  \n动态路由是网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程，它能实时地适应网络结构的变化。\n动态路由机制的运作依赖路由器的两个基本功能：对路由表的维护；路由器之间适时的路由信息交换。\n动态路由适用于网络规模大、网络拓扑复杂的网络。当然，各种动态路由协议会不同程度地占用网络带宽和 CPU 资源。\n路由器与路由转发表\n每个路由器中都有一个路由表和 FIB(Forward Information Base)表：\n\n路由表用来决策路由。\nFIB 用来转发分组。\n\n路由表：\n\n这里个表都用来保存路由信息，路由表通常由路由协议和路由管理模块维护，\n包括更多的信息（IP 地址/IP 子网、下一跳、路由度量、超时间等）；\n\n路由表中路由有三类：\n（1）链路层协议发现的路由（即是直连路由）\n（2）静态路由。\n（3）动态路由协议发现的路由。\n转发表（FIB）：是基于路由生成的，路由器实际转发时使用转发表（只包括 IP 地址/IP 子网和下一跳/出接口）。\n路由器的结构\n\n路由器的工作流程\n\n路由协议\n因特网采用分层的路由选择协议\n\n常见的路由选择协议\n\n内部网关协议 RIP\n路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。\nRIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。\nRIP 是一种分布式的、基于距离向量的路由选择协议。\nRIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。\n\n路由器到直连网络的距离定义为 1\n路由器到非直连网络的距离定义为所经过的路由器数量+1\n\n这里的“距离”实际上指的是“最短距离”。\n\n\n\nRIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。\nRIP 协议的三个特点\n(1) 仅和相邻路由器交换信息。\n(2) 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。\n(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。\n工作过程\n\n\n路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。\n\n\n以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。\n\n\n经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。\n\n\n\n\nRIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。\n\n\n虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。\n\n\n\n\nRIP 优缺点\n\n\n优点：\n\n实现简单，开销较小。\n\n\n\n缺点：\n\n\nRIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。\n\n\n路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。\n\n\n“坏消息传播得慢”，又被称为路由环路，距离无穷计数问题，使更新过程的收敛时间过长。\n\n\n\n\n开放最短路径优先（OSPF）\nOSPF 协议是为了克服 RIP 的缺点而开发的。该算法基于 dijkstra 提出的最短路径优先算法。\n\nOSPF 是基于链路状态的， 而不像 RIP 那样基于距离向量\nOSPF 采用 SPF 算法计算路由，从算法上保证了不会产生路由环路\nOSPF 不受网络规模限制， 更新效率高\n链路状态是指本路由器和哪些路由器相邻，以及相应的链路代价（距离，时延，带宽）\n\n\n\n\n\n\n\nICMP 协议\n在 IP 通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是 ICMP 报文。在 IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助 IP 协议，交换各种各样的控制信息而被制造出来的。\n\n\nICMP 差错报告报文: 路由器收到错误分组, 向源 IP 地址发送一个报文, 被称为 ICMP 差错报文.\n\n\n\nICMP 协议的应用: Traceroute\n\nIPV6 协议\n我们前面说的 IP 地址其实是 IPV4，那么，为什么已经有 IPIV4 了，还要来一个 IPV4 呢？原来是这样的，早在上个世纪，人们就预料到 IPV4 地址枯竭的一天，为了解决这个问题，开始了 IPV6 的研发。\n**IPv6 (IP version 6)是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。**IPv4 的地址长度为 4 个 8 位字节,即 32 比特。而 IPv6 的地址长度则是原来的 4 倍,即 128 比特,一般写成 8 个 16 位字节。可以看到，IPV6 的地址是取之不尽，用之不竭的，那么现在为什么不把 IPV4 全部换成 IPV6 呢？\n从 IPV4 切换到 IPV6 极其耗时,需要将网络中所有主机和路由器的 IP 地址进行重新设置。当互联网广泛普及后,替换所有 IP 地址会是更为艰巨的任务。\n在现存的网络中，既有 IPV4 又有 IPV6，那么它们之间是怎么通信的呢？有两种技术：双协议栈、隧道技术，下面分别进行介绍：\n\n双协议栈：改变 IP 地址的首部，在首部进行转换的过程中，IPV6 的首部的部分信息会丢失，而且这种转换的损失不可避免。\n隧道技术：何谓隧道技术了？其实完全可以通过字面的意思理解。下面还是以画图的方式帮助大家理解。隧道技术说白了就是数据在传输的时候进行了另一种的封装与解封，如图数据由 IPV6 网络进入到 IPV4 的网络，需要把 IPV6 的数据包封装在 IPV4 的数据包里。\n\n\n数据链路层\n简介\n在本章中我们研究的是在同一个局域网中,分组怎样从一台主机传送到另一台主机,但并不经过路由器转发。 从整个互联网来看,局域网仍属于数据链路层的范围，并不将其放到网络层中讨论，因为网络层讨论的是分组怎么从一个网络通过路由器转发到另一个网络。\n数据链路层使用的信道主要有以下两种类型：\n\n点对点信道：一对一的点对点通信方式。\n广播信道：一对多的广播通信方式。\n\n本章最重要的内容是:\n\n数据链路层的点对点信道和广播信道的特点,以及这两种信道所使用的协议(PPP 协议以及 CSMA/CD 协议)的特点。\n数据链路层的三个基本问题:封装成帧、透明传输和差错检测。\n以太网MAC 层的硬件地址。\n适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。\n\n使用点对点信道的数据链路层\n基本术语\n（1）链路 (link): 就是从一个结点到相邻结点的一段物理线路(有线或无线),而中间没有任何其他的交换结点。在进行数据通信时,两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。\n（2）数据链路(data link): 当需要在一条线路上传送数据时,除了必须有一条物理线路外,还必须有一些必要的通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上,就构成了数据链路。现在最常用的方法是使用网络适配器(既有硬件,也包括软件)来实现这些协议。\n（3）数据通信协议 曾叫做通信规程(procedure)，在数据链路层,规程和协议是同义语。\n（4）帧： 点对点信道的数据链路层的协议数据单元。\n基本问题\n封装成帧(framing)\n封装成帧就是在一段数据的前后分别添加首部和尾部,这样就构成了一个帧。 帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。 首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外,首部和尾部还包括许多必要的控制信息。在发送帧时,是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。 为了提高帧的传输效率,应当使帧的数据部分长度尽可能地大于首部和尾部的长度。每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元 MTU(Maximum Transfer Unit)。MTU 大小一般为 1500 字节。\n控制字符 SOH(Start Of Header) 表示帧的首部开始，控制字符 EOT(End Of Transmission)表示帧的结束。针对差错数据(只有首部开始符 SOH 而没有传输结束符 EOT)，直接丢弃，完整数据予以保留。\n透明传输\n在数据链路层透明 传送数据表示无论什么样的比特组合的数据,都能够按照原样没有差错地通过这个数据链路层。由于上面已经使用专门的控制字符（8 比特）来标识 SOH 和 EOT。所传输的数据中若是出现一样的比特编码就会出现帧定界的错误（误将数据当作界定符）。只有当输入数据无上述差错传输成功时才可称作透明传输。\n当数据部分是文本文件时，自然不会出现上述差错；但当数据部分是非 ASCⅡ 码的文本文件时(如二进制代码的计算机程序或图像等), 如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样,数据链路层就会错误地“找到帧的边界”,把部分帧收下(误认为是个完整的帧),而把剩下的那部分数据丢弃。\n解决方案： 发送端在数据中出现控制字符 SOH 或 EOT 的前面插入一个转义字符 ESC (其十六进制编码是 1B,二进制是 00011011)。接收端把数据送往网络层之前删除这个插入的转义字符。称为字节填充(byte stuffing)或字符填充(character stuffing)。如果转义字符也出现在数据当中,那么解决方法仍然是在转义字符的前面插入一个转义字符。因此,当接收端收到连续的两个转义字符时,就删除其中前面的一个。\n差错检测\n（1）比特差错： 现实的通信链路都不会是理想的，比特在传输过程中可能会产生差错:1 可能会变成 0,而 0 也可能变成 1。这就叫做比特差错。比特差错是传输差错中的一种。\n（2）产生原因： 在一段时间内,传输错误的比特占所传输比特总数的比率称为误码率 BER(Bit Error Rate)。误码率与信噪比有很大的关系。如果设法提高信噪比,就可以使误码率减小。实际的通信链路并非是理想的,它不可能使误码率下降到零。\n（3）解决方案： 为了保证数据传输的可靠性,在计算机网络传输数据时,必须采用各种差错检测措施。目前在数据链路层广泛使用了循环冗余检验 CRC(Cyclic Redundancy Check) 的检错技术。\n（4）循环冗余检验原理： 在发送端,将数据划分为组,每组 k 个比特。CRC 运算就是在 k 位比特数据的后面添加供差错检测用的 n 位冗余码,然后构成一个帧发送出去,一共发送(k+n)位。具体地，使用模 2 运算，将收到的 k+n 位数据（在其后添加 n 个 0）除以事先商定的 n+1 位除数 P，得到商 R，n 位余数 R，这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。冗余码常称为帧检验序列 FCS(Frame Check Sequence)。例如：M=101001(k=6)，除数 P=1101(n=3)。经模 2 除法运算后的结果是:商 Q=110101,余数 R=001,具体计算过程如下：\n\n在接收端把接收到的数据以帧为单位进行 CRC 检验:把收到的每一个帧都除以同样的除数 P(模 2 运算),然后检查得到的余数 R。如果在传输过程中无差错,那么经过 CRC 检验后得出的余数 R 肯定是 0。但如果出现误码,那么余数 R 仍等于零的概率是非常非常小的。总之,在接收端对收到的每一帧经过 CRC 检验后,有以下两种情况：\n\n若得出的余数 R=0,则判定这个帧没有差错,就接受(accept)；\n若余数 R≠0,则判定这个帧有差错(但无法确定究竟是哪一位或哪几位出现了差错),就丢弃。\n\n（5）传输差错： 若仅仅使用循环冗余检验 CRC 差错检测技术,则只能做到对帧的无差错接受，到的帧并没有出现比特差错,但出现了帧丢失、帧重复或帧失序，以上三种情况都属于传输差错。“无比特差错”与“无传输差错”并不是同样的概念。不要求在数据链路层提供可靠传输，即不要求在数据链路层解决帧丢失、帧重复或帧失序问题。\n点对点协议 PPP\n点对点协议 PPP(Point-to-Point protocol)则是目前使用得最广泛的数据链路层协议。PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。\n数据链路层协议, 将上层交付下来的协议数据单元封装成 PPP 帧。\n\nPPP 协议设计要求\n\n简单：CRC 检验，正确就收下，反之就丢弃。\n封装成帧：准确定位开始和结束。\n透明性：转义字符保证透明传输。\n多种网络层协议：支持多种网络层协议（如 IP 和 IPX）。\n多种链路类型：串行的(一次只发送一个比特)或并行的(一次并行地发送多个比特),同步的或异步的,低速的或高速的,电的或光的,交换的(动态的)或非交换的(静态的)点对点链路。\n差错检测\n检测连接状态：自动检测出链路是否处于正常工作状态。当出现故障的链路隔了一段时间后又重新恢复正常工作时, 就特别需要有这种及时检测功能。\n最大传送单元：PPP 协议必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值，以促进各种实现之间的互操作性。\n网络层地址协商：如果仅仅在链路层建立了连接而不知道对方网络层地址,则还不能够保证网络层可以传送分组。\n数据压缩协商：PPP 协议必须提供一种方法来协商使用数据压缩算法。但并不要求将数据压缩算法进行标准化。\n\n在 TCP/P 协议族中,可靠传输由运输层的 TCP 协议负责,因此数据链路层的 PPP 协议不需要进行纠错,不需要设置序号,也不需要进行流量控制。PPP 协议不支持多点线路(即一个主机轮流和链路上的多个从主机进行通信),而只支持点对点的链路通信。此外,PPP 协议只支持全双工链路。\nPPP 协议的组成\n\n一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路(无奇偶检验的 8 比特数据),也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。\n一个用来建立、配置和测试数据链路连接的链路控制协议 LCP(Link Control Protocol)。\n一套网络控制协议 NCP(Network Control Protocol),其中的每一个协议支持不同的网络层协议,如 IP、OSI 的网络层、 DECnet,以及 AppleTalk 等。\n\nPPP 协议的帧格式\n（1）PPP 帧的首部和尾部分别为四个字段和两个字段。\n\n\n首部第一尾部第二：标志字段 F(Flag),规定为 0x7E(符号“0x”表示它后面的字符是用十六进制表示的,十六进制的 7E 的二进制表示是 01111110), 标志字段就是 PPP 帧的定界符。如果出现连续两个标志字段,就表示这是一个空帧,应当丢弃。\n首部第二 Address：控制字段 A 规定为 0xFF(即 11111111)。\n首部第三 Control：控制字段 C 规定为 0x03(即 00000011)，这两个字段实际上并没有携带 PPP 帧的信息。\n首部第四 Protocol：PPP 首部的第四个字段是 2 字节的协议字段。\n\n当协议字段为 0x0021 时,PPP 帧的信息字段就是 IP 数据报。\n若为 0xC021,则信息字段是 PPP 链路控制协议 LCP 的数据\n而 0x8021 表示这是网络层的控制数据。\n\n\n尾部第一：CRC 的帧检验序列 FCS（冗余码）。\n信息字段：长度可变,不超过 1500 字节。\n\n（2）字节填充：当信息字段中出现和标志字段一样的比特(0x7E)，并且使用异步传输时，转义符定义为 0x7D,就必须采取措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。\n字节填充方法如下：\n\n把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D,0x5E)。\n若信息字段中出现一个 0x7D 的字节(转义字符),则把 0x7D 转变成为 2 字节序列(0x7D,0x5D)。\n若信息字段中出现 ASCII 码的控制字符(即数值小于 0x20 的字符),则在该字符前面要加入一个 0x7D 字节,同时将该字符的编码加以改变。例如,出现 0x03 就要把它转变为 2 字节序列(0x7D,0x23)。\n接收端在收到数据后再进行与发送端字节填充相反的变换,就可以正确地恢复出原来的信息。\n\n（3）零比特填充：PPP 协议用在 SONET/SDH 链路时,使用同步传输，在这种情况下,PPP 协议采用零比特填充方法来实现透明传输。\n零比特填充的具体做法是：\n\n在发送端,先扫描整个信息字段(通常用硬件实现,但也可用软件实现,只是会慢些)。只要发现有 5 个连续 1,则立即填入一个 0。因此经过这种零比特填充后的数据,就可以保证在信息字段中不会出现 6 个连续 1。\n接收端在收到一个帧时,先找到标志字段 F 以确定一个帧的边界,接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时,就把这 5 个连续 1 后的一个 0 删除,以还原成原来的信息比特流，如下图。\n\n\nPPP 协议的工作状态\nPPP 链路初始化：\n\n\n当用户拨号接入 ISP 后,就建立了一条从用户个人电脑到 ISP 的物理连接；\n\n\n这时,用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组(封装成多个 PPP 帧),以便建立 LCP 连接；\n\n\n这些分组及其响应选择了将要使用的一些 PPP 参数。\n\n\n接着还要进行网络层配置,网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的 IP 地址。\n\n\n当用户通信完毕时,NCP 释放网络层连接,收回原来分配出去的 IP 地址\n\n\n接着,LCP 释放数据链路层连接。最后释放的是物理层的连接。\n\n\n\n以下从中间分支箭头上的操作分步骤介绍具体初始化过程：\n\n起初：PPP 链路的起始和终止状态永远是“链路静止”(Link Dead)状态,这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。\n物理层连接建立：当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后 PPP 就进入“链路建立”(Link establish)状态,其目的是建立链路层的 LCP 连接。\nLCP 配置协商：物理链路建立之后，开始进行 LCP 配置协商,即发送 LCP 的配置请求帧(Configure-Request)，这是一个 PPP 帧,其协议字段置为 LCP 对应的代码,而信息字段包含链路上的最大帧长、所使用的鉴别协议,以及不使用 PPP 帧中的地址和控制字段(因为这两个字段的值是固定的,没有任何信息量,可以在 PPP 帧的首部中省略这两个字节)。链路的另一端可以发送以下几种响应中的一种。若配置失败，则转到链路静止状态，否则进入“鉴别”( Authenticate)状态。\n\n配置确认帧(Configure-Ack)：所有选项都接受。\n配置否认帧(Configure-Nak)：所有选项都理解但不能接受。\n配置拒绝帧(Configure-Reject)：选项有的无法识别或不能接受,需要协商。\n\n\n鉴别：鉴别( Authenticate)状态只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口 令鉴别协议 PAP(Password Authentication Protocol),则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。还可以使用更加复杂安全的口令握手鉴别协议 CHAP(Challenge-Handshake Authentication Protocol)。若鉴别身份失败,则转到“链路终止”(Link Terminate)状态。若鉴别成功,则进入“网络层协议”(Network- Layer Protocol)状态。\nNCP 配置协商：在“网络层协议”状态,PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。PPP 协议两端的网络层可以运行不同的网络层协议,但仍然可使用同一个 PPP 协议进行通信。如果在 PPP 链路上运行的是 IP 协议,则对 PPP 链路的每一端配置 IP 协议模块(如分配 IP 地址)时就要使用 NCP 中支持 IP 的协议——IP 控制协议 ICP(IP Control Protocol)。当网络层配置完毕后,链路就进入可进行数据通信的“链路打开”(Link Open)状态。\n互发分组。在链路打开状态下，链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送回送请求 LCP 分组(Echo-Request)和回送回答 LCP 分组(Echo-Reply),以检查链路的状态。\n终止请求：数据传输结束后,可以由链路的一端发出终止请求 LCP 分组(Terminate-Request)请求终止链路连接,在收到对方发来的终止确认 LCP 分组(Terminate-Ack)后,转到“链路终止”状态。如果链路出现故障,也会从“链路打开”状态转到“链路终止”状态。当调制解调器的载波停止后,则回到“链路静止”状态。\n\n使用广播信道的数据链路层\n广播信道可以进行一对多的通信。局域网使用的就是广播信道。\n局域网的数据链路层\n（1）局域网简介：局域网最主要的特点是:网络为一个单位所拥有,且地理范围和站点数目均有限。局域网可按网络拓扑进行分类：星形网，环形网和总线网。由于集线器(hub)的出现和双绞线大量用于局域网中,星形以太网以及多级星形结构的以太网获得了非常广泛的应用。双绞线已成为局域网中的主流传输媒体。当数据率很高时,往往需要使用光纤作为传输媒体。\n\n（2）共享信道：在局域网要着重考虑的一个问题是共享信道，这在技术上有两种方法:\n\n静态划分信道：如之前介绍过的频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高,不适合于局域网使用。\n动态媒体接入控制：又称为多点接入(multiple access),其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：\n\n随机接入：所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息,那么在共享媒体上就要产生碰撞,使得这些用户的发送都失败。因此,必须有解决碰撞的网络协议。这也是本章介绍的重点。\n受控接入：用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询(polling),或称为轮询。受控接入在局域网中使用得较少。\n\n\n\n（3）MAC 协议：为了使数据链路层能更好地适应多种局域网标准,IEEE802 委员会就把局域网的数据链路层拆成两个子层,即逻辑链路控制 LLC(Logical Link Control)子层和媒体接入控制 MAC(Medium Access Control)子层。而 TCP/IP 体系经常使用的局域网仅装有 MAC 协议而没有 LLC 协议。\n（4）适配器：计算机与外界局域网的连接是通过通信适配器(adapter，或称网卡) 进行的。在这种通信适配器上面装有处理器和存储器(包括 RAM 和 ROM)。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的而适配器和计算机之间的通信则是通过计算机主板上的 LO 总线以并行传输方式进行的。因此,适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同,因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时,还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。适配器还要能够实现以太网协议。适配器在接收和发送各种帧时,不使用计算机的 CPU。这时计算机中的 CPU 可以处理其他任务。当适配器收到有差错的帧时,就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时,它就使用中断来通知该计算机,并交付协议栈中的网络层。当计算机要发送 IP 数据报时,就由协议栈把 IP 数据报向下交给适配器,组装成帧后发送到局域网。计算机的硬件地址就在适配器的 ROM 中,而计算机的软件地址—P 地址在计算机的存储器中。\n\nCSMA/CD 协议\n（1）总线型一对一通信：最早的以太网是总线型的，当一台计算机发送数据时,总线上的所有计算机都能检测到这个数据，属于广播通信。为了在总线上实现一对一的通信,可以使每一台计算机的适配器拥有一个与其他适配器都不同的地址。在发送数据帧时,在帧的首部写明接收站的地址，仅当数据帧中的目的地址与适配器 ROM 中存放的硬件地址一致时,该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧就丢弃。\n（2）以太网通信措施：\n\n第一,采用较为灵活的无连接的工作方式：不必先建立连接就可以直接发送数据适配器对发送的数据帧不进行编号,也不要求对方发回确认。因此,以太网提供的服务是尽最大努力的交付,即不可靠的交付。当目的站收到有差错的数据帧时,就把帧丢弃。对有差错帧是否需要重传则由高层（TCP 协议，若 TCP 发现丢失了数据，就把这些数据重新传递给以太网进行重传，但以太网并不知道这是重传帧）来决定。在同一时间只能允许一台计算机发送数据,否则各计算机之间就会互相干扰,使得所发送数据被破坏。以太网采用最简单的随机接入,并使用 CSMA/CD（载波监听多点接入/碰撞检测，Carrier Sense Multiple Access with Collision Detection）协议以减少冲突发生的概率。\n第二,以太网发送的数据都使用曼彻斯特(Manchester)编码，每一个码元的正中间出现一次电压的转换,而接收端就利用这种电压的转换很方便地把位同步信号提取出来。曼彻斯特编码的缺点是它所占的频带宽度比原始的基带信号增加了一倍(因为每秒传送的码元数加倍了)。\n\n（3）CSMA/CD 载波监听多点接入/碰撞检测协议：\n\n“多点接入”就是说明这是总线型网络,许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。\n“载波监听”就是用电子技术检测总线上有没有其他计算机也在发送，就是检测信道,不管在发送前,还是在发送中,每个主机都必须不停地检测信道。在发送前检测信道,是为了获得发送权。在发送中检测信道,是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。\n“碰撞检测”也就是“边发送边监听”,即适配器边发送数据边检测信道上的信号电压的变化情况,以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时,总线上的信号电压变化幅度将会增大(互相叠加)。当适配器检测到的信号电压变化幅度超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞。一旦发现总线上出现了碰撞,其适配器就要立即停止发送,然后等待一段随机时间后再次发送。\n\n（4）碰撞起因\n\n既然每一个站在发送数据之前已经监听到信道为“空闲”,那么为什么还会出现数据在总线上的碰撞呢?\n这是因为电磁波在总线上总是以有限的速率传播的，若是在这个传播时延内有多台主机检测到空闲，并发送数据，则发生冲突。\n\n（5）碰撞分析\n\n把总线上的单程端到端传播时延记为 τ，最迟经过 2τ 的时间发送端能检测到碰撞，即总线的端到端往返传播时延。\n显然,在使用 CSMA/CD 协议时,一个主机不可能同时进行发送和接收(但必须边发送边监听信道)。因此使用 CSMA/CD 协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。\n每一个站在自己发送数据之后的一小段时间内,存在着遭遇碰撞的可能性。这一小段时间是不确定的,它取决于另一个发送数据的站到本站的距离。以太网的这一特点称为发送的不确定性。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。\n以太网的端到端往返时间 2τ 称为争用期(contention period),又称为碰撞窗口(collision window)。这是因为一个站在发送完数据后,经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞。\n\n（6）碰撞解决方案\n以太网使用截断二进制指数退避(truncated binary exponential backoff)算法来确定碰撞后重传的时机。这种算法让发生碰撞的站在停止发送数据后,推迟(这叫做退避)一个随机的时间再次发送。因为如果几个发生碰撞的站都在监听信道,那么都会同时发现信道变成了空闲。如果大家都同时再重新发送,那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小,具体的退避算法如下:\n\n协议规定了基本退避时间为争用期 2τ,争用期时间具体是 51.2us。对于 10 Mbit/s 以太网,在争用期内可发送 512bit,即 64 字节。也可以说争用期是 512 比特时间。\n从离散的整数集合中随机取出一个数,记为 r。重传应推后的时间就是 r 倍的争用期。参数,当重传次数不超过 10 时,参数 k 等于重传次数;但当重传次数超过 10 时,k 就不再增大而一直等于 10。\n当重传达 16 次仍不能成功时(这表明同时打算发送数据的站太多,以致连续发生突),则丢弃该帧,并向高层报告。\n\n（7）指数退避算法分析\n\n适配器每发送一个新的帧,就要执行一次 CSMA/CD 算法。适配器对过去发生过的碰撞并无记忆功能。因此,当好几个适配器正在执行指数退避算法时,很可能有某一个适配器发送的新帧能够碰巧立即成功地插入到信道中,得到了发送权,而已经推迟好几次发送的站,有可能很不巧,还要继续执行退避算法,继续等待。\n若发送数据小于争用期 512bit，发送端边发送边侦听，如果发生冲突并用了 51.2us 冲突回传回来时，早就发完了，那发送站认为这个碰撞不是自己的帧，因而不会重传这个帧。为了避免发生这种情况,以太网规定了一个最短帧长 64 字节,即 512bit。如果要发送的数据非常少,那么必须加入一些填充字节,使帧长不小于 64 字节。对于 10Mbit/s 以太网,发送 512bit 的时间需要 51.2us,也就是上面提到的争用期。\n由此可见,以太网在发送数据时,如果在争用期(共发送了 64 字节)没有发生碰撞那么后续发送的数据就一定不会发生冲突。换句话说,如果发生碰撞,就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送,这时已经发送出去的数据一定小于 64 字节,因此凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。只要收到了这种无效帧,就应当立即将其丢弃。\n\n（8）强化碰撞\n当发送数据的站一旦发现发生了碰撞时,除了立即停止发送数据外,还要再继续发送 32 比特或 48 比特的人为干扰信号 (jamming signal),以便让所有用户都知道现在已经发生了碰撞。\n以太网还规定了帧间最小间隔为 96μs,相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理,做好接收下一帧的准备。\n集线器与星型拓扑\n集线器的一些特点如下：\n\n从表面上看,使用集线器的局域网在物理上是一个星形网,但使用集线器的以太网在逻辑上仍是一个总线网,各主机共享逻辑上的总线,各主机中的适配器执行 CSMA/CD 协议)，，在同一时刻至多只允许一个主机发送数据。\n集线器工作在物理层,它的每个接口仅仅简单地转发比特——收到 1 就转发 1,收到 0 就转发 0,不进行碰撞检测。若两个接口同时有信号输入(即发生碰撞),那么所有的接口都将收不到正确的帧。\n集线器采用了专门的芯片,进行自适应串音回波抵消。这样就可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰(这种干扰即近端串音)。每个比特在转发之前还要进行再生整形并重新定时。\n集线器一般都有少量的容错能力和网络管理功能。例如,假定在以太网中有一个适配器出了故障,不停地发送以太网帧。这时,集线器可以检测到这个问题,在内部断开与出故障的适配器的连线,使整个以太网仍然能够正常工作。\n\n以太网的信道利用率\n假定一个 10 Mbit/s 以太网同时有 10 个站在工作,那么每一个站所能发送数据的平均速率似乎应当是总数据率的 1/10(即 1Mbit/s)。但由于碰撞的存在，信道资源会造成浪费。因此,以太网总的信道利用率并不能达到 100%。\n下图的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过若干个争用期后,发送成功了。假定发送帧需要的时间是。它等于帧长(bit 除以发送速率(10 Mbit/s)。成功发送一个帧需要占用信道的时间是,也就是发送时延+传播时延。\n\n**\n要提高以太网的信道利用率,就必须减小与之比。在以太网中定义了参数,当 a→0 时,只要一发生碰撞,就立即可以检测出来,并立即停止发送,因而信道资源被浪费的时间非常非常少。以太网的参数 a 的值应当尽可能小些,这就要求分子数值要小些,而分母的数值要大些。\n现在考虑一种理想化的情况，假定以太网上的各站发送数据都不会产生碰撞,即总线一旦空闲就有某一个站立即发送数据,于是我们可计算出极限信道利用率 ,指出了只有当参数  远小于 1 才能得到尽可能高的极限信道利用率。\n以太网的 MAC 层\n（1）在局域网中,硬件地址又称为物理地址或 MAC 地址(因为这种地址用在 MAC 帧中)，是指局域网上的每台计算机中固化在适配器的 ROM 中的 48 位（6 字节）的地址。IEEE 的注册管理机构 RA(Registration Authority) 负责分配地址字段的 6 个字节中的前三个字节(即高位 24 位)给生产局域网适配器的厂家,称为组织唯一标识符 OUI(Organizationally Unique Identifier)。地址字段中的后三个字节(即低位 24 位)则由厂家自行指派称为扩展标识符(extended identifier),只要保证生产出的适配器没有重复地址即可。一个公司可能有几个 OUI,也可能有几个小公司合起来购买一个 OUI。\n（2）MAC 帧格式\n常用的以太网 MAC 帧格式有两种标准,一种是 DIX Ethernet V2 标准(即以太网 V2 标准),准),另一种是 IEEE 的 802.3 标准。这里只介绍使用得最多的以太网 V2 的 MAC 帧格式。以太网 V2 的 MAC 帧由五个字段组成：目的地址（6 字节），源地址（6 字节），类型字段（2 字节，标志上一层使用的是什么协议，0x0800 表示上层使用的是 IP 数据报，0x8137 表示该帧是由 Novell IPX 发过来的），数据字段（46 到 1500 字节，46 字节=最小长度 64 字节-18 字节的收尾），帧检验序列 FCS（4 字节，使用 CRC 检验）。\n\n（3）数据长度判断\n以上 MAC 帧格式并没有帧长度(或数据长度)字段，接收方依据曼彻斯特编码的特性（每个码元中间有一次电压转换）确定数据字段的长度。但是当数据字段的长度小于 46 字节时,MAC 子层就会在数据字段的后面加入填充字段,但 MAC 帧的首部并没有指出数据字段的长度是多少，上层协议如何知道填充字段的长度呢? 当上层使用 IP 协议时,其首部就有一个“总长度”字段。因此,“总长度”加上填充字段的长度,应当等于 MAC 帧数据字段的长度。例如,当 IP 数据报的总长度为 42 字节时,填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后,IP 层就把其中最后 4 字节的填充字段丢弃。\n（4）位同步\n为了接收端迅速实现位同步,从 MAC 子层向下传到物理层时还要在帧的前面插入 8 字节(由硬件生成),它由两个字段构成。第一个字段是7 个字节的前同步码,它的作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率,使它和发送端的时钟同步。第二个字段是帧开始定界符,定义为 10101011，它的前六位的作用和前同步码一样,最后的两个连续的 1 就是告诉接收端适配器:“MAC 帧的信息马上就要来了,请适配器注意接收”。\n（5）无效的 MAC 帧\n\n帧的长度不是整数个字节；\n用收到的帧检验序列 FCS 查出有差错\n收到的帧的 MAC 客户数据字段的长度不在 46~1500 字节之间。\n\n扩展的以太网\n在物理层扩展以太网\n以太网上的主机之间的距离不能太远,否则主机发送的信号经过铜线的传输就会衰减到使 CSMA/CD 协议无法正常工作。现在,扩展主机和集线器之间的距离的一种简单方法就是使用光纤和一对光纤调制解调器。光纤调制解调器的作用就是进行电信号和光信号的转换。如果使用多个集线器,就可以连接成覆盖更大范围的多级星形结构的以太网。\n\n优点：跨独立以太网通信，扩大了以太网覆盖的地理范围。\n缺点：三个独立以太网的通过集线器互连起来后就把三个碰撞域变成一个碰撞域，且这时的最大吞吐量仍然是单个以太网的吞吐量。如果不同的独立以太网使用不同的以太网技术(如数据率不同),那么就不可能用集线器将们互连起来。如上图中,一个系使用 10Mbit/s 的适配器,而另外两个系使用 100Mbit/s 的适配器,那么用集线器连接起来后,大家都只能工作在 10 Mbit/s 的速率。\n数据链路层扩展以太网\n（1）扩展以太网更常用的方法是在数据链路层进行。最初使用的是网桥(bridge)。网桥对收到的帧根据其 MAC 帧的目的地址进行转发和过滤。当网桥收到一个帧时,并不是向所有的接口转发此帧,而是根据此帧的目的 MAC 地址,查找网桥中的地址表,然后确定将该帧转发到哪一个接口,或者是把它丢弃(即过滤)。**交换式集线器(switching hub，或称为以太网交换机(switch)或第二层交换机(L2 switch))**的出现很快就淘汰了网桥。\n以太网交换机的特点：\n\n太网交换机实质上就是一个多接口的网桥**,通常都有十几个或更多的接口,**以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连,并且一般都工作在全双工方式。\n以太网交换机还具有并行性,即能同时连通多对接口,使多对主机能同时通信(而网桥只能一次分析和转发一个帧)。相互通信的主机都是独占传输媒体,无碰撞地传输数据。\n以太网交换机的接口还有存储器,能在输出端口繁忙时把到来的帧进行缓存。\n以太网交换机是一种即插即用设备,其内部的帧交换表(又称为地址表)是通过自学习算法自动地逐渐建立起来的。\n对于传统的 10 Mbit/s 的共享式以太网,若共有 10 个用户,则每个用户占有的平均带宽只有 1Mbis。若使用以太网交换机来连接这些主机,虽然在每个接口到主机的带宽还是 10Mbit/s,但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽,因此对于拥有 10 个接口的交换机的总容量则为 100 Mbit/s。这正是交换机的最大优点。\n以太网交换机一般都具有多种速率的接口,例如,可以具有 10 Mbit/s、100Mbit/s 和 1Gbit/s 的接口的各种组合,这就大大方便了各种不同情况的用户。 虽然许多以太网交换机对收到的帧采用存储转发方式进行转发,但也有一些交换机采 用直通 ( cut-through)的交换方式。直通交换不必把整个数据帧先缓存后再进行处理,而是在 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口,因而提高了帧的 转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵,交换时延就非常小。\n\n（2）以太网交换机的自学习功能\n\n当交换机不知道哪个接口对应哪个 MAC 主机时，就采用广播的方式，然后将过滤后的 MAC 地址和接口号对应填入交换表；\n当交换表已知某个帧的目的 MAC 地址对应接口时，不必要广播，直接转发。\n考虑到有时可能要在交换机的接口更换主机,这就需要更改交换表中的项目。为此,在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。\n\n（3）从总线以太网到星形以太网\n总线以太网使用 CSMA/CD 协议,以半双工方式工作。但以太网交换机不使用共享总线,没有碰撞问题,因此不使用 CSMA/CD 协议,而是以全双工方式工作。既然连以太网的重要协议 CSMA/CD 都不使用了,为什么还叫做以太网呢?原因就是它的帧结构未改变,仍然采用以太网的帧结构。\n虚拟局域网\n（1）概念：虚拟局域网 VLAN(Virtual LAN)是由一些局域网网段构成的与物理位置无关的逻辑组。每一个 VLAN 的帧都有一个明确的标识符,指明发送这个帧的计算机属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务,而并不是一种新型局域网。\n\n（2）实例\nLAN1:(A1,A2,B1,C1),LAN2:(A3,B2,C2),LAN3:(A4,B3,C3)这 10 个用户划分为三个物理工作组,同时被划分为三个逻辑虚拟局域网 VLANVLAN1:(Al, A2, A3, A4), VLAN2: (Bl, B2, B3): VLAN3: (Cl, C2, C3)\n（3）工作原理\n虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记(tag),用来指明发送该帧的计算机属于哪一个虚拟局域网。插入 VLAN 标记得出的帧称为802.1Q 帧。\n\nVLAN 标记字段的长度是 4 字节,插入在以太网 MAC 帧的源地址字段和类型字段之间。VLAN 标记的前两个字节总是设置为 0x8100(图中显示的是二进制),称为IEEE802.1Q 标记类型。在后面的两个字节中,前 3 位是用户优先级字段,接着的一位是规范格式指示符 CFI(Canonical FormatIndicator),最后的 12 位是该虚拟局域网 VLAN 标识符 VID (VLAN ID),它唯一地标志了这个以太网帧属于哪一个 VLAN。由于用于 VLAN 的以太网帧的首部增加了 4 个字节,因此以太网的最大帧长从原来的 1518 字节(1500 字节的数据加上 18 字节的首部)变为 1522 字节。\n物理层\n物理层的主要任务\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流,而不是指具体的传输媒体。 可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性,即:\n\n机械特性 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置,等。平时常见的各种规格的接插件都有严格的标准化的规定。\n电气特性 指明在接口电缆的各条线上出现的电压的范围。\n功能特性 指明某条线上出现的某一电平的电压的意义（如判断是高电平还是低电平）。\n过程特性 指明对于不同功能的各种可能事件的出现顺序。\n\n数字信号与模拟信号\n它的作用是：屏蔽不同的传输媒体和通信手段的差异。我们都知道，自然界的信号无非就是两种，一种是数字信号，另一种就是模拟信号。那么是什么模拟信号？什么又是数字信号呢？\n说白了，所谓的模拟信号就是连续变化的物理量，模拟信号其特点是幅度连续(连续的含义是在某一取值范围内可以取无限多个数值)。模拟信号，其信号波形在时间上也是连续的，因此它又是连续信号。我们对连续信号进行抽样，就会得到抽样信号，但抽象信号就是离散的（说着说着就说到了信号系统，看来补考对我的影响还是有的）。但数字信号是不同于模拟信号的，他在时间域上是离散的，它有两种不同状态的物理量，分别用“0”，“1”来表示。这就好像电灯开关一样，也有两种不同的状态。\n当然，数字信号与模拟信号是可以相互转换的，模拟信号通常使用 PCM（脉冲编码调制）方法量化并转换为数字信号，PCM 方法是使不同范围的模拟信号对应不同的二进制值。通常，数字信号通过载波相移得到模拟信号。\n信道\n按照传输媒介可以分为三类：\n\n有线信道：有线信道以导线为传输媒质，信号沿导线进行传输，信号的能量集中在导线附近，因此传输效率高，但是部署不够灵活。这一类信道使用的传输媒质包括用电线传输电信号的架空明线、电话线、双绞线、对称电缆和同轴电缆等等，还有传输经过调制的光脉冲信号的光导纤维。\n无线信道：无线信道主要有以辐射无线电波为传输方式的无线电信道和在水下传播声波的水声信道等。无线电信号由发射机的天线辐射到整个自由空间上进行传播。不同频段的无线电波有不同的传播方式。\n存储信道：在某种意义上，磁带、光盘、磁盘等数据存储媒质也可以被看作是一种通信信道。将数据写入存储媒质的过程即等效于发射机将信号传输到信道的过程，将数据从存储媒质读出的过程即等效于接收机从信道接收信号的过程。\n\n信道是传输信息的信道，信道容量描述了信道无差错地传输信息的最大能力，可以用来衡量信道的好坏。\n关于信道，还有一个重要的参数，那就是信噪比，信噪比越大，信道的容量也越大，这里的话给出著名的香农公式：\n\n其中，C 为信道容量，B 为带宽，S/N 为信噪比。\n物理层的传输媒介\n我们大家都知道，数据在物理层传输的媒介是不一样的，工作在物理层的是集线器。不过，大致可以为一下两类：\n\n\n引导型传输媒介：引导型传输媒体中又有不同的类别，比如同轴电缆、光缆、双绞线，其中双绞线根据是否屏蔽又可以继续细分。\n\n\n非引导型传输媒介：非引导型传输媒介指的是无线电波在空间中的传播，利用不同的频段可以传输不同的信号。\n\n\n通信的双方信息交互的方式\n从通信的双方信息交互的方式来看,可以有以下三种基本方式：\n\n单向通信又称为单工通信,即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电广播以及电视广播就属于这种类型。\n双向交替通信又称为半双工通信,即通信的双方都可以发送信息,但不能双方同时发送(当然也就不能同时接收)。\n双向同时通信又称为全双工通信,即通信的双方可以同时发送和接收信息\n\n单向通信只需要一条信道,而双向交替通信或双向同时通信则都需要两条信道(每个方向各一条)。显然,双向同时通信的传输效率最高。\n信道复用技术\n在进行通信时,复用器( multiplexer)总是和分用器( demultiplexer)成对地使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用正好和复用器相反,它把高速信道传送过来的数据进行分用,分别送交到相应的用户。\n\n\n频分多路复用 FDM: 每个用户占用不同的宽带频率, 单位 Hz. 用户得到一定的频率之后通信过程中始终占用该频率.\n时分多路复用 TDM: 将时间段划分为等长的时分复用帧, 每个用户占用固定序号的时隙. 各用户占用的时隙是周期性出现的.\n波分多路复用 WDM: 将不同的波长分配给不同的用户, 在光通信系统中常见.\n码分复用 CDM: 多用于无线通信网络, 为每个用户分配一个 m 比特的唯一码片序列. 用户使用相同频率的载波, 利用各自的码片序列编码数据. 编码信号=原始数据*码片序列. 对于一个用户, 他想要发送它的数据, 那么假如该数据是 0 , 则发送自己的 m 比特的码片序列. 如果数据是 1, 就发送 m 比特码片序列的补码.并且要求个用户的码片序列相互正交.\n\n常见的宽带接入技术\n\n\nADSL 技术\n\n\n光纤同轴混合网（HFC 网）\n\n\nFTTx 技术\n\n\n从宽带接入的媒体来看，可以划分为两大类：\n\n\n有线宽带接入\n\n\n无线宽带接入\n\n\n参考资料\n书籍参考\n计算机网络: 自顶向下方法 -原书第七版\n计算机网络-谢希仁\n王道考研-计算机网络\n视频参考\n计算机网络 哈工大\n计算机网络 湖南科技大学\n文章参考\n三天两夜肝完这篇万字长文，终于拿下了 TCP/IP\n计算机网络:自顶向下方法 Github 仓库\n计算机网络发展的四个阶段\n计算机网络的发展历史\n计算机网络起源 网络发展简介（一）\n计算机网络基础知识总结\n计算机网络速率，带宽，吞吐量概念\n动画：什么是计算机网络时延\n计算机网络分类-百度百科\n计算机网络交换技术-百度百科\n计算机网络-交换技术\n计算机网络（一）\n2019-02-21 网络层次划分\n1-为什么要学习网络协议？\n2-网络分层的真实含义是什么？\n计算机网络太难？了解这一篇就够了\n深入理解计算机网络（二）：应用层\n计算机网络之应用层详述\n计算机网络通信 TCP/IP 协议浅析 网络发展简介（二）\n计算机网络自顶向下方法第 2 章-应用层(application-layer)\n计算机网络\n计算机网络之应用层详述\n深入理解计算机网络（二）：应用层\n计算机网络（二） 物理层\n计算机网络（三） 数据链路层\n计算机网络-3y\n完全理解 ICMP 协议\n计算机网络传输层知识点全覆盖\n计算机网络之路由器\nIP 数据报分片——Fragmentation 和重组\n推荐文章计算机网络学习总结[转载][1]使用 Java 实现简单的 WebServer","plink":"https://mvbbb.github.io/rptlxk/"},{"title":"后端简介","date":"2021-01-03T10:17:43.000Z","date_formatted":{"ll":"Jan 3, 2021","L":"01/03/2021","MM-DD":"01-03"},"updated":"2021-02-03T04:20:58.369Z","content":"这篇文章是写给团队大一同学的，主要简单的介绍一下后端方向。\n准备时间挺仓促的， 不能面面俱到。之后再改改。\n\n什么是前端、后端\n\n这里就只是简单对比一下这两者，忽略安卓开发，游戏开发…\n我们说的后端主要是指 Java 后端\n\n前端\n前端开发主要涉及网站和 App，用户能够从 App 屏幕或浏览器上看到东西。简单地说，能够从 App 屏幕和浏览器上看到的东西都属于前端。\n移动 APP 和网站的前端\n移动 App 的前端和网站是一样的。例如，你所看到的内容、按钮、图片，它们都属于前端。另外，因为移动设备的屏幕是可以触摸的，所以应用程序对各种触控手势（比如放大 / 缩小、双击、滑动等）做出的响应也属于前端，它们是前端的活动部分。\n\n摘自 InfoQ\n\n以这个站点的首页为例，前端决定了它长什么样\n\n后端\n后端开发即“服务器端”开发，主要涉及软件系统“后端”的东西。比如，用于托管网站和 App 数据的服务器、放置在后端服务器与浏览器及 App 之间的中间件，它们都属于后端。简单地说，那些你在屏幕上看不到但又被用来为前端提供支持的东西就是后端。\n网站和移动 APP 的后端\n网站的后端涉及搭建服务器、保存和获取数据，以及用于连接前端的接口。如果说前端开发者关心的是网站外观，那么后端开发者关心的是如何通过代码、API 和数据库集成来提升网站的速度、性能和响应性。\n后端开发使用 Ruby、Apache、Nginx、PHP、MySQL、MongoDB 等技术。\n\n摘自 InfoQ\n\nJava 后端前景怎样\nJava 薪资在所有程序员岗位中相对较高，很多人跨行去做 zhi 程序员，这应该是一个主要原因。Java 人才的需求量很大，就业岗位很多，对求职者技术要求、学历背景要求也越来越高，想拿到一个大厂的 offer,竞争相对更大。\nJava 技术也在不断进步，Java 应用会越来越广泛，人才需求当然也不会止步于当前，所以不论现在还是未来，整体市场都不会饱和，只会低端饱和，高端缺人。\nJava 相较于其他语言来说，是一个庞大的知识体系，它的覆盖范围非常广，在很多新兴领域如人工智能、大数据、云计算等 Java 也是必备语言。而且在相关流行开发语言的调查报告上已经连续 10 几年位居榜首。所以 Java 语言本身来说，市场发展前景是非常稳定的。\n前段时间，Coding Dojo 发布了一份的有关程序员工作机会最多的编程语言数据。根据数据显示，Java 是 2020 年最受欢迎的语言之一。另外之前流出的一份互联网校招高薪清单年薪 30 万招聘应届生的企业不在少数。\n\n摘自 https://zhidao.baidu.com/question/550939236.html\n\n后端工程师工作需要干什么\n\n摘自 https://yanzhi.lagou.com/question/2020.html\n\n看需求文档\n和产品交流\n和其他开发交流（可能没有）\n插上耳机\n开始编码\n单元测试\n提交代码\n提交测试\n和测试交流\n查看日志\n改 bug\n撕逼\n背锅\n调戏妹纸\n被妹纸调戏\n写邮件\n回复邮件\n打望\n抠脚\n升降椅子\n玩手机\n揉一下脖子\n锤一下腰\n打望\n查工资余额\n看楼盘\n看车\n然后哭\n发誓努力工作\n改 bug\n看需求\n上拉勾\n投简历\n面试跳槽。。。\n入职\n看需求。。。\n看， 多有趣！\n后端需要学哪部分的内容\n这部分内容我更推荐看你们看别人写得， 因为我也还不太懂 😂。\n详见最后的参考资料。\n我对后端感兴趣，我该怎么开始\n后端主要是指 Java 开发，后端的学习也主要是围绕着 Java 展开。\n现在你们大一， 马上寒假， 我推荐你们在寒假中先学习 Java Se 。\n\nJavaSe 简单的理解就是指 Java 的基础内容。\n\n我从来不建议学习编程的时候抱着一本书看。我更推荐你们通过视频学习。\n Java 基础到高级-宋红康-零基础自学 Java-尚硅谷\n当然，看视频的时候你也需要思考，别看着看着就睡着了。能动手跟着视频里面敲代码是最好的。\n关于编译器， 一个好用的编译器可以使你的学习事半功倍。我推荐使用 IntelliJ IDEA。\n\n下载地址 https://www.jetbrains.com/idea/download/#section=windows\n\n\nJavaSe 已经够你们喝一壶了，等你们学完这部分之后我再补充接下来的学习方向。\n我的几点建议：\n1） 学会使用搜索引擎： Google， Stackoverflow，百度…\n2） 学会找资源： csdn， 掘金， GitHub， 知乎…\n3） 学会做笔记，每学到一个语法知识，都把它记下来。\n4） 学习的时候别陷入到细节知识中，还是那句话，** 会用就行**\n参考资料\n这下面的东西才是这篇文章的精华，对后端感兴趣的最好都看完\n知乎-计算机是学前端开发好还是后端开发好？\n知乎-后端都需要学什么\n知乎-后端的发展前景如何\nInfoQ-一位高级软件工程师的自述：这个职位到底要做什么工作？\nZindex’s blog-后端工作方向介绍\n掘金-[译] 前端 vs 后端：哪一个适合你？\nBackend Vs Frontend Development: Your Step By Step Guide For 2020\n后端工程师需要会什么？2020 年最新 Web 后端程序员技能介绍（上期\n掘金-现代后端开发者必备技能-2018 版\n码库 CTOLib.COM-后端开发技能速览\nInfoQ-一文看懂前端和后端开发\n知乎-后端的发展前景如何？\n博客园-java 后端学习路线\n3y-周末再聊聊 Java 学习路线\ncodingdojo-Top 7 Programming Languages Of 2020\n","plink":"https://mvbbb.github.io/lqm4qt/"},{"title":"计算机网络学习总结[转载][1]","date":"2021-01-02T03:37:56.000Z","date_formatted":{"ll":"Jan 2, 2021","L":"01/02/2021","MM-DD":"01-02"},"updated":"2021-02-03T04:20:59.129Z","content":"前言\n这篇文章是我搜集各种资料之后整合出来的，仅用作个人学习使用。如有侵权请联系我，我立马删除。\n本篇包含\n\n预备知识\n应用层\n传输层\n\n部分内容待完善\n\n数据链路层结构不够清晰\nTCP 可靠传输部分没写\n\n\n预备知识\n计算机网络发展的四个阶段\n第一阶段（60 年代初期到 60 年代中期）\n面向终端的计算机网络：主机是网络的中心和控制者，终端（键盘和显示器）分布在各处并与主机相连，用户通过本地的终端使用远程的主机。只提供终端和主机之间的通信，子网之间无法通信。\n第二阶段（60 年代中期到 70 年代中期）\n采用分组交换技术实现计算机  —  计算机之间的通信，使计算机网络的结构、概念都发生了变化，形成了通信子网和资源子网的网络结构。\n\n第二代计算机网络是计算机网络的“形成与发展”阶段\n美国的 ARPA 网就是第二代网络的代表: ARPA\n\n第三阶段（70 年代中期到 80 年代末期）\n现代计算机网络互连阶段，特征是网络体系结构的形成和网络协议的标准化。  \n      在计算机通信系统的基础之上，重视网络体系结构和协议标准化的研究，建立全网统一的通信规则，用通信协议软件来实现网络内部及网络与网络之间的通信，通过网络操作系统，对网络资源进行管理，极大的简化了用户的使用，使计算机网络对用户提供透明服务  。 \n1981 年国际标准化组织(ISO)制订：开放体系互联基本参考模型（OSI/RM），实现不同厂家生产的计算机之间实现互连。\nTCP/IP 协议也是诞生于该阶段。\n\n第四阶段 –高速、综合化网络\n\n\n宽带综合业务数字网：信息高速公路\n\n\nATM 技术、ISDN、千兆以太网\n\n\n交互性：网上电视点播、电视会议、可视电话、网上购物、网上银行、网络图书馆等高速、可视化。\nInternet 就是这一代网络的典型代表，已经成为人类最重要的、最大的知识宝库。第四代计算机网络属于计算机网络的“继续发展”阶段。\n\n\n网络性能指标\n速率相关\n\n**比特 bit：**数据计量单位 01 组成。\n**速率 rate：**是指计算机网络中的主机在数字信道上，单位时间内从一端传送到另一端的数据量，即数据传输率，也称数据率或比特率。比特(bit)是数据量的最小单位，s(秒)是时间的最小单位。所以速率单位为 bit/s 或 bps(bit persecond)，类似的有 kb/s(k=10^3)、Mb/s(M=10^6)、Gb/s(G=10^9)、Tb/s(T=10^12)，1Byte=8bit 1B=8b1B/s=8b/s(或 1Bps=8bps)。\n带宽 bandwidth： 计算机网络中的主机在数字信道上，单位时间内从一端传送到另一端的最大数据量，即最大速率。单位是比特/秒。\n**吞吐量 throughput：**吞吐量是指对网络、设备、端口或其他设施在单位时间内成功地传送数据的数量（以比特、字节等测量单位），也就是说吞吐量是指在没有帧丢失的情况下，设备能够接收并转发的最大数据速率。\n\n时延 Delay\n\n**节点处理时延 proc： **路由器或主机在收到数据包时，要花费一定时间进行处理，例如分析数据包的首部、进行首部差错检验，查找路由表为数据包选定准发接口，这就产生了处理时延。\n\n\n\n**排队时延 queue：**等待输出链路可用，进入路由器之后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了排队时延。\n\n\n\n**传输时延 trans：传输延迟也叫发送时延, 将所有分组推向链路的时间 。**取决于路由器的拥塞程度\n\n\n\n**传播时延 prop： **指电磁波在信道中传播一定距离需要花费的时间。取决于链路的物理性质。\n\n\n总时延=发送时延+传播时延+处理时延+排队时延\n\n其他\n\n**时延带宽积： **时延带宽积表示链路可容纳的比特数，因此，链路的时延带宽积又称为以比特为单位的链路长度。时延带宽积=传播时延 × 带宽。\n\n\n\n**往返时间 RTT： **往返时间 RTT，表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方收到数据后便立即发送确认），总共经历的时间。往返时间一般就会包括分组在网络中的各种时延。在一定程度上反映了网络的拥塞程度。\n**信道利用率： **信道利用率指出某信道有百分之几的时间是被利用的（有数据通过），等于发送时延除以发送时延加上往返传输时延。完全空闲的信道的利用率是零。利用率越接近于 1，时延急剧增大，信道利用率越高。\n\n\n计算机网络的分类\n按照覆盖的地理范围进行分类，计算机网络可以分为局域网、城域网和广域网三类。\n\n局域网(LAN)。局域网是一种在小区域内使用的，由多台计算机组成的网络，覆盖范围通常局限在 10 千米范围之内，属于一个单位或部门组建的小范围网。\n城域网(MAN)。城域网是作用范围在广域网与局域网之间的网络，其网络覆盖范围通常可以延伸到整个城市，借助通信光纤将多个局域网联通公用城市网络形成大型网络，使得不仅局域网内的资源可以共享，局域网之间的资源也可以共享。\n广域网(WAN) 广城网是一种远程网，涉及长距离的通信，覆盖范围可以是个国家或多个国家，甚至整个世界。由于广域网地理上的距离可以超过几千千米，所以信息衰减非常严重，这种网络一般要租用专线，通过接口信息处理协议和线路连接起来，构成网状结构，解决寻径问题。\n\n常见网络的拓扑结构\n星型拓扑\n星型拓扑是由中央节点和通过点到点通信链路接到中央节点的各个站点组成。\n优点：可靠性高，方便管理，易于扩展，传输效率高.\n缺点：线路利用率低，中心节点需要很高的可靠性和冗余度。\n\n总线拓扑\n总线拓扑结构采用一个信道作为传输媒体,所有站点都通过相应的硬件接口直接连到这一公共传输媒体上,该公共传输媒体即称为总线。\n优点：费用较低，易于扩展，线路的利用率高；\n缺点：可靠性不高，维护困难，传输效率低。\n\n环型拓扑\n在环型拓扑中各节点通过环路接口连在一条首尾相连的闭合环型通信线路中，环路上任何节点均可以请求发送信息。\n优点：令牌控制，没有线路竞争，实时性强，传输控制容易；\n缺点：维护困难，可靠性不高\n\n计算机网络交换技术\n数据交换的基本概念：通常将数据在通信子网中各节点间的数据传输过程称为数据交换。\n分类：网络中常用的数据交换技术可分为两大类：电路交换和存储转发交换，其中存储转发交换技术又可分为报文交换和分组交换。\n电路交换\n传统的电路交换要求每个主机之间必须直接连接, 假设网络中有  台主机, 就必须使用  条链路, 十分浪费资源. 为了改进, 引入交换机, 让主机连入到交换机上, 通过交换技术实现两台主机的连接.\n\n从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。\n电路交换的 3 个阶段\n\n建立连接\n通信\n关闭连接\n\n报文交换\n报文整个地发送，一次一跳。报文交换是分组交换的前身。\n报文交换采用&quot;存储-转发&quot;方式进行传送，无需事先建立线路，事后更无需拆除。它的优点是：线路利用率高、故障的影响小、可以实现多目的报文；缺点是：延迟时间长且不定、对中间节点的要求高、通信不可靠、失序等，不适合计算机网络，处理时间大于分组交换。\n分组交换\n分组交换是一种数位通信网络。它将资料组合成适当大小的区块，称为封包，再通过网络来传输。这个传送封包的网络是共享的，每个单位都可以独立把封包再传送出去，而且配置自己需要的资源。\n分组又称为包,而分组的首部也可称为“包头”。**分组是在互联网中传送的数据单元。**分组的首部包含了诸如目的地址和源地址等重要控制信息,每一个分组才能在互联网中独立地选择传输路径,并被正确地交付到分组传输的终点。\n路由器是用来进行分组交换的。路由器收到一个分组,先暂时存储一下,检查其首部,查找转发表,按照首部中的目的地址,找到合适的接口转发出去,把分组交给下一个路由器。这样一步一步地(有时会经过几十个不同的路由器)以存储转发的方式,把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息,以便创建和动态维护路由器中的转发表,使得转发表能够在整个网络拓扑发生变化时及时更新。\n为了提高分组交换网的可靠性,互联网的核心部分常采用网状拓扑结构,使得当发生网络拥塞或少数结点、链路出现故障时,路由器可灵活地改变转发路由而不致引起通信的中断或全网的瘫痪。\n** 分析：** 分组交换在传送数据之前不必先占用一条端到端的链路的通信资源。分组在哪段链路上传送才占用这段链路的通信资源。分组在传输时一段一段地断续占用通信资源（转发）,而且还省去了建立连接和释放连接的开销,因而数据的传输效率更高。同时可靠性更高。\n但是，这种非端到端占用资源就会导致存储转发时需要排队，这就产生了时延。此外，分组所携带的首部种的控制信息也会占用一定的开销。\n分组交换的特点：\n\n存储转发传输: 与报文交换机能够开始向输出链路传输该分组的第一个比特之前, 必须接收到整个分组. 仅当路由器接收到所有分组之后才能向链路传输该分组. 通过  条速率均为  的链路组成的路径, 从源到目的地发送一个分组, 端到端的时延是 \n排队时延与分组丢失: 对于每条相连的链路, 该分组交换机有一个输出缓存(输出队列)，用于存储路由器准备发往那条链路的分组。因此分组需要承受输出缓存的排队时延。\n**转发表和路由选择协议: **当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址. 路由器有一个转发表，用于将目的地址映射为输出链路，路由器会根据分组的地址在转发表里面查找对应的输出链路。\n\n3 种交换网络的对比\n分组交换与报文交换都是采用存储-转发交换方式. 报文交换以完整报文进行 “存储-转发”, 分组交换以较小的分组进行 “存储-转发”。\n\n计算机网络协议基本概念\n网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。\n网络协议是由三个要素组成：\n(1)  语义。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。\n(2)  语法。语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。例如，括号要成对，结束要使用分号等。\n(3)  时序。时序是对事件发生顺序的详细说明。（也可称为“同步”）。  例如，可以先加上某个数值，然后再减去某个数值。\n人们形象地把这三个要素描述为：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。\n网络层次结构的划分\n为什么要在网络中使用分层\n类比于在软件工程中使用分层结构，分层的目的是屏蔽底层细节。分层就是层层交付，下层向上层提供服务。对于上层来说，如同两个对等层之间直接交流，他们不关心底层的细节与实现，底层的存在是透明的。\n在分层体系结构中，各层之间是完全独立的，某一层并不需要知道他的下一层是如何实现的，而仅仅是需要知道下层提供的服务。由于每一层都只是实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个小问题。\n\nTCP/IP 协议簇\n现代网络使用的是 TCP/IP 协议簇， 但是在 TCP/IP 协议簇之前，还有一种协议理论： OSI 协议。 但由于 OSI 理论过于复杂，因此并没有得到广泛应用。\n\n互联网中广泛使用的是 TCP/IP 的四层协议，但是在教学过程中， 我们学习的是五层协议，注意区分。\n\n\n（1）应用层：\n应用层协议定义的是应用进程间通信和交互的规则。  这里的进程就是指主机中正在运行的程序。在互联网中的应用层协议很多,如域名系统DNS,支持万维网应用的HTTP 协议,支持电子邮件的SMTP 协议,等等。应用层交互的数据单元称为报文(message)。\n（2）运输层：\n负责向两台主机中进程之间的通信提供通用的数据传输服务。运输层主要使用两种协议：传输控制协议 TCP(Transmission Control protocol，提供面向连接的、可靠的数据传输服务）和用户数据报协议 UDP(User Datagram Protocol，提供无连接的、尽最大努力的数据传输服务(不保证数据传输的可靠性)）。\n（3）网络层：\n** 网络层负责为分组交换网上的不同主机提供通信服务。**  在发送数据时,网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP/IP 体系中,由于网络层使用 IP 协议,因此分组也叫做 IP 数据报,或简称为数据报。无论在哪一层传送的数据单元,都可笼统地用“分组”来表示。网络层的另一个任务就是要选择合适的路由,使源主机运输层所传下来的分组,能够通过网络中的路由器找到目的主机。\n**\n（4）数据链路层：\n数据链路层常简称为链路层。我们知道,两台主机之间的数据传输,总是在一段一段的链路上传送的,这就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时,数据链路层将网络层交下来的 IP 数据报组装成帧(framing,在两个相邻结点间的链路上传送帧(fame)。**每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。**\n（5）物理层：\n** 在物理层上所传数据的单位是比特。因此物理层要考虑用多大的电压代表“1”或“0”,以及接收方如何识别出发送方所发送的比特。**  物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。请注意,传递信息所利用的些物理媒体,如双绞线、同轴电缆、光缆、无线信道等,并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理层下面的物理媒体当作第 0 层。注意 mac 地址并不属于物理层而是属于数据链路层。\n应用层\n应用层是网络协议栈的最上面的一层。应用层协议定义的是应用进程间通信和交互的规则。 这里的进程就是指主机中正在运行的程序。在互联网中的应用层协议很多,如域名系统 DNS,支持万维网应用的 HTTP 协议,支持电子邮件的 SMTP 协议,等等。应用层交互的数据单元称为报文(message)。\n网络应用模型\n应用层协议原理\n** 研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序**。例如，在网络应用程序中，有两个互相通信的不同程序：一个是运行在用户主机上的浏览器程序；另一个是运行在 Web 服务器主机上的 Web 服务器程序。\n体系结构\n主要分为 p2p 模型和 客户/服务器模型\n\n(1) 在客户-服务器体系结构 (client-server architecture)中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。著名的应用程序包括 Web、FTP、Telnet 和电子邮件。\n(2) 在一个 P2P 体系结构(P2P architecture)中,对位于数据中心的专用服务器有最小的(或者没有)依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。\n进程通信\n在以上两种体系结构中， 服务器或者客户的服务都是以进程的形式运行在主机上的。不同主机中的进程是如何进行信息通信的？\n客户与服务器进程\n在 CS 架构中，浏览器或者客户端被称为客户，Web 服务器被称为服务器。在 P2P 架构中， 一个进程充当两种角色：用户和服务器。\n在一对进程之间的通信会话场景中，发起通信（即在会话开始时发起与其他进程的联系）的进程称为客户，在会话开始时等待联系的被称为服务器。\n进程与计算机网络之间的接口\n在一台主机上肯定不止运行了一个进程， 分布在多个主机上的进程是如何进行通信的？实际上，每个进程之间会有一个 套接字(socket) 的软件接口存在，套接字是应用程序的内部接口，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。\n\nSocket 是同一台主机内的应用层和传输层之间的接口。  程序开发者对于传输层的控制仅限于: 1 选择传输层协议 2 也许可以设定几个传输层参数。\nSocket 是对 TCP/IP 协议的封装，复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。它的出现使得程序员能够更加方便地借助于 TCP/IP 协议栈通信。\n进程寻址\n进程寻址用于解决 socket 往哪发送数据的问题。不同主机之间需要使用 IP 地址进行标识，同一主机上的进程用端口号进行标识。例如， Web 应用程序需要用 80 端口来标示，邮件服务器程序需要使用 25 来标示。\n端口的分类：\n公认端口（WellKnownPorts）0-1023：其中 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务等。访问网站默认访问服务器的 80 端口。\n注册端口（RegisteredPorts）1024-49151：分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。\n动态端口（Dynamic Ports）49152-65535：动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态。\n应用层协议\n应用程序的应用层协议选择\n应用层协议有很多， 应用程序应该怎样选择适合自己的应用层协议？主要从以下四个方面进行考量。\n**数据传输是否可靠： **\n分组在计算机网络中会存在丢包问题，丢包问题的严重性跟网络应用程序的性质有关，如果像是电子邮件、文件传输、远程主机、Web 文档传输的过程中出现问题，数据丢失可能会造成非常严重的后果。如果像是网络游戏，多人视频会议造成的影响可能比较小。鉴于此，数据传输的可靠性也是首先需要考虑的问题。因此，如果一个协议提供了这样的确保数据交付的服务，就认为提供了 可靠数据传输(reliable data transfer)，能够忍受数据丢失的应用被称为 容忍丢失的应用(loss-tolerant application)。\n吞吐量：\n吞吐量就是在网络应用中数据传输过程中，发送进程能够向接收进程交付比特的速率。具有吞吐量要求的应用程序被称为 带宽敏感的应用(bandwidth-sensitive application)。带宽敏感的应用具有特定的吞吐量要求，而 弹性应用(elastic application) 能够根据当时可用的带宽或多或少地利用可供使用的吞吐量。\n定时\n运输层协议也能提供定时保证，如同吞吐量保证一样，定时保证可以以多种形式实现。例如，可以设置发送方注入进套接字的每个比特到达接收方的套接字不迟于 100ms。这种服务对交互式实时应用程序非常适用。\n安全性\n在发送主机中，运输层协议能够加密由发送进程传输的所有数据；在接收主机中，运输层协议能够在数据交付给接收进程之前解密这些数据。\n\n因特网能够提供的运输服务\n一个应用层协议需要选择适合他的运输层协议支撑他的该应用层协议的服务。\n运输层提供了两种运输协议：\n1）TCP 服务\n1 . 面向连接的服务\n在应用层数据报发送后， TCP 让客户端和服务器互相交换运输层控制信息。这个握手过程就是提醒客户端和服务器需要准备好接受数据报。握手阶段后，一个  TCP 连接(TCP Connection)  就建立了。这是一条全双工的连接，即连接双方的进程都可以在此连接上同时进行收发报文。当应用程序结束报文发送后，必须拆除连接。\n2 . 可靠的数据服务\n通信进程能够依靠 TCP，无差错、按适当顺序交付所有发送的数据。应用程序能够依靠 TCP 将相同的字节流交付给接收方的套接字，没有字节的丢失和冗余。\n3 . 拥塞控制\nTCP 的拥塞控制并不一定为通信进程带来直接好处，但能为因特网带来整体好处。当接收方和发送方之间的网络出现拥塞时，TCP 的拥塞控制会抑制发送进程（客户端或服务器），我们会在后面具体探讨拥塞控制\n2）UDP 服务: 基于“尽力而为”的网络层\n\n面向非连接\n不可靠连接\n没有拥塞控制\n\n网络层与传输层之间的对比\n在之前我们介绍过了运输层的 tcp 和 udp，为了和应用层协议做区分，我们对比一下应用层和运输层。\n\n常见的应用对应的应用层协议\n\nWeb 和 HTTP\n关于 HTTP\nWeb 即 World Wide Web。是全世界使用最广泛的网络应用。提供了文件以及其他 web 资源访问服务，所有的文件通过 URL（统一资源定位器）来定位。在浏览器中输入 url 就可以访问这网站的资源文件。\nHTTP 协议（HyperText Transfer Protocol），它定义了网络通信中消息的结构，以及客户端和服务端如何交换消息，消息可以称为 HTTP 报文（HTTP Message）。HTTP 网络通信由客户端应用程序和服务端应用程序构成，客户端应用程序为 Web 浏览器，服务端应用程序为 Web 服务器。HTTP 通信的过程是：浏览器通过 URL 指定要访问的资源，然后发送 HTTP 请求给服务器，服务器收到请求后，响应 HTTP 请求。浏览器收到的服务器的响应信息后，渲染该资源文件。\n关于 URL 统一资源定位器：\n例如 https://www.yzh.im:80/index.html。\n**协议：**其中 https:// v 告诉浏览器使用何种协议。另外，浏览器也知道如何处理其他协议。例如， mailto: 协议指示浏览器打开邮件客户端；ftp:协议指示浏览器处理文件传输。\n**主机：**www.yzh.im 是一个域名，它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 IP address 地址发起请求。\n端口：两个主机之间要发起 TCP 连接需要两个条件，主机 + 端口。它表示用于访问 Web 服务器上资源的入口。如果访问的该 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。\n路径：/index.html 代表访问服务器根目录下的 index.html 文件。\nHTTP 分类\nhttp 分为持久性连接和非持久性连接。\n\n\n非持久性连接在每个 TCP 链接都在服务器发送完成后关闭。每个 TCP 连接只传输一个请求报文和响应报文。\n在采用 HTTP 1.1 持续连接的情况下，服务器在发送响应后保持该 TCP 连接打开不关闭。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。\n\nHTTP 报文\n\nHTTP 请求报文\n请求报文格式如下\n12345(Request Line) method URL Version(Header Lines) header_field_name: value               header_field_name: value\t\t\t   ...(Entity Body)  ...\n字段说明：\n请求头（request line）中定义了 http 请求的关键参数。其中 Method 字段表示请求的方式，常用的请求方式为 GET，POST。URL 字段用来定位资源，Version 字段用来说明当前使用的协议版本。\n头部行（Header Lines）中定义了可选的参数，用来辅助 HTTP 请求。\n数据域（Entity Body） 用来传输数据。\n例如：\n\nHTTP 响应报文\n格式如下：\n12345(Status Line)  version status_code phrase(Header Lines) header_field_name: value               header_field_name: value               ...(Entity Body)  ...\n字段说明：\n状态行（Status Line）定义了响应报文的关键参数。其中 Version 用来说明当前使用的协议版本，Status Code 表示请求结果的状态码，phrase 为状态码的说明。\n头部行（Header Lines）中定义了可选的参数，用来辅助 HTTP 响应。\n数据域（Entity Body） 用来传输数据。响应的数据一般是 HTML 文本，或者 JSON 文本。\n常见的状态码\n\n200 OK：请求成功。\n301 Moved Permanently：资源位置永久移动，请求会自动重定向到资源新的 URL。\n400 Bad Request：错误的请求。\n404 Not Found：请求的资源不存在服务器中。\n505 HTTP Version Not Supported：HTTP 协议版本不支持。\n\n例如：\n\n\nCookie\nHTTP 服务器是无状态化的，这简化了服务器的设计，这让工程师可以去开发能同时处理大量数据的高性能服务器。但是有时 Web 站点希望能去识别用户，为此 HTTP 使用了 cookie 来进行用户跟踪。\ncookie 技术有 4 个组件：\n\n在 HTTP 响应报文中的一个 cookie 首部行；\n在 HTTP 请求报文中的一个 cookie 首部行；\n在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；\n位于 Web 站点的一个后端数据库。\n\n\nDNS\n什么是 dns\n实现域名到主机 IP 的转换。DNS 是一个实现在多个 DNS 服务器的分布式数据库。一个应用层协议允许去查询分布式数据库。它提供了将域名转换为 IP 地址的服务。\n\nDNS 的全称是 Domain Name System,DNS ，它是一个由分层的 DNS 服务器（DNS server）实现的分布式数据库；它还是一个使得主机能够查询分布式数据库的应用层协议。\n与 HTTP、FTP、SMTP 协议一样，DNS 协议也是应用层协议。它运行在 UDP 之上，使用客户机/服务器模式在通信的端系统之间运行，在通信的端系统之间通过下面的端到端运输层协议来传送 DNS 报文。DNS 通常由其他应用层协议(包括 HTTP、FTP、SMTP)所使用，用于将用户提供的主机名解析为 IP 地址。\n在浏览器中键入一个域名来访问网站，DNS 的工作流程如下：\n【1】用户主机上运行着 DNS 应用的客户端\n【2】浏览器从 URL 中提取出要访问的网站的主机名，将主机名传送给本机的 DNS 客户端\n【3】DNS 客户端向 DNS 服务器发送一个包含主机名的请求\n【4】DNS 客户端收到一份来自服务器的回答报文，其中包含对应于主机名的 IP 地址\n【5】浏览器向对应的 IP 地址定位的 HTTP 服务器发起一个 TCP 连接\n除了提供 IP 地址到主机名的转换，DNS 还提供了下面几种重要的服务:\n主机别名(host aliasing)，有着复杂的主机名的主机能够拥有一个或多个其他别名，比如说一台名为 relay1.west-coast.enterprise.com 的主机，同时会拥有 enterprise.com 和 www.enterprise.com 的两个主机别名，在这种情况下，relay1.west-coast.enterprise.com 也称为 规范主机名，而主机别名要比规范主机名更加容易记忆。应用程序可以调用 DNS 来获得主机别名对应的规范主机名以及主机的 IP 地址。\n邮件服务器别名(mail server aliasing)，同样的，电子邮件的应用程序也可以调用 DNS 对提供的主机名进行解析。\n负载分配(load distribution)，一个域名关联一组 IP 地址，多个服务器依次处理 HTTP 请求，从而减少了单个服务器的压力。\nDNS 的工作概述\n假设运行在用户主机上的某些应用程序（如 Web 浏览器或邮件阅读器） 需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名。用户主机上的 DNS 收到后，会使用 UDP 通过 53 端口向网络上发送一个 DNS 查询报文，经过一段时间后，用户主机上的 DNS 会收到一个主机名对应的 DNS 回答报文。因此，从用户主机的角度来看，DNS 就像是一个黑盒子，其内部的操作你无法看到。但是实际上，实现 DNS 这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。\nDNS 最早的一种简单设计只是在因特网上使用一个 DNS 服务器。该服务器会包含所有的映射。这是一种集中式的设计，这种设计并不适用于当今的互联网，因为互联网有着数量巨大并且持续增长的主机，这种集中式的设计会存在以下几个问题\n\n单点故障(a single point of failure)，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。\n通信容量(traaffic volume)，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级\n远距离集中式数据库(distant centralized database)，单个 DNS 服务器不可能 邻近 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。\n维护(maintenance)，维护成本巨大，而且还需要频繁更新。\n\n所以 DNS 不可能集中式设计，它完全没有可扩展能力，因此采用分布式设计，所以这种设计的特点是 分布式、层次数据库。\n**\n首先分布式设计首先解决的问题就是 DNS 服务器的扩展性问题，因此 DNS 使用了大量的 DNS 服务器，它们的组织模式一般是层次方式，并且分布在全世界范围内。**没有一台 DNS 服务器能够拥有因特网上所有主机的映射**。相反，这些映射分布在所有的 DNS 服务器上。\n大致来说有三种 DNS 服务器：根 DNS 服务器、 顶级域(Top-Level Domain, TLD) DNS 服务器 和 权威 DNS 服务器 。这些服务器的层次模型如下图所示：\n\n假设现在一个 DNS 客户端想要知道 amazon.com 的 IP 地址，那么上面的域名服务器是如何解析的呢？首先，客户端会先根服务器之一进行关联，它将返回顶级域名 com 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一联系，它将为 amazon.com 返回权威服务器的 IP 地址。最后，该客户与 amazom.com 权威服务器之一联系，它为 www.amazom.com 返回其 IP 地址。\n我们现在来讨论一下上面域名服务器的层次系统\n\n\n根 DNS 服务器 ，有 400 多个根域名服务器遍及全世界，这些根域名服务器由 13 个不同的组织管理。根域名服务器的清单和组织机构可以在 root-servers.org/ 中找到，根域名服务器提供 TLD 服务器的 IP 地址。\n\n\n顶级域 DNS 服务器，对于每个顶级域名比如 com、org、net、edu 和 gov 和所有的国家级域名 uk、fr、ca 和 jp 都有 TLD 服务器或服务器集群。所有的顶级域列表参见 tld-list.com/ 。TDL 服务器提供了权威 DNS 服务器的 IP 地址。\n\n\n权威 DNS 服务器，在因特网上具有公共可访问的主机，如 Web 服务器和邮件服务器，这些主机的组织机构必须提供可供访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。\n一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是 本地 DNS 服务器(local DNS server)。严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 ISP(Internet Service Provider) 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP 地址。通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP 地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。\n\n\nDNS 的查询方式\n\n\n主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。\n\n\n**本地域名服务器向根域名服务器的查询通常是采用迭代查询。**当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。\n\n\n\nDNS 缓存\nDNS 缓存(DNS caching) 有时也叫做 DNS 解析器缓存，它是由操作系统维护的临时数据库，它包含有最近的网站和其他 Internet 域的访问记录。也就是说， DNS 缓存只是计算机为了满足快速的响应速度而把已加载过的资源缓存起来，再次访问时可以直接快速引用的一项技术和手段。那么 DNS 的缓存是如何工作的呢？\nDNS 缓存的工作流程\n在浏览器向外部发出请求之前，计算机会拦截每个请求并在 DNS 缓存数据库中查找域名，该数据库包含有最近的域名列表，以及 DNS 首次发出请求时 DNS 为它们计算的地址。\nDNS 记录和报文\n共同实现 DNS 分布式数据库的所有 DNS 服务器存储了资源记录(Resource Record, RR)，RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文中会包含一条或多条资源记录。RR 记录用于回复客户端查询。\n资源记录是一个包含了下列字段的 4 元组\n1(Name, Value, Type, TTL)\nRR 会有不同的类型，下面是不同类型的 RR 汇总表\nDNS RR 类型解释 A 记录 IPv4 主机记录，用于将域名映射到 IPv4 地址 AAAA 记录 IPv6 主机记录，用于将域名映射到 IPv6 地址 CNAME 记录别名记录，用于映射 DNS 域名的别名 MX 记录邮件交换器，用于将 DNS 域名映射到邮件服务器 PTR 记录指针，用于反向查找（IP 地址到域名解析）SRV 记录 SRV 记录，用于映射可用服务。\nDNS 报文\nDNS 有两种报文，一种是查询报文，一种是响应报文，并且这两种报文有着相同的格式，下面是 DNS 的报文格式：\n\n下面对报文格式进行解释\n\n前 12 个报文是 首部区域，也就是说首部区域有 12 个字节，第一个字段（标识符）是一个 16 比特的数，用于标示该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接受到的回答。 标志字段含有若干标志，标志字段表示为 1 比特，它用于指出报文是 0-查询报文还是 1-响应报文。\n问题区域包含着正在进行的查询信息。这个区域包括：1) 名字字段，包含正在被查询的主机名字；2) 类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联（类型 A）还是与某个名字的邮件服务器相关联（类型 MX）。\n在来自 DNS 服务器的回答中，回答区域包含了对最初请求的名字的资源记录。上面说过 DNS RR 记录是个四元组，而且元组中的 Type 会有不同的类型。在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。\n权威区域 包含了其他权威服务器的记录\n附加区域 包含了其他有帮助的记录。\n\n邮件协议\n电子邮件\n\n从图中我们可以看到它有三个主要组成部分：用户代理(user agent)、邮件服务器(mail server)、和简单邮件传输协议(Simple Mail Transfer Protocol,SMTP)。下面我们就来描述一下邮件收发的过程。\n用户代理允许用户阅读、回复、转发、保存和撰写报文。微软的 Outlook 和 Apple Mail 是电子邮件用户代理的例子。当用户编写完邮件时，他的用户代理向邮件服务器发送邮件，此时用户发送的邮件会放在邮件服务器的外出消息队列(Outgoing message queue)中，当接收方用户想要阅读邮件时，他的用户代理直接从外出消息队列中去取得该报文。\n邮件服务器构成了整个邮件系统的核心。每个接收方在其中的邮件服务器上会有一个邮箱(mailbox) 存在。用户的邮箱管理和维护发送给他的报文。一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。用接收方的用户想要从邮箱中读取邮件时，他的邮件服务器会对用户进行认证。如果发送方发送的邮件无法正确交付给接收方的服务器，那么发送方的用户代理会把邮件存储在一个报文队列(message queue)中，并在以后尝试再次发送，通常每 30 分钟发送一次，如果一段时间后还发送不成功，服务器就会删除报文队列中的邮件并以电子邮件的方式通知发送方。\nSMTP 是因特网电子邮件中的主要的应用层协议。SMTP 也使用 TCP 作为运输层协议，保证数据传输的可靠性。\nSMTP 协议传输过程\n为了描述 SMTP 的基本操作，我们观察一下下面这种常见的情景。\n\n我们假设 Alice 想给 Bob 发送一封简单的 ASCII 报文\n我们假设 Alice 想给 Bob 发送一封简单的 ASCII 报文\n\nAlice 调用她的邮件代理程序并提供 Bob 的邮件地址 （例如 bob@someschool.edu），编写邮件报文，然后指示用户代理发送该报文\nAlice 的用户代理把报文发送给她的邮件服务器，在那里该报文被放在消息队列中。\n运行在 Alice 的邮件服务器上的 SMTP 客户端发现了报文队列中的邮件，它就创建一个到运行在 Bob 邮件服务器上的 SMTP 服务器的 TCP 连接\n在经过一些初始化 SMTP 握手后，SMTP 客户端通过该 TCP 连接发送 Alice 的邮件。\n在 Bob 的邮件服务器上，SMTP 的服务端接收该邮件，Bob 的邮件服务器将邮件放在 Bob 的邮箱中\n在 Bob 想要看邮件时，他会调用用户代理阅读该邮件\n上面说的邮件其实就是报文，指的就是一系列 ASCII 码，SMTP 传输邮件之前，需要将二进制多媒体数据编码为 ASCII 码进行传输。\n\nSMTP 一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端也是这样的。TCP 连接通常直接连接 Alice 的邮件服务器和 Bob 的邮件服务器。\n现在你知道了两台邮件服务器邮件发送的大体过程，那么，SMTP 是如何将邮件从 Alice 邮件服务器发送到 Bob 的邮件服务器的呢？主要分为下面三个阶段：\n\n建立连接：在这一阶段，SMTP 客户请求与服务器的 25 端口建立一个 TCP 连接。一旦连接建立，SMTP 服务器和客户就开始相互通告自己的域名，同时确认对方的域名。\n邮件传送：一旦连接建立后，就开始邮件传输。SMTP 依靠 TCP 能够将邮件准确无误地传输到接收方的邮件服务器中。SMTP 客户将邮件的源地址、目的地址和邮件的具体内容传递给 SMTP 服务器，SMTP 服务器进行相应的响应并接收邮件。\n连接释放：SMTP 客户发出退出命令，服务器在处理命令后进行响应，随后关闭 TCP 连接。\n\n下面我们分析一个实际的 SMTP 邮件发送过程，以下统称为SMTP客户(C)和 SMTP服务器(S)。客户的主机名为 crepes.fr，服务器的主机名为 hamburger.edu。以 C: 开头的 ASCII 码文本就是客户交给 TCP 套接字的那些行，以 S: 开头的 ASCII 码则是服务器发送给其 TCP 套接字的那些行。一旦创建了连接，就开始了如下过程\n123456789101112131415S: 220 hamburger.eduC: HELO crepes.frS: 250 Hello crepes.fr, pleased to meet youC: MAIL FROM: &lt;alice@crepes.fr&gt;S: 250 alice@crepes.fr ... Sender okC: RCPT TO: &lt;bob@hamburger.edu&gt;S: 250 bob@hamburder.edu ... Recipient okC: DATAS: 354 Enter mail, end with &quot;.&quot; on a line by itselfC: Do you like ketchup?C: How about pickles?C: .S: 250 Message accepted for deliveryC: QUITS: 221 hamburger.edu closing connection\n在上述例子中，客户从邮件服务器 crepes.fr 向邮件服务器 hamburger.edu 发送了一个报文 (&quot; Do you like ketchup? How about pickles? &quot;) 。作为对话的一部分，该客户发送了 5 条命令: HELO(是 HELLO 的缩写)、 MAMIL FROM、RCPT TO、DATA 以及 QUIT。这些命令都是自解释的。\n什么是自解释，就是不需要再进行解释了，命令自己就能解释自己所要表述的功能。\n上面是一个简单的 SMTP 交换过程，包括了连接建立、邮件传送和连接释放三个具体过程。\n\n首先建立 TCP 连接、SMTP 调用 TCP 协议的 25 号端口监听连接请求，然后客户端发送 HELO 指令用来表明自己是发送方的身份，然后服务端作出响应。\n然后，客户端发送 MAIL FROM 命令，表明客户端的邮件地址是 &lt;alice@crepes.fr&gt;，服务器以 OK 作为响应，表明准备接收。\n客户端发送 RCPT TO 表明接收方的电子邮件地址，可以有多个 RCPT 行，即一份邮件可以同时发送给多个收件人。服务器端则表示是否愿意为收件人接收邮件。\n协商结束后，客户端用 DATA 命令发送信息，结束标志是CRLF.CRLF ，也就是 回车换行.回车换行。\n最后，控制交互的任一端可选择终止会话，为此它发出一个 QUIT 命令，另一端用命令 221 响应，表示同意终止连接，双方将关闭连接。\n\n上述过程中会涉及几个类似 HTTP 的状态码。250 就表示 OK ，类似 HTTP 的 200。在命令成功时，服务器返回代码 250，如果失败则返回代码 550（命令无法识别）、451（处理时出错）、452（存储空间不够）、421（服务器不可用）等，354 则表示开始信息输入。\nSMTP 的报文会有局限性，SMTP 的局限性表现在只能发送 ASCII 码格式的报文，不支持中文、法文、德文等，它也不支持语音、视频的数据。通过 MIME协议，对 SMTP 补充。MIME 使用网络虚拟终端(NVT)标准，允许非 ASCII 码数据通过 SMTP 传输。\nSMTP 与 HTTP 的对比\n这两个协议都用于从一台主机向另一台主机传送文件：HTTP 从 Web 服务器向 Web 客户端（通常是浏览器）传送文件，SMTP 是从一个邮件服务器向另一个邮件服务器传送文件（即电子邮件报文）。\n这两个协议也会有几个重要的区别\n\n首先，HTTP 是一个 拉协议(pull protocol)，客户端发送请求，请求获取服务端的资源，然后服务端进行响应，把需要下载的文件传输给客户端；而 SMTP 是一个 推协议(push protocol)，SMTP 的客户端会主动把邮件推送给 SMTP 的服务端。\n第二个区别是，SMTP 要求每个报文都采用 7 比特的 ASCII 码格式，如果某报文包含了非 7 比特的 ASCII 自负或二进制数据，则该报文必须按照 7 比特 ASCII 码进行编码。HTTP 数据则不受这种限制。\n第三个区别是如何处理一个既包含文本又包含图形的文档，HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。\n\n邮件访问协议\n在上述分析中，有一个疏漏的环节，那就是在 Alice 向 Bob 发送邮件的过程中，Bob 是如何通过运行在他本地 PC 上的用户代理，获得位于某 ISP 的邮件服务器上的他的邮件呢？注意到 Bob 的用户代理不能使用 SMTP 来取回邮件，因为取邮件时一个拉操作，而 SMTP 是一个推协议。因此我们要引入邮件访问协议，包括第三版的邮局协议（POP3）、因特网邮件访问协议（IMAP）以及 HTTP。\n　　下图总结了应用于因特网电子邮件的一些协议：SMTP 用来将邮件从发送发的邮件服务器传输到接收方的邮件服务器。如 POP3 这样的邮件访问协议用来将邮件从接收方的邮件服务器传送到接收方的用户代理。\n\n1）POP3\n\nPOP3 是 Post Office Protocol 3 的简称，即邮局协议的第 3 个版本，是 TCP/IP 协议族中的一员（默认端口是 110）。\n它被用户代理用来邮件服务器取得邮件。POP3 采用的也是 C/S 通信模型，对应的 RFC 文档为 RFC1939。\nPOP3 支持电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的 3 封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。\nPOP3 使用明文传输密码, 不对密码加密\nPOP3 建立在 TCP 连接上, 使用的是有连接的可靠数据传输服务\n\n2) IMAP\n\nIMAP 全称是 Internet Mail Access Protocol，即互联网邮件访问协议，是一个应用层协议（端口是 143）。用来从本地邮件客户端（Outlook Express、Foxmail、Mozilla Thunderbird 等）访问远程服务器上的邮件。\n开启了 IMAP 后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。\n\n3) 基于 Web 的电子邮件\n　　当用户用 Web 浏览器使用电子邮件时，用户和他远程邮箱之间的通信则通过 HTTP；然而，用户的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用的是 SMTP。\nCDN 内容分发\n网络视频需要消耗大量的网络带宽，很多网络视频公司会选择 CDN （Content Distribution Network）服务，来优化用户的体验。\n一个 CDN 网络管理很多分布在世界各地的服务器，在每个服务器上复制了视频和其它资源文件的副本，用户请求 CDN，然后 CDN 提供一个离用户客户端距离较近的服务器同响应客户端请求，从而给用户更快更好的网络体验。CDN 的实现是利用了 DNS 拦截和重定向请求功能。\n不使用 CDN 可能会出现的问题\n每个客户端都请求同一个地区的服务器（数据中心），服务器的带宽是一定的，请求太多造成客户端得到的资源吞吐量下降，会导致视频卡顿。\n一个流行的视频会在同一个通信链路上多次传输，浪费网络带宽。\n一个数据中心容易出现单点故障，导致整个服务不可用。\nCDN 使用的过程\n\n用户访问一个视频的链接，如 http://video.netcinema.com/6Y7B23V 。\n浏览器查询客户端本地缓存是否存在该域名的 IP 地址。如果没有，继续下一步查询。\n浏览器请求本地 DNS 服务器，查询 video.netcinema.com 域名的 IP 地址。本地 DNS 服务器检查本地缓存是否存在该域名，不存在，则请求权威 DNS 服务器，查询 video.netcinema.com 的 IP 地址。权威 DNS 服务器发现是 video 开头的域名，则返回 CDN 提供商的权威域名如 a105.kingcdn.com。\n本地 DNS 服务器请求权威域名服务器，查询 a105.kingcdn.com 的 IP 地址，CDN 提供商根据客户端的地理位置，最终返回 CDN 系统中的一个 web 服务器 IP 地址。\n本地 DNS 服务器把 IP 地址返回给浏览器。\n浏览器通过 IP 地址与服务器建立 TCP 连接，发送视频访问请求。web 服务器返回视频内容给浏览器。\n\nCDN 是如何让客户端访问离自己最近的一个服务器\n**方法一：**使用 DNS 服务器响应一个离用户最近的服务器的 IP 地址。DNS 服务器通过查询 IP 位置数据库，获取客户端所在的城市。根据客户端所在的城市选一个最近的一个服务器的 IP 地址返回给客户端。\n**方法二：**使用任播（Anycast）路由选择一个最近的服务器。CDN 分布世界各地的所有 Web 服务器使用同一个 IP 地址。路由器根据最少花费（Lowest Cost）的路由规则，选择一个离客户端最近的服务器。\nFTP\n简介\n文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。\nFTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限\n网络环境下复制文件的复杂性：\n\n\n计算机存储数据的格式不同。\n\n\n文件的目录结构和文件命名的规定不同。\n\n\n对于相同的文件存取功能，操作系统使用的命令不同。\n\n\n访问控制方法不同。\n\n\n正是因为网络环境下复制文件的复杂性，因此就需要用到了 FTP 协议了。\n过程\n\n\n打开熟知端口（端口号为 21），使客户进程能够连接上。\n\n\n等待客户进程发出连接请求。\n\n\n启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。\n\n\n回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。\n\n\n当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。\n\n\n接着**，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。**\n\n\n由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。\n\n\n\nFTP 是使用了两个 TCP 连接的。好处：\n\n\n使协议更加简单和更容易实现。\n\n\n在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。\n\n\nP2P\n我们上面探讨的协议 HTTP、SMTP、DNS 都采用了客户-服务器 模式，这种模式会极大依赖总是打开的基础设施服务器。而 P2P是客户端与客户端模式，对总是打开的基础设施服务器有最小的依赖。\nP2P 的全称是 Peer-to-peer, P2P ，是一种分布式体系结构的计算机网络。在 P2P 体系中，所有的计算机和设备都被称为对等体，他们互相交换工作。对等网络中的每个对等方都等于其他对等方。网络中没有特权对等体，也没有主管理员设备。\n\n从某种意义上说，对等网络是计算机世界中最平等的网络。每个对等方都相等，并且每个对等方具有与其他对等方相同的权利和义务。对等体同时是客户端和服务器。\n实际上，对等网络中可用的每个资源都是在对等之间共享的，而无需任何中央服务器。P2P 网络中的共享资源可以是诸如处理器使用率，磁盘存储容量或网络带宽等。\nP2P 用来做什么\nP2P 的主要目标是共享资源并帮助计算机和设备协同工作，提供特定服务或执行特定任务。如前面说到的，P2P 用于共享各种计算资源，例如网络带宽或磁盘存储空间。 但是，对等网络最常见的例子是 Internet 上的文件共享。 对等网络非常适合文件共享，因为它们允许连接到它们计算机等同时接收文件和发送文件。\nBitTorrent 是 P2P 使用的主要协议。\nP2P 网络的作用\nP2P 网络具有一些使它们有用的特征\n\n很难完全掉线，即使其中的一个对等方掉线，其他对等方仍在运行并进行通信。 为了使 P2P（对等）网络停止工作，你必须关闭所有对等网络。对等网络具有很强的可扩展性。 添加新的对等节点很容易，因为你无需在中央服务器上进行任何中央配置。\n当涉及到文件共享时，对等网络越大，速度越快。 在 P2P 网络中的许多对等点上存储相同的文件意味着当某人需要下载文件时，该文件会同时从多个位置下载。\n\n传输层\n传输层概述\n传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。\n传输层两大重要的功能：复用 和 分用。\n\n复用：在发送端，多个应用进程公用一个传输层；\n分用：在接收端，传输层会根据端口号将数据分派给不同的应用进程。\n\n\n和网络层的区别：\n\n网络层为不同主机提供通信服务，而传输层为不同主机的不同应用提供通信服务。\n网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。\n\n可靠传输的原理\n理想的传输条件有以下两个特点：\n\n\n(1) 传输信道不产生差错。\n\n\n(2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。\n\n\n然而实际的网络都不具备以上两个理想条件**。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。**\nUDP 和 TCP 的特点\n\n\n用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。\n\n\n传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。\n\n\nUDP\nUDP 概述\nUDP 只在 IP 的数据报服务之上增加了很少一点的功能：\n\n\n复用和分用\n\n\n差错检测\n\n\nUDP 特性：\n\n\n提供无连接服务。\n\n\n在传送数据之前不需要先建立连接。\n\n\n传送的数据单位协议是 UDP 报文或用户数据报。\n\n\n对方的运输层在收到 UDP 报文后，不需要给出任何确认。\n\n\n虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。\n\n\nUDP 支持一对一、一对多、多对一和多对多的交互通信。\n\n\nUDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短\n\n\n还要注意的是：\n\n\nIP 数据报要经过互连网中许多路由器的存储转发。\n\n\nUDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。\n\n\nUDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。\n\nUDP 首部格式\n\n首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。源端口号可有可无。\n长度字段：UDP 数据报的整个长度，首部+数据字段。\nUDP 检验和：用于差错校验，非必须，如果不使用校验和就将校验和字段置为全 0，如果校验和字段恰巧全为 0，就将校验和置为全 1。\n分用时，找不到目的端口号，就丢弃报文，并且发送一个 ICMP，端口不可达的差错报文。\n伪首部：也被称为伪 IP 首部，只在计算校验和的时候出现，既不向下传送也不向上递交。\n伪首部的第三个字段固定全零。\n伪首部第四个字段 17：封装 UDO 报文的 IP 数据报首部协议字段是 17。\nUDP 长度：UDP 首部 8B+数据部分的长度（不包括伪首部）。\nUDP 校验和计算\n将一行看作一个整体，当作 4 个字节。\n发送端：\n\n填上伪首部\n全 0 填充校验和字段\n全 0 填充数据部分（UDP 数据报要看着许多 4B 的字串拼接起来）\n用伪首部+首部+数据部分采用二进制反码求和\n把和求反码填入校验和字段\n去掉伪首部，发送。\n\n接收端：\n\n填上伪首部\n伪首部+首部+数据部分采用二进制反码求和\n结果全为 1 则无差错，否则丢弃数据报、交给应用层上出差错的警告。\n\n\nTCP\nTCP 概述\n面向字节流\n\n\nTCP 中的“流”(stream)指的是流入或流出进程的字节序列。\n\n\n“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。\n\n\n接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。\n\n\n提供面向连接的服务。\n\n\n传送的数据单位协议是 TCP 报文段 (segment)。\n\n\nTCP 不提供广播或多播服务。\n\n\n由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。\n\n\nTCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。\n值得注意的：\n\n\nTCP 连接是一条虚连接而不是一条真正的物理连接。\n\n\nTCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。\n\n\nTCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）\n\n\n面向套接字接口： 端口号拼接到 (contatenated with) IP 地址即构成了套接字。\nTCP 报文\n\n\n\n序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。\n\n\n确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。\n\n\n数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。\n\n\n确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n\n\n同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。\n\n\n终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。\n\n\n窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。\n\n\nTCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。首部的最大长度是 40 字节。\nTCP 连接管理\nTCP 的三次握手\n\n假设 A 为客户端，B 为服务器端。\n\n\n首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\n\n\nA 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。\n\n\nB 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。\n\n\nA 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\n\n\nB 收到 A 的确认后，连接建立。\n\n\n三次握手的原因\n第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\nTCP 的四次挥手\n\n以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。\n\n\nA 发送连接释放报文，FIN=1。\n\n\nB 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n\n\n当 B 不再需要连接时，发送连接释放报文，FIN=1。\n\n\nA 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\n\n\nB 收到 A 的确认后释放连接。\n\n\n四次挥手的原因\n客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。\nTIME_WAIT\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n\n\n确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n\n\n等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n\n\nTCP 可靠传输\nTCP 流量控制\n流量控制是为了控制发送方发送速率，保证接收方来得及接收。\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\nTCP 使用滑动窗口机制来实现流量控制。\n窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。\n发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。\n\nTCP 拥塞控制\n如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。\n\nTCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n为了便于讨论，做如下假设：\n\n接收方有足够大的接收缓存，因此不会发生流量控制；\n虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n\n\n慢开始与拥塞避免\n发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。\n快重传与快恢复\n在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M 和 M，此时收到 M，应当发送对 M 的确认。\n在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M，则 M 丢失，立即重传 M。\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n**\n推荐文章计算机网络学习总结[转载][2]使用 Java 实现简单的 WebServer","plink":"https://mvbbb.github.io/hf30zm/"},{"title":"Bye! My 2020","date":"2020-12-31T23:00:00.000Z","date_formatted":{"ll":"Dec 31, 2020","L":"12/31/2020","MM-DD":"12-31"},"updated":"2021-02-03T04:20:05.890Z","content":"\n  \n  \n    \n      \n      \n        查看该博客需要密码, 你猜是多少\n      \n    \n  \n\n","plink":"https://mvbbb.github.io/my2020/"},{"title":"数据结构笔记归档","date":"2020-12-23T04:30:41.000Z","date_formatted":{"ll":"Dec 23, 2020","L":"12/23/2020","MM-DD":"12-23"},"updated":"2021-02-03T04:20:59.133Z","content":"一些之前写的笔记. 因为公式编码的原因, 在 Hexo 上渲染出错, 就将他们放在了语雀上.\n数据结构知识点\n树图基础\n哈夫曼编码\n\n","plink":"https://mvbbb.github.io/hb7vve/"},{"title":"20/12/1 近期规划","date":"2020-12-01T12:50:08.000Z","date_formatted":{"ll":"Dec 1, 2020","L":"12/01/2020","MM-DD":"12-01"},"updated":"2021-02-03T04:20:59.153Z","content":"要点记录:\n\nSQL 练习\n计算机网络\n操作系统\nSpring 相关\n英语六级\nJava 实践\n\n安排计划\n1 . SQL 练习: 最近几天加强练习, 周末上机实验写不出来就尴尬了\n2 . 计算机网络: 还需要写一个简单的代理服务器程序, 还要看可靠数据传输原理. 代理服务器的事儿可以先放一放, 可靠数据传输原理明天上课应该可以搞定.\n3 . 操作系统: 先把学习通的几百道题做完, 不过还好, 已经做了许多了, 发现了很多遗忘或者不懂东西.\n\n快表命中率, 访问时间… 的计算方法\n经典同步问题的 pv 操作\n文件系统/IO 可以说是一窍不通, 之前学了也忘得差不多了\n页/段/段页存储, 物理地址, 虚地址… 的相关计算\n各种调度算法英文单词对应的中文含义\n记录型信号量和整型信号量的区别\n长/中/短程调度的区别\n\n4 . Spring 相关: 现在还有点迷, 迷, 迷.\n5 . 英语六级: 呵呵, 迎来的又是一次裸考, 下次一定过. 失眠的时候背背单词已经是我做出的最大努力了.\n6 . Java 实践: 实在是不想再写了, 把之前的推翻了一遍又一遍, 累了, 不改了, “修车” 功能也懒得实现了.\n\nOne More thing\n… Better not to say…\nUnhappy !\n\n\n","plink":"https://mvbbb.github.io/izwdvz/"},{"title":"使用 Java 实现简单的 WebServer","date":"2020-11-24T13:43:44.000Z","date_formatted":{"ll":"Nov 24, 2020","L":"11/24/2020","MM-DD":"11-24"},"updated":"2021-02-03T04:20:59.209Z","content":"Web Server 的功能: 根据用户提供的 Http request, Web Server 返回对应的 Http response. Web Server 也只不过是一个 Application.\n\n预备知识\n\nsocket 的基本使用\nHTTP 协议\nJava 知识\n\nSocket 的基本使用\nSocekt 是同一台主机内, 应用层与传输层之间的接口. 两个程序通过彼此的 Socket 接口进行信息交换, 建立在 Socket 上的程序不需要关心底层的实现.\n12345Socket 方法InetAddress getInetAddress() : 返回socket连接的地址int getPort(): 返回远程连接这socket的端口InetAddress getLocalAddress(): 获取该socket绑定的本地地址int getLocalPort() : 获取这socket绑定的本地端口\nHTTP 协议\nHTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）, 是客户端和服务器交互的一种通迅的格式.\n\nHttp 请求\n\nHttp 响应\n\n\n首先, 用户浏览器向服务器发送 HTTP 请求来获取资源. 之后服务器回复 HTTP 响应. 在本程序中, HTTP 请求有浏览器发出, Java 程序负责响应用户请求, 并返回 HTTP 响应报文. 它们通过 Socket 接口进行 HTTP 报文交换.\nJava 知识\n使用到 Java 中的两个主要类来实现 Web Server: java.net.ServerSocket, java.net.ServerSocket\n下图是 TCP 中客户套接字和服务器套接字的连接方式\n\nServerSocket 对应上图中的 Welcoming Socket, Socket 对应上图中的 Connection Socket.\nWelcoming Socket 监听请求, 当收到来自用户的请求, 就为其建立一个 Connection Socket.\n实现思路\n\n服务在指定端口进行监听，等待请求。\n当接收到请求后，建立连接，新建一个线程，准备分析报文。\n分析请求报文，对用户请求的网页进行查找，并读取内容。\n构造响应报文的内容。\n将响应报文发送给请求方。\n\n代码实现\n第一个版本\n根据 HTTP 报文请求的 URL 返回给用户对应的资源.\n代码实现和项目目录结构如下\n\n123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class HttpServer &#123;    public static final String webroot= &quot;version1/WebRoot/&quot;;    public static void main(String[] args) throws Exception &#123;        /*在80端口监听的 Welcoming Socekt*/        ServerSocket serverSocket = new ServerSocket(80);        /* accept 是一个阻塞方法, 会一直监听, 建立连接之后返回一个 Connection Socket */        System.out.println(&quot;服务器端等待请求&quot;);        Socket socket = serverSocket.accept();        System.out.println(&quot;成功建立连接&quot;+socket.toString());        /*用于获取 socket 接收的服务端请求报文*/        BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        /*Http请求行*/        String httpRequestLine = reader.readLine();        /*请求的 uri*/        String uri = httpRequestLine.split(&quot; &quot;)[1];        String url=webroot+uri;        /*从磁盘中取出用户请求的资源文件, 并放回给用户*/        FileInputStream fileInputStream = new FileInputStream(url);        OutputStream outputStream = socket.getOutputStream();        byte[] buffer = new byte[1024];        int length=0;        while((length=fileInputStream.read(buffer))!=-1)&#123;            outputStream.write(buffer, 0, length);        &#125;        System.out.println(&quot;成功发送给用户&quot;);        outputStream.flush();        socket.close();    &#125;&#125;\n\n\n第二个版本\n1 . 在第一个版本中假如用户请求一个服务器没有的资源, 服务器会报异常, 这一点需要改进. 资源不存在的时候应该返回 404 界面\n\n2 . 用户可能不止一次的请求服务器, 我们需要使用循环, 不断监听用户请求.\n3 . 真实情况下, 服务器不止处理一个用户的请求, 在第一个版本中我们只能处理一个用户的请求, 因此我们需要使用多线程, 同时处理多个用户的请求.\n4 . 实现 GET/POST, 并返回标准的 HTTP response\n代码实现和目录结构如下\n\n代码仓库 HTTP 服务器\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.HashMap;import java.util.Map;import java.util.Scanner;import java.util.Set;public class WebServer &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket serverSocket=new ServerSocket(8000);        while(true)&#123;            Socket socket= serverSocket.accept();            new Thread(new MyHttpServer(socket)).start();        &#125;    &#125;&#125;/** * 处理一个 Connection Socket 的请求的 HttpServer */class MyHttpServer implements Runnable &#123;    private final String CRLF=&quot;\\r\\n&quot;;    private Socket socket;    private String webroot;    public MyHttpServer(Socket socket) &#123;        System.out.println(&quot;连接到服务器的用户: &quot;+socket);        this.socket = socket;        // 服务器的资源根目录是当前用户的工作目录        webroot=System.getProperties().getProperty(&quot;user.dir&quot;);    &#125;    /**     * 目前只是实现了解析 HTTP 请求     */    @Override    public void run() &#123;        BufferedReader reader=null;        PrintWriter printWriter=null;        try &#123;            // 读取输入            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));            // 写输出            printWriter = new PrintWriter(socket.getOutputStream(), true);            // 读入请求行            String requestLine = reader.readLine();            if(requestLine==null)return;            // 请求行参数: POST/GET 请求uri HTTP版本            String[] requstLineArgs = requestLine.split(&quot; &quot;);            // 读入请求头            String line = null;            String[] keyValue = null;            Map&lt;String, String&gt; requestHeaders = new HashMap&lt;String, String&gt;();            while ((line = reader.readLine()) != null &amp;&amp; !&quot;&quot;.equals(line)) &#123;                int i = line.indexOf(&quot;: &quot;);                requestHeaders.put(line.substring(0,i),line.substring(i+2));            &#125;            // 展示HTTP请求行中的参数            System.out.println(&quot;用户&quot;+socket.getPort()+&quot;请求方法: &quot;+requstLineArgs[0]);            System.out.println(&quot;用户&quot;+socket.getPort()+&quot;请求地址: &quot;+requstLineArgs[1]);            System.out.println(&quot;用户&quot;+socket.getPort()+&quot;的HTTP版本: &quot;+requstLineArgs[2]);            // 展示Http 请求头中的参数            System.out.println(&quot;********************&quot;);            System.out.println(&quot;用户&quot;+socket.getPort()+&quot;请求头参数&quot;);            showMapValue(requestHeaders);            System.out.println(&quot;********************&quot;);            // 如果是POST方法继续读入请求体            if (&quot;POST&quot;.equals(requstLineArgs[0])) &#123;                doPost(requstLineArgs, requestHeaders, reader, printWriter);            &#125;            // 如果是GET方法就解析uri            if (&quot;GET&quot;.equals(requstLineArgs[0])) &#123;                doGet(requstLineArgs, requestHeaders, printWriter);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (reader != null) &#123;                try &#123;                    reader.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (printWriter != null) &#123;                printWriter.close();            &#125;            if(socket!=null)&#123;                try &#123;                    System.out.println(&quot;关闭与服务器连接的用户: &quot;+socket);                    System.out.println();                    socket.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /**     * 请求行中是 GET 方法     * @param requestLineArgs     * @param requestHeaders     * @param printWriter     */    public void doGet(String[] requestLineArgs,Map&lt;String,String&gt; requestHeaders,PrintWriter printWriter)&#123;        // GET 的 requestLine 的解析        int i = requestLineArgs[1].indexOf(&#x27;?&#x27;);        // GET 有参数        if(i!=-1) &#123;            // 将参数放入到 getArgs 中            String sourceUri = requestLineArgs[1].substring(0, i);            String[] s = requestLineArgs[1].substring(i + 1).split(&quot;&amp;&quot;);            String[] keyValue = null;            Map&lt;String, String&gt; getArgs = new HashMap&lt;String, String&gt;();            for (String ss : s) &#123;                String[] split = ss.split(&quot;=&quot;);                getArgs.put(split[0], split[1]);            &#125;            // 展示GET请求链接中的参数            System.out.println(&quot;********************&quot;);            System.out.println(&quot;用户&quot;+socket.getPort()+&quot;GET 中的参数&quot;);            showMapValue(getArgs);            System.out.println(&quot;********************&quot;);            writeFile(printWriter,requestHeaders,sourceUri);        &#125;else&#123; // 没有额外参数, 属于直接访问            writeFile(printWriter,requestHeaders,requestLineArgs[1]);        &#125;    &#125;    /**     * 请求行中是 POST 方法, 现在还不会处理POST方法, 先挖坑     * @param requestLineArgs     * @param requestHeaders     * @param reader     * @param printWriter     */    public void doPost(String[] requestLineArgs,Map&lt;String,String&gt; requestHeaders,BufferedReader reader,PrintWriter printWriter)&#123;        String sourceUri=requestLineArgs[1];        // 还需要读入 requestBody    &#125;    /**     * 将用户请求的文件发送给用户     * @param printWriter     * @param requestHeaders     * @param uri     */    public void writeFile(PrintWriter printWriter,Map&lt;String,String&gt; requestHeaders,String uri) &#123;        String url=webroot+uri;        System.out.println(&quot;用户&quot;+socket.getPort()+&quot;请求文件地址: &quot;+url);        File file = new File(url);        try &#123;            String statusLine=null;            String contentType=null;            String entityBody=null;            // 请求的文件存在             if(file.exists()&amp;&amp;file.isFile())&#123;                statusLine =&quot;HTTP/1.0 200 OK&quot;+CRLF;                contentType=&quot;Content-Type&quot;  +contentType(file.toString())+CRLF;                printWriter.print(statusLine);                printWriter.print(contentType);                printWriter.print(CRLF); //之前的为响应行+响应头部, 之后的是响应正文, 之间用 CRLF 分隔                 // 将文件内容发送给用户                 Scanner scanner = new Scanner(new FileInputStream(file));                 while (scanner.hasNextLine()) &#123;                     printWriter.println(scanner.nextLine());                 &#125;                 printWriter.flush();             &#125;            else&#123;                statusLine=&quot;HTTP/1.0 404 Not Found&quot;+CRLF;                contentType=&quot;Content-Type: text/html&quot;+CRLF;                entityBody=&quot;&lt;HTML&gt;&quot; +                        &quot;&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;&quot; +                        &quot;&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;&quot;;                 printWriter.print(statusLine);                 printWriter.print(contentType);                 printWriter.print(CRLF); //之前的为响应行+响应头部, 之后的是响应正文, 之间用 CRLF 分隔                 printWriter.print(entityBody);                 printWriter.flush();            &#125;        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 根据用户请求的文件类型, 返回符合mime标准的文件类型     * 目前只实现了请求html文件的功能     * @param fileName     * @return     */    public String contentType(String fileName)&#123;        if(fileName.endsWith(&quot;.htm&quot;)||fileName.endsWith(&quot;.html&quot;))&#123;            return &quot;text/html&quot;;        &#125;        return &quot;&quot;;    &#125;    public void showMapValue(Map&lt;String,String&gt; map)&#123;        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;            System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue());        &#125;    &#125;&#125;\n\n控制台打印\n123456789101112131415161718192021连接到服务器的用户: Socket[addr=/0:0:0:0:0:0:0:1,port=11148,localport=8000]用户11147请求方法: GET用户11147请求地址: /index.html用户11147的HTTP版本: HTTP/1.1********************用户11147请求头参数Cookie: Idea-48934e7a=d9468800-fffb-4bce-8707-98eda7648a0b; Webstorm-bee48fc1=645e8992-2d9b-4176-af5d-21b7e87ac442Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Upgrade-Insecure-Requests: 1Connection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36Sec-Fetch-Site: noneSec-Fetch-Dest: documentHost: localhost:8000Sec-Fetch-User: ?1Accept-Encoding: gzip, deflate, brAccept-Language: zh,en-US;q=0.9,en;q=0.8,zh-CN;q=0.7Sec-Fetch-Mode: navigate********************用户11147请求文件地址: E:\\Desktop\\新建文件夹 (2)/index.html关闭与服务器连接的用户: Socket[addr=/0:0:0:0:0:0:0:1,port=11147,localport=8000]\n注意, 该版本并不完美\n\n在 Linux 环境下好像会出现路径转义错误\n并不能根据请求参数的不同做出不同的响应, 只能响应最基本的请求 HTML 文件功能, 并判断是否响应 404\nGET 请求的中文编码问题没解决\n\n参考资料\n万字长文复习 HTTP\n菜鸟教程: Http \nHTTP 请求头和请求体\njava Socket + 自定义线程池 实现 web 服务器 仿 Servlet\njava 实现简单的 http 服务器\n廖雪峰-Java 网络编程\n推荐文章计算机网络学习总结[转载][2]计算机网络学习总结[转载][1]JDBC与mysql数据库交互《码出高效》笔记Practical Java筆記","plink":"https://mvbbb.github.io/cxnppw/"},{"title":"在服务器上部署运行Socket","date":"2020-11-20T05:46:46.000Z","date_formatted":{"ll":"Nov 20, 2020","L":"11/20/2020","MM-DD":"11-20"},"updated":"2021-02-03T04:20:59.221Z","content":"\n环境: JDK11+Centos7\n\n开通服务器端口\n\n宝塔面板开通\n\n\n2 . 服务器商安全组放行\n编写代码\n服务器端\n123456789101112131415161718192021import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPServer &#123;    public static void main(String[] args) throws Exception&#123;        DatagramSocket socket = new DatagramSocket(12000);        byte[] bys=new byte[1024];        int length =bys.length;        DatagramPacket packet = new DatagramPacket(bys, length);        while(true) &#123;            socket.receive(packet);            InetAddress inetAddress = packet.getAddress();            String ip= inetAddress.getHostAddress();            byte[] data = packet.getData();            int len= packet.getLength();            String s = new String(data, 0, len);            System.out.println(ip+&quot;传过来的数据是 : &quot;+s);        &#125;    &#125;&#125;\n客户端(本地运行)\n12345678910111213141516import java.net.*;public class UDPClient &#123;    public static void main(String[] args) throws Exception &#123;        // 创建 DatagramSocket 类        DatagramSocket socket = new DatagramSocket();        byte[] bys=&quot;你好, 我是客户端 &quot;.getBytes();        int length = bys.length;        InetAddress address = InetAddress.getByName(&quot;***.***.***.***&quot;);// 替换为你的服务器IP        int port =12000;        DatagramPacket packet = new DatagramPacket(bys,length,address,port);        socket.send(packet);        socket.close();    &#125;&#125;\n运行代码\n1 . 将服务器代码上传到服务器, 编译运行\n12javac UDPServer.java //编译java UDPServer // 运行\n2 . 本地运行 UDPClient, 服务器端会打印内容\n\n后续:\n假如不小心关闭了终端, 怎样结束服务器端 UDPServer 程序?\n1 . 查看 12000 端口占用情况, 找到 Java 进程 PID: netstat -ntulp |grep 12000 \n    \nPID= 23531\n2 . 使用 kill -9 [PID]  结束 Java 进程\n其他 Socket 程序都是以类似的方式部署运行.\n更多的 Socket 程序请查看 Java 网络编程\n","plink":"https://mvbbb.github.io/bvgh8x/"},{"title":"文件上传下载","date":"2020-11-13T06:47:34.000Z","date_formatted":{"ll":"Nov 13, 2020","L":"11/13/2020","MM-DD":"11-13"},"updated":"2021-02-03T04:20:59.233Z","content":"上传功能\n需要使用到两个包\nindex.jsp\n123456&lt;form method=&quot;post&quot; action=&quot;upload.do&quot; enctype=&quot;multipart/form-data&quot;&gt;    用户名: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;&lt;br&gt;    &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot;&gt;|        &lt;input type=&quot;reset&quot;&gt;  &lt;/form&gt;\nFileServlet.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117@WebServlet(&quot;/upload.do&quot;)public class FileServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doGet(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;FileServlet.java doPost&quot;);        // 判断上传的文件是普通表单还是带文件的表单        if(!ServletFileUpload.isMultipartContent(req))&#123;            return;  // 普通表单        &#125;        // 创建上传文件的保存路径, 建议保存到 WEB-INF 目录下, 安全, 用户无法直接访问上传的文件        String uploadPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); // 该项目下的/WEB-INF/upload 目录        File uploadFile = new File(uploadPath);        if(!uploadFile.exists())&#123;            uploadFile.mkdir(); // 创建这个目录        &#125;        // 缓存, 临时文件        // 临时路径, 如果文件超过预取大小, 将该文件放到临时文件中, 过几天自动删除, 或者提醒用户转存为永久        String temPath = this.getServletContext().getRealPath(&quot;/WEB-INF/tmp&quot;); // 该项目下的/WEB-INF/upload 目录        File tmpFile = new File(uploadPath);        if(!tmpFile.exists())&#123;            tmpFile.mkdir(); // 创建这个目录        &#125;        // 处理上传的文件一般通过流来获取, 我们可以使用 request.getInputStream(), 原生态的文件上传流来获取, 十分麻烦        // 一般建议使用 Apache 的文件上传组件来实现, common-fileupload, 它依赖于 commons-io 组件        //1. 创建 DiskFileItemFactory 对象, 处理上传路径或者大小的限制        DiskFileItemFactory factory=new DiskFileItemFactory();        /* 可选项,非必须        // 通过这工厂设置一个缓冲区, 当上传文件大于这个缓冲区是, 将他放到临时文件中        factory.setSizeThreshold(1024*1024); // 缓冲区大小为1m        factory.setRepository(tmpFile); // 临时目录的保存目录        */        //2. 获取 ServletFileUpload        ServletFileUpload upload=new ServletFileUpload(factory);        /* 可选项,非必须        // 监听文件的上传进度        upload.setProgressListener(new ProgressListener() &#123;            @Override            public void update(long l, long l1, int i) &#123;                System.out.println(&quot;总大小: &quot;+l1+&quot;已上传: &quot;+l);            &#125;        &#125;);        upload.setHeaderEncoding(&quot;UTF-8&quot;);  //处理乱码问题        upload.setFileSizeMax(1024*1024*10); //设置单个文件的最大值        upload.setSizeMax(1024*1024*10); // 设置总共能够上传文件的大小        */        //3. 处理上传的文件        try &#123;            // 将前端请求解析, 封装成 FileItem 对象, 需要从 ServletFileUpload 对象获取            List&lt;FileItem&gt; fileItems = upload.parseRequest(req);            for (FileItem fileItem : fileItems) &#123;                // 判断上传的文件是普通表单还是带文件的表单                if(fileItem.isFormField())&#123;                    // name 是指前端表单控件的 name                    String name = fileItem.getFieldName();                    String value=fileItem.getString(&quot;UTF-8&quot;); // 处理乱码                    System.out.println(name+&quot;: &quot;+value);                &#125;else&#123;                    // 如果是文件表单                    //================1. 处理文件                    // 获取文件名(全路径)                    String uploadFileName=fileItem.getName();                    if(uploadFileName.trim().equals(&quot;&quot;)||uploadFileName==null)&#123;                        continue;                    &#125;                    // 上传的文件名(单文件)                    String fileName=uploadFileName.substring(uploadFileName.lastIndexOf(&quot;/&quot;)+1);                    // 文件后缀                    String fileExtName=uploadFileName.substring(uploadFileName.lastIndexOf(&quot;.&quot;) + 1);                    /*                    如果问价后缀不合法可以直接return, 告诉用户文件类型不合法                    可以使用UUID(唯一通用识别码),保证文件名唯一                    UUID.randomUUID(), 随机生成一个唯一识别通用码                     */                    String uuidPath = UUID.randomUUID().toString();                    //===============2. 存放地址                    String realPath=uploadPath+&quot;/&quot;+uuidPath;                    File realPathFile = new File(realPath);                    if(!realPathFile.exists())&#123;                        realPathFile.mkdir();                    &#125;                    //===============3. 文件传输                    // 获得文件上传流                    InputStream inputStream=fileItem.getInputStream();                    // 创建文件输出流                    // realPath=真实的文件夹                    // 差了一个文件; 加上输出文件的名字+&quot;/&quot;+uuidFileName                    FileOutputStream fos=new FileOutputStream(realPathFile+&quot;/&quot;+fileName);                    // 创建缓冲区                    byte[] buffer=new byte[1024*1024];                    int len=0;                    while((len=inputStream.read(buffer))&gt;0)&#123;                        fos.write(buffer, 0, len);                    &#125;                    fos.close();                    inputStream.close();                    fileItem.delete();                    // 通知前端文件上传成功                    System.out.println(&quot;成功&quot;);                &#125;            &#125;        &#125; catch (FileUploadException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n在 idea 中, 上传成功的文件会保存到 out/artifacts/项目名/WEB-INF  下\n下载功能\n12345678910111213141516171819202122232425262728293031@WebServlet(&quot;download.do&quot;)public class FileDownloadServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取到资源的路径        String path = this.getServletContext().getRealPath(&quot;/download/1.png&quot;);        //读取资源        FileInputStream fileInputStream = new FileInputStream(path);        //获取到文件名,路径在电脑上保存是\\\\形式的。        String fileName = path.substring(path.lastIndexOf(&quot;\\\\&quot;) + 1);        //设置消息头，告诉浏览器，我要下载1.png这个图片, 解决中文乱码问题        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;));        //把读取到的资源写给浏览器        int len = 0;        byte[] bytes = new byte[1024];        ServletOutputStream servletOutputStream = resp.getOutputStream();        while ((len = fileInputStream.read(bytes)) &gt; 0) &#123;            servletOutputStream.write(bytes, 0, len);        &#125;        //关闭资源        servletOutputStream.close();        fileInputStream.close();    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doPost(req, resp);    &#125;&#125;","plink":"https://mvbbb.github.io/vuhe3q/"},{"title":"过滤器-监听器","date":"2020-11-09T09:57:39.000Z","date_formatted":{"ll":"Nov 9, 2020","L":"11/09/2020","MM-DD":"11-09"},"updated":"2021-02-03T04:20:59.313Z","content":"过滤器解决 response 中文乱码\n\nShowServlet.java\n12345678910111213@WebServlet(&#123;&quot;/servlet/show&quot;,&quot;/show&quot;&#125;)public class ShowServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;deGet&quot;);        resp.getWriter().write(&quot;你好呀&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doPost(req, resp);    &#125;&#125;\nCharacterEncodingFilter\n123456789101112131415161718192021222324// 过滤范围@WebFilter(&quot;/servlet/*&quot;)public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;CharacterEncodingFilter 初始化&quot;);    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        servletRequest.setCharacterEncoding(&quot;UTF-8&quot;);        servletResponse.setCharacterEncoding(&quot;UTF-8&quot;);        servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);        System.out.println(&quot;CharacterEncodingFilter执行前&quot;);        filterChain.doFilter(servletRequest,servletResponse); // 让请求继续走, 到下一个过滤器, 不然就终止了        System.out.println(&quot;CharacterEncodingFilter执行后&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;CharacterEncodingFilter 销毁&quot;);    &#125;&#125;\nindex.html\n12&lt;a href=&quot;/WebLearning/servlet/show&quot;&gt;点击链接(有过滤器)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/WebLearning/show&quot;&gt;点击链接(无过滤器)&lt;/a&gt;\n监听器在线人数\n123456789101112131415161718192021222324252627282930@WebListenerpublic class OnlineCountListener implements HttpSessionListener &#123;    // 创建Session监听, 创建成功会触发    @Override    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;        System.out.println(&quot;session 创建&quot;);        ServletContext context = httpSessionEvent.getSession().getServletContext();        Integer onlineCount = (Integer) context.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount=new Integer(1);        &#125;else&#123;            onlineCount+=1;        &#125;        context.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    // 销毁Session监听, 销毁会触发    @Override    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;        System.out.println(&quot;session 销毁&quot;);        ServletContext context = httpSessionEvent.getSession().getServletContext();        Integer onlineCount = (Integer) context.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount=new Integer(0);        &#125;else&#123;            onlineCount-=1;        &#125;        context.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;&#125;\n过滤器实现权限控制\n通过 session 标记用户权限, 使用过滤器过滤\n\nindex.jsp\n1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;首页&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;默认是 tom&lt;/p&gt;    &lt;!--action=&quot;login&quot;表示当前项目的login--&gt;    &lt;form method=&quot;post&quot; action=&quot;login&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt;      &lt;input type=&quot;submit&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\nerror.jsp\n12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;error&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;错误页面&lt;/h1&gt;    &lt;p&gt;      &lt;a href=&quot;index.jsp&quot;&gt;返回登录页面&lt;/a&gt;    &lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\nsys/success.jsp\n1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;成功&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;登陆成功&lt;/h1&gt;    &lt;p&gt;&lt;a href=&quot;../logout&quot;&gt;注销&lt;/a&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\nLoginServlet.java\n1234567891011121314151617181920@WebServlet(&quot;/login&quot;)public class LoginServlet  extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doGet(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;LoginServlet.java doGet&quot;);        String username = req.getParameter(&quot;username&quot;);        if(&quot;tom&quot;.equals(username))&#123;            // 登陆成功写入 Session 属性            req.getSession().setAttribute(&quot;USER_SESSION&quot;,req.getSession().getId());            resp.sendRedirect(&quot;sys/success.jsp&quot;);        &#125;else&#123;            resp.sendRedirect(&quot;error.jsp&quot;);        &#125;    &#125;&#125;\nLogoutServlet.java\n1234567891011121314151617@WebServlet(&quot;/logout&quot;)public class LogoutServlet  extends HttpServlet&#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;LogoutServlet.java doGet&quot;);        Object user_session = req.getSession().getAttribute(&quot;USER_SESSION&quot;);        if (user_session != null) &#123;            req.getSession().removeAttribute(&quot;USER_SESSION&quot;);            resp.sendRedirect(&quot;index.jsp&quot;);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doPost(req, resp);    &#125;&#125;\nSysFilter.java\n1234567891011121314151617// 过滤 sys 下的请求@WebFilter(&quot;/sys/*&quot;)public class SysFilter  extends HttpFilter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;SysFilter.java doFilter&quot;);        HttpServletRequest req  = (HttpServletRequest) request;        HttpServletResponse resp = (HttpServletResponse) response;        // 没有这 Session 属性(权限)        if(req.getSession().getAttribute(&quot;USER_SESSION&quot;)==null)&#123;            // 当前路径在 sys            resp.sendRedirect(&quot;../error.jsp&quot;);        &#125;        chain.doFilter(request, response);    &#125;&#125;","plink":"https://mvbbb.github.io/oz6abw/"},{"title":"反射与注解","date":"2020-11-09T06:48:54.000Z","date_formatted":{"ll":"Nov 9, 2020","L":"11/09/2020","MM-DD":"11-09"},"updated":"2021-02-03T04:20:59.325Z","content":"获取类加载器\n12345678910111213141516171819202122232425262728class Main&#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        // 获取系统加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        // 获取系统加载器的父类加载器-&gt;扩展加载器        ClassLoader parent = systemClassLoader.getParent();        System.out.println(parent);        // 获取扩展加载器的父类加载器-&gt;根加载器        ClassLoader parent1 = parent.getParent();        System.out.println(parent1);        // 获取当前类的加载器名        ClassLoader classLoader = Class.forName(&quot;Main&quot;).getClassLoader();        System.out.println(getClassLoaderName(classLoader));        // 获取JDK类的加载器名        System.out.println(getClassLoaderName(Class.forName(&quot;java.lang.Object&quot;).getClassLoader()));    &#125;    public static String getClassLoaderName(ClassLoader cla)&#123;        if(cla==ClassLoader.getSystemClassLoader())&#123;            return &quot;系统类加载器&quot;;        &#125;else if(cla==ClassLoader.getSystemClassLoader().getParent())&#123;            return &quot;扩展加载器&quot;;        &#125;else            return &quot;根加载器&quot;;    &#125;&#125;\n反射获取类属性\n1234567891011121314151617181920212223242526272829303132333435public class Main&#123;    public static void main(String[] args) throws Exception&#123;        Class&lt;?&gt; cl = Class.forName(&quot;User&quot;);        User user = (User) cl.newInstance();        // 获取类名: User        System.out.println(cl.getName());        // 获取类属性        Field name = cl.getDeclaredField(&quot;name&quot;);        name.setAccessible(true);        name.set(user,&quot;daming&quot;);        System.out.println(user); // User&#123;name=&#x27;daming&#x27;, age=0&#125;        // 类方法获取        Method userMethod = cl.getMethod(&quot;userMethod&quot;);        userMethod.invoke(user);  // 用户方法    &#125;&#125;class User&#123;    private String name;    private int age;    public void userMethod()&#123;        System.out.println(&quot;用户方法&quot;);    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n反射调用构造方法\n12345678910111213141516171819202122232425262728293031323334public class Main&#123;    public static void main(String[] args) throws Exception &#123;        Class cl=Class.forName(&quot;User&quot;);        User usr=(User)cl.newInstance();  // 调用无参构造器        System.out.println(usr);  // User&#123;name=&#x27;null&#x27;, age=0&#125;        // 通过指定构造器构造对象        Constructor constructor = cl.getDeclaredConstructor(String.class, int.class);        User usr2= (User) constructor.newInstance(&quot;daming&quot;, 12);        System.out.println(usr2); // User&#123;name=&#x27;null&#x27;, age=0&#125;    &#125;&#125;class User&#123;    private String name;    private int age;    public User() &#123;    &#125;    public User(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n反射获取泛型信息\n1234567891011121314151617181920212223242526272829303132333435363738public class Test &#123;    public List&lt;Integer&gt; test01(Map&lt;String,Integer&gt; mao, List&lt;String&gt; list)&#123;        System.out.println(&quot;test01&quot;);        return null;    &#125;    public static void main(String[] args) throws Exception &#123;        Method method = Test.class.getMethod(&quot;test01&quot;, Map.class, List.class);        // 获取方法参数的泛型信息        Type[] genericParameterTypes = method.getGenericParameterTypes();        for (Type genericParameterType : genericParameterTypes) &#123;            System.out.println(&quot;#&quot;+genericParameterType);            // 获取泛型的参数类型            if(genericParameterType instanceof ParameterizedType)&#123;                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();                for (Type actualTypeArgument : actualTypeArguments) &#123;                    System.out.print(actualTypeArgument+&quot;   &quot;);                &#125;            &#125;            System.out.println(&quot;\\n&quot;);        &#125;        /*        #java.util.Map&lt;java.lang.String, java.lang.Integer&gt;        #java.util.List&lt;java.lang.String&gt;         */        // 获取方法返回值的泛型信息        Type genericReturnType = method.getGenericReturnType();        System.out.println(genericReturnType);  // java.util.List&lt;java.lang.Integer&gt;        if(genericReturnType instanceof ParameterizedType)&#123;            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();            for (Type actualTypeArgument : actualTypeArguments) &#123;                System.out.print(actualTypeArgument+&quot;   &quot;);            &#125;        &#125;    &#125;&#125;\n通过反射读取注解\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class Main&#123;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; cl = Class.forName(&quot;Student&quot;);        // 通过反射获得注解        Annotation[] annotations = cl.getAnnotations();        for (Annotation annotation : annotations) &#123;            System.out.println(annotation);  // @TableAnnotation(value=&quot;du_student&quot;)        &#125;        // 获得注解的value        TableAnnotation tableAnnotation = (TableAnnotation)cl.getAnnotation(TableAnnotation.class);        String value =  tableAnnotation.value();        System.out.println(value); // du_student        // 获得指定属性(字段)的值        Field name = cl.getDeclaredField(&quot;name&quot;);        FieldAnnotation annotation = name.getAnnotation(FieldAnnotation.class);        System.out.println(annotation.columnName());  // db_name        System.out.println(annotation.type());  // varchar        System.out.println(annotation.length());  // 3    &#125;&#125;// 类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableAnnotation&#123;    String value();&#125;// 属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldAnnotation&#123;    String columnName();    String type();    int length();&#125;@TableAnnotation(&quot;db_student&quot;)class Student&#123;    @FieldAnnotation(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length=10)    private int id;    @FieldAnnotation(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length=10)    private int age;    @FieldAnnotation(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length=3)    private String name;    public Student() &#123;    &#125;    public Student(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;","plink":"https://mvbbb.github.io/ptidvw/"},{"title":"近期规划-碎碎念","date":"2020-11-07T08:59:27.000Z","date_formatted":{"ll":"Nov 7, 2020","L":"11/07/2020","MM-DD":"11-07"},"updated":"2021-02-03T04:20:59.349Z","content":"要点记录\n\n操作系统\nJavaSe\nJavaWeb\n\nAjax\nBootstrap\n\n\n计算机网络\n大学物理\n英语 6 级\n算法\nSQL 练习\n线性代数\n\n安排安排\n\n重点先解决操作系统, 重点是分页和分段的相关计算, 以及**PV 大题, **由于 IO 和文件系统学校不讲就暂时先放一放\n然后是计算机网络, 比较重要, 还没搞清楚学校的教学计划, 究竟是像操作系统那样的枯燥知识点的堆砌还是啥的.\n大学物理上课就没听懂过, 想拖一拖, 但是又害怕挂科… 又懒得学.\n英语六级考前一周突击一下, 做几套真题, 上次差一点点就过了, 可惜了, 之前还想的是大一就把 4/6 级搞定的, 可是因为疫情原因, 大一下不能参加 6 级考试 到了现在, 英语水平直线下降, 难过.\n线性代数, 大一上的时候学了, 现在他们开课要学线代, 我是忘得差不多了, 再跟着学一次(有时间的话)\nSQL 练习, 上课的时候没事就练一下, 生疏了可不好\n算法算法算法, 很重要, 我知道, Take Action please!!!\nJavaWeb, 不想学理论专业课的时候就学他, 不急, 寒假的时候再把重点放在他身上\n\nOne More thing\n… Better not to say…\n\n推荐文章Bye! My 2020刷题!刷题!想学算法博客配置修改EmotionCamera","plink":"https://mvbbb.github.io/gmx84f/"},{"title":"Linux服务器安装 MySql 8.0并配置远程连接","date":"2020-11-05T13:04:14.000Z","date_formatted":{"ll":"Nov 5, 2020","L":"11/05/2020","MM-DD":"11-05"},"updated":"2021-02-03T04:20:59.377Z","content":"配置了一个下午, 终于配置成功了, 决定把今天遇到的坑都写下来\n\n\n教程\n只针对 Mysql 8, centos7/Ubuntu20\n1 . 使用宝塔面板傻瓜式安装 MySql8.0\n2 . 在宝塔-安全处发行 3306 端口, 并且在服务器厂商处放行 3306 端口\n\n\n\n\n3 . 修改配置, 可以直接在宝塔 Mysql 进行配置修改, 在 [mysqld] 下面添加 skip-grant-tables 跳过安全检查. 重启服务器.\n4 . 在云主机提供的终端进行以下命令操作\n\n5 . 登录 Mysql , 修改 root 用户的远程访问权限并修改密码\n1234567891011121314151617# 输入之后直接回车, 默认没有密码mysql -u root# 使用 Mysql 数据库use mysql;# 查看用户访问端口. root 的host是 localhost, 只允许本地访问, 不允许远程访问, 如果没有root账户需要手动添加, 查看文末链接select user,host from user;# 修改访问端口update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;# 刷新服务配置项FLUSH PRIVILEGES;# 再次查看 root 的host, 发现变成了 %select user,host from user;# 修改 root 用户的密码, 如果出现因为处于 &quot;--skip-grant-tables&quot; 模式而产生的限制, 先执行一次 FLUSH PRIVILEGES;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY &#x27;新密码&#x27;;# 退出, 将 &quot;--skip-grant-tables&quot; 属性注释了vi /etc/my.cnf\n6 . 测试新密码是否可以登录\n1mysql -uroot -p密码\n7 . 重启 MySQL\n12service mysql restartservice\n8 . 在本机 cmd 测试是否可以远程登录\n1mysql -h&lt;主机公网IP&gt; -uroot -p&lt;新密码&gt;\n9 . 之后就可以使用远程连接工具来连接服务器了 Navicat 之类的\n坑与细节\n看了别的教程, 觉得不同的 MySql 版本之间的差异还是挺大的, 许多方法在不同的 Mysql 版本中不兼容.\n坑如下:\n\n使用服务器终端输入 mysql -u root 之后显示 PermissionDenied 认证失败\n解决方案: 在 /etc/my.cnf 下的 [mysqld] 添加一行 --skip-grant-tables\n可以在服务器终端成功登录, 关闭防火墙也没用, 无法在远程登录, 执行netstat -an | grep 3306 或者 lsof -i :3306 没有反应, 3306 端口没有被占用\n出现这个情况是因为现在 Mysql 处于 ‘skip-grant-tables’ 模式\n远程连接报错 ERROR 2003 (HY000): Can't connect to MySQL server on\n按照别的教程大多都是到配置文件注释 bind-address, 但是在 mysql 8 中已经没有这个配置了. 其实主要就是 Mysql 处于 --skip-grant-tables 模式, 按照上面的教程步骤来\n有的教程使用 UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root'; 来更新密码, MySql 报语法错误\n首先 Mysql8 的密码字段名不是 password, 而是 mysql_native_password .其次不是使用的 password 函数. 更改密码的命令应该使用\n\n1ALTER USER &#x27;test&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY &#x27;新密码&#x27;;\n参考:\nNavicat 连接远程 MySQL8.0 数据库\nLinux 下 mysql 服务存在，但是 3306 端口监听不存在，远程连接不上\nMysql 中 root 账户丢失\n","plink":"https://mvbbb.github.io/sb74kg/"},{"title":"内存管理","date":"2020-10-21T05:51:37.000Z","date_formatted":{"ll":"Oct 21, 2020","L":"10/21/2020","MM-DD":"10-21"},"updated":"2021-02-03T04:20:59.433Z","content":"内存管理概念\n覆盖, 交换, 连续分配算法\n工作集: 某段时间间隔内, 实际访问的页面的集合\n\n针对一个页表\n逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成\n物理地址: 具体的物理地址.\n地址结构: 页表号+页内偏移量\n页面/页/页框: 内存中的一小片\n页面大小: 内存中一小片的大小\n页表: 用于链接进程地址和实际物理地址\n页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中实际的物理地址\n页表项大小: 页面大小/页表项大小=页表项个数\n页号: 页表项的编号, 从 0 开始\n页内偏移量: 在一个页面内的偏移量, 最大值是页面大小\n页表寄存器:   记录页表的起始长度和页表的大小\n快表: 相联存储器, 记录访问过的页表号和内存号, 加快下次访问速度\n针对多级页表\n一级页表: 记录二级页表在内存中的内存块号\n二级页表: 记录下一级页表在内存中的内存块号, 如果本身是最后一级页表, 就是记录的所需内存块号\n一级/二级页表: 特指两级页表中, 称链接进程逻辑地址的那个页表为一级页表. 采用了多级页表之后, 逻辑地址结构也需要对应的进行修改, 原来只需要找到在一个页表中的某个页表号, 原来使用一个坐标就能定位, 现在者需要多个. 以二级页表为例, 逻辑地址结构修改为: 一级页号+二级页号+页内偏移\n采用多级页表机制, 各级页表大小不能超过一个页面\n分段\n逻辑地址: 段号(前 16 位)+段内地址(后 16 位)\n段号的位数决定了每个进程最多可以分几个端\n段内地址位数决定了每个端的最大长度是多少\n段表: 段号, 段长, 基址\n段名: 在低级语言中, 进程被分为多个段, 可以为他们取单独的名称. 隐含的, 不占存储空间\n段表项: 各个段表项的长度是相同的\n段表长度: 段表项的个数\n基址: 物理地址的开始地址\n段长: 该段号对应的实际长度, 与页不同, 它的大小不固定, 在段内地址的合法性校验中会用到.\n段页式管理\n逻辑地址: 段号(前 16 位)+页号(中间 4 位)+页内偏移量(后 12 位)\n段号的位数决定了每个进程最多可以分几个段\n页号的位数决定了每个段最多有多少页\n页内偏移量决定了页面的大小, 内存块的大小是多少\n\n虚拟存储概念\n虚拟内存的最大容量是由计算机的地址结构确定的\n虚拟内存的实际容量 = min(内存+外存, CPU 的寻址范围)\n请求调页: 将内存中缺失的页面调入内存\n页面置换: 将暂时用不到的页面调出内存\n请求分页存储的页表: 内存块号+状态位(是否已经调入内存)+访问字段(该页面被访问过几次/记录上一次访问这个页面的时间, 用于判断是否需要调出内存)+修改位(自从调入是否被修改过)+外存地址\n改进型时钟置换算法: 优先考虑没有访问过的页面, 如果都被访问过, 就优先访问没有被修改过的, 如果都被修改过. 就选择最近访问过, 但是没有修改的, 最其次选择访问过而且被修改过的.\n\n相关问题\n为什么分页存储的地址空间是一维的，而分段存储的地址是二维的?\n短号和页号的来历是不同的，段号是程序员自己定义的，每个段都是有特定含义的，因此不同段的大小不同，代表的意义也不相同，因此要想找到某个数据或指令，需要指定段号和位移两个变量。而页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此是一维的。\n一维或者二维是相对于程序员来讲的\n\n转载自 https://blog.csdn.net/xiaotai1234/article/details/107427547\n\n\n页目录号 = (LA&gt;&gt;22)&amp;1111111111, 页表索引 = (LA&gt;&gt;12)&amp;1111111111\n页式存储中页表记录的是内存块号, 段式存储中记录的是内存始址\n页面的大小 = 2^(逻辑地址的长度)\n推荐文章经典进程同步问题","plink":"https://mvbbb.github.io/ldcb18/"},{"title":"经典进程同步问题","date":"2020-10-14T13:41:43.000Z","date_formatted":{"ll":"Oct 14, 2020","L":"10/14/2020","MM-DD":"10-14"},"updated":"2021-02-03T04:20:59.525Z","content":"一些比较经典的, 书上的进程同步问题\n总结的解题思路:\n\n画图理解题目\n判断题目类型\n分析进程数目, 填写进程模板\n补充基本代码\n补充 PV 代码\n检查调整代码\n\n\n不同线程之间的同步问题\n由于不同线程之间存在异步性, 两个线程的语句执行先后顺序无法确定.\n使用信号量机制来实现不同线程之间的同步问题\n\n以此为延申, 如何实现拓扑排序\n\n注意在线程同步中信号量初值为 0, 但是在线程互斥中信号量初值为 1\n生产者-消费者问题\n分析\n共享变量为缓存池里面的产品数\n缓冲区满, 生产者必须等待. 缓冲区空, 消费者必须等待\n因为缓冲区的数量是临界资源, 只使用一个互斥变量来实现线程互斥如何?\n12345678910111213141516171819semaphore n = 5;semaphore mutex=1;producer ()&#123;    do&#123;        wait(mutex);        signal(n);        // produce        signal(mutex);    &#125;while(true);&#125;consumer()&#123;    do&#123;        wait(mutex);        wait(n);        // consume        signal(mutex);    &#125;while(true);&#125;\n这个代码存在很严重的问题. 假设只有一个 consumer 进程先启动, 他顺利执行到 consume 操作. 但是此时的缓冲区中还没有商品.\n我们对此进行分析一下.\n\n如果缓冲区满，生产者是不能生产的，所以生产者进程受到消费者进程的制约；\n如果缓冲区空，消费者是不能消费的，所以消费者进程受到生产者进程的制约。\n\n所以 P/C 问题不仅仅是线程互斥, 还包含了线程同步, 线程同步仅仅使用一个信号量是不够的.\n因此我们需要额外设置两个信号量来实现线程的同步问题.\n生产者在乎的是剩余空间 empty. 消费者在乎的是占用空间 full.\n生产者在生产商品之前应该 P(empty) , 消费者在消费商品之前应该 P(full).\n\n1234567891011121314151617181920212223semaphore mutex = 1;semaphore empty = n;semaphore full = 0;producer()&#123;    do&#123;        wait(empty);  // P消耗一个空闲缓冲区        wait(mutex);        // produce        signal(mutex);        signal(full);  // V增加一个产品    &#125;while(true);&#125;consumer()&#123;    do&#123;        wait(full);  // P消耗一个产品, 非缓冲区        wait(mutex);        // consume        signal(mutex);        signal(empty); // V增加一个空闲缓冲区    &#125;while(true);&#125;\n是否可以交换 producer 或者 consumer 中的两个 P 操作呢?\n我们交换 producer 里面的两个 P 操作\n123// producerwait(mutex);wait(empty);  // P消耗一个空闲缓冲区\n假设此时缓冲区为满, empty = 0, full=n;\nproducer 执行 P(mutex), mutex 变为 0, 执行 P(empty), 这个时候会被阻塞.\n现在切换回 consumer 进程, 执行 wait(full) 没有问题, 执行 wait(mutex) 会被阻塞. 这样就会出现线程死锁.\n因此实现互斥的 P 操作要在实现 同步的 P 操作之后执行\n但是 V 操作的执行顺序不会导致线程.\n套路\n\n分析题目题型: 容器大小固定, 为 P/C 问题\n分析进程数量: 不同个体对应不同的进程\n分析每个进程关心的: 消费者只关心占用空间, 生产者只关心剩余空间\n填写进程基本操作\n补充 PV 代码\n\n哲学家进餐问题\n\n\nhttps://www.bilibili.com/video/BV1YE411D7nH?p=27\n\n分析\n临界资源: 筷子\n对哲学家进行编号, 第 i 位哲学家的活动可以描述为\n123456789101112131415semaphore chopstick[5]=&#123;1,1,1,1,1&#125;; // 筷子的信号量Pi()&#123;    do&#123;        wait(chopstick[i]);        wait(chopstick[(i+1)%5]); // 对左右筷子互斥访问        ////        //eat        ////        signal(chopstick[i]);        signal(chopstick[(i+1)%5]); // 释放        ////        //think        ////    &#125;while(true);&#125;\n但是这样会导致一个问题, 哲学家们可能会同时拿起左边的筷子, 在去拿右边的筷子时会发生阻塞\n解决方案\n\n最多允许四个哲学家同时拿左边的筷子\n只有当哲学家左右两边的筷子均可以使用时才允许拿筷子\n奇数哲学家先拿左边, 再拿右边的筷子. 偶数哲学家相反\n\n方案 1\n12345678910111213semaphore chopstick[5]=&#123;1,1,1,1,1&#125;; // 筷子的信号量semaphore r=4; // 只允许4个哲学家进餐Pi()&#123;    do&#123;        wait(r);        wait(chopstick[i]);        wait(chopstick[(i+1)%5]);        //eat        signal(chopstick[(i+1)%5]);        signal(chopstick[i]);        signal(r);    &#125;while(true);&#125;\n获得信号量 r 的哲学家最多只有 4 个\n最少有一个哲学家可以 eat, 使用完之后释放两只筷子, 不会出现死锁和饿死\n方案 2\n123456789101112131415semaphore chopstick[5]=&#123;1,1,1,1,1&#125;; // 筷子的信号量semaphore mutex=1; // 互斥访问变量Pi()&#123;    do&#123;        wait(mutex);        wait(chopstick[i]);        wait(chopstick[(i+1)%5]); //*        signal(mutex);        // eat        signal(chopstick);        signal(chopstick[(i+1)%5]);        // think    &#125;while(true);&#125;\n使用一个互斥变量实现线程同步, 但是, 这其实也不是一个完美的方案\n假如一个哲学家 x 拿起了左右两边的筷子, 他右边的哲学家 y 拿起了他左边的筷子, 想去拿右边的筷子时会发生阻塞, 阻塞在 * 位置. 这个情况下只能等 x 放下了 x 左边的筷子, y 才能继续进行.\n不过比较好的是, 这个方案并不会产生死锁的问题\n方案 3\n123456789101112131415semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;Pi()&#123;    while(1)&#123;        if(i%2！=0)&#123;//奇数号哲学家            wait(chopstick[i]);//拿左边的            wait(chopstick[(i+1)%5]);//右边的        &#125;else&#123;//偶数号哲学家            wait(chopstick[(i+1)%5]);//右边的            wait(chopstick[i]);//左边的        &#125;        // eat        signal(chopstick[i]);//释放筷子资源        signal(chopstick[(i+1)%5]);    &#125;&#125;\n读者-写者问题\n要求:\n\n可以多个读者同时读\n但是不允许多个写者同时写, 只允许一个写者写\n不允许在写的时候读, 也不能有新的写者来写\n写者执行写之前, 不应该有读者或写者在操作\n\n共享数据是文件\n分析\n两类进程: 读, 写者进程\n**互斥关系: **1. 读进程-写进程 2. 写进程-写进程\n写进程与其他进程都互斥. 首先, 写进程与写进程之间 需要一个信号量 rw, 在写者操作共享文件前后加上 PV 操作\n其次, 读进程与写进程也互斥, 因此也需要 PV 操作. 但是如果一个读者在读取共享文件之前进行了 P(rw) 操作, 会导致其他读者无法读取. 怎么解决?\n**使用一个 count 变量来解决, 记录当前有多少读进程. **\n假设刚开始 count = 0 , 进行 P(rw) 保证不会有写进程参与进来, 之后 count++, 说明现在有一个读进程.\n此时有另外一个读进程参与进来, 由于 count!=0, 那么他就不会进行 P(rw) 操作, 而是直接 count++. 这样我们就解决了读者进程之间的非互斥执行问题\n12345678910111213141516171819202122semaphore rw=1; // 对文件的互斥访问int count = 0; // 记录当前读进程数reader()&#123;    do&#123;        if(count==0) // 如果当前没有读者            wait(rw);        count++;        // read file        count--;        if(count==0) // 如果当前没有读者            signal(rw);    &#125;while(true);&#125;writer()&#123;    do&#123;        wait(rw);        // write file        signal(rw);    &#125;while(true);&#125;\n还存在一个问题, count 变量是共享变量, 设想这样一种情况, count=0 时, 读者 1 if 判断执行, 刚要执行 P(rw) 时, count 现在还是 0, 与此同时另外一位读者也通过了 if 判断. 那么, 在读者一获得了 rw 权限之后, 读者 2 就会被阻塞.\n还需要一个互斥变量来保证一气呵成地操作 count 变量\n1234567891011121314151617181920212223242526272829semaphore rw=1; // 对文件的互斥访问int count = 0; // 记录当前读进程数semaphore mutex = 1; // 对count 变量的互斥访问reader()&#123;    do&#123;        wait(mutex);        if(count==0) // 如果当前没有读者            wait(rw);        count++;        signal(mutex);        // read file        wait(mutex);        count--;        if(count==0) // 如果当前没有读者            signal(rw);        signal(mutex);    &#125;while(true);&#125;writer()&#123;    do&#123;        wait(rw);        // write file        signal(rw);    &#125;while(true);&#125;\n套路\n写者关心文件是否被占用.\n**读者团: **\n\n第一个读者关心文件是否被占有, 未被占有就占用.\n中间读者只增加读者团人数.\n最后一个读者释放文件.\n\n设置一个信号量表示资源是否被占有, 使用另外一个信号量表示读者团中读者的数量.\n特征: 资源占用, 团体性\n推荐文章内存管理","plink":"https://mvbbb.github.io/ognzg7/"},{"title":"洛谷【搜索】暴力专项训练","date":"2020-10-10T08:22:11.000Z","date_formatted":{"ll":"Oct 10, 2020","L":"10/10/2020","MM-DD":"10-10"},"updated":"2021-02-03T04:20:59.549Z","content":"题集链接\nP1331 海战\n\nhttps://www.luogu.com.cn/problem/P1331\n\n1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;const int maxn= 1010;const int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;char maze[maxn][maxn];int R,C;void dfs(int x,int y)&#123;    maze[x][y]=&#x27;.&#x27;;    for(int i=0;i&lt;4;i++)&#123;        int nx=x+dx[i];        int ny=y+dy[i];        if(nx&gt;=0&amp;&amp;nx&lt;R&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;C&amp;&amp;maze[nx][ny]==&#x27;#&#x27;)&#123;            dfs(nx,ny);        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;R&gt;&gt;C;    for(int i=0;i&lt;R;i++)&#123;        for(int j=0;j&lt;C;j++)&#123;            cin&gt;&gt;maze[i][j];        &#125;    &#125;    int res=0;    for(int i=0;i&lt;R;i++)&#123;        for(int j=0;j&lt;C;j++)&#123;            if(maze[i][j]==&#x27;#&#x27;)&#123;                res++;                dfs(i,j);            &#125;        &#125;    &#125;    printf(&quot;There are %d ships.&quot;,res);    return 0;&#125;\n\n后优化\nP1596 [USACO10OCT]Lake Counting S\n\nhttps://www.luogu.com.cn/problem/P1596\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; P; //x,y坐标const int maxn=110;int n,m;char maze[maxn][maxn];void bfs(int i,int j)&#123;    queue&lt;P&gt; q;    q.push(P(i,j));    maze[i][j]=&#x27;.&#x27;;    while(q.size())&#123;        P p=q.front(); q.pop();        int x=p.first,y=p.second;        for(int dx=-1;dx&lt;=1;dx++)&#123;            for(int dy=-1;dy&lt;=1;dy++)&#123;                int nx=x+dx;                int ny=y+dy;                if(maze[nx][ny]==&#x27;W&#x27;)&#123;                    maze[nx][ny]=&#x27;.&#x27;;                    q.push(P(nx,ny));                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;maze[i][j];        &#125;    &#125;    int ans=0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(maze[i][j]==&#x27;W&#x27;)&#123;                ans++;                bfs(i,j);            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n\nP1219 [USACO1.5]八皇后 Checker Challenge\n\nhttps://www.luogu.com.cn/problem/P1219\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=15;int n,res;int cols[maxn];int diag1[maxn*2];int diag2[maxn*2];char board[maxn][maxn];bool isOk(int row_index,int col_index)&#123;    return !cols[col_index]&amp;&amp;!diag1[col_index+row_index]&amp;&amp;!diag2[row_index-col_index+n];&#125;void update(int row_index,int col_index,bool to)&#123;    cols[col_index]=to;    diag1[col_index+row_index]=to;    diag2[row_index-col_index+n]=to;    board[row_index][col_index]=to?&#x27;Q&#x27;:&#x27;.&#x27;;&#125;void print_board()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(board[i][j]==&#x27;Q&#x27;)                cout&lt;&lt;j&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;void solve(int row_index)&#123;    if(row_index==n+1)&#123;        res++;        if(res&lt;=3)&#123;            print_board();        &#125;        return ;    &#125;    for(int col_index=1;col_index&lt;=n;col_index++)&#123;        if(isOk(row_index,col_index))&#123;            update(row_index,col_index,true);            solve(row_index+1);            update(row_index,col_index,false);        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    memset(board,&#x27;.&#x27;,sizeof(board));    solve(1);    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;\nP1162 填涂颜色\n\nhttps://www.luogu.com.cn/problem/P1162\n\n使用 bfs, 要点: 对于某个 0, 只要他不属于边界 0 的连通量内, 他就可以变成 2\n我的写法:\n先 bfs 遍历边界 0, 使用标记数组标记连通分量内的 0.\n在遍历非边界位置, 遇到 0, 判断他是否已经被标记数组标记, 没有的话开始从这儿搜索,\n第二种思路和第一种思路类似: 将所有的 0 变成 2, 之后将边界的 2 变为 0, 之后我们可以额外在外面加一圈 2, 这样边界的 2 就会形成一个连通分量, 减少查询次数\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;const int maxn=35;const int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;int n;int board[maxn][maxn];// 开始搜索的坐标  搜索的对象 变成什么void bfs(int i,int j,int which, int to)&#123;    queue&lt;P&gt; q;    q.push(P(i,j));    board[i][j]=to;/////    while(q.size())&#123;        P p=q.front(); q.pop();        int x=p.first,y=p.second;        for(int i=0;i&lt;4;i++)&#123;            int nx=x+dx[i],ny=y+dy[i];            // 注意这里要扩大搜索范围, 因为我们多围了圈            if(nx&gt;=0&amp;&amp;ny&gt;=0&amp;&amp;nx&lt;=n+1&amp;&amp;ny&lt;=n+1&amp;&amp;board[nx][ny]==which)&#123;                board[nx][ny]=to;                q.push(P(nx,ny));            &#125;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cin&gt;&gt;board[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(board[i][j]==0)&#123;                // 把0全部变成2                bfs(i,j,0,2);            &#125;        &#125;    &#125;    // 把边界的2的连通分量全部变成0    // 因为我们多围了一圈, 所以边界的2是属于一个连通分量, 只需要一次搜索    bfs(0,0,2,0);    // 打印输出    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cout&lt;&lt;board[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;\n写出上面这段代码, 再看看别人的, 我才知道自己有多蠢, 第一次搜索把 0 变成 2 简直是弱智操作, 直接在读入的时候把 0 变成 2 不就行了吗.\n推荐文章八皇后问题位运算kuangbin 题单挑战程序设计竞赛-习题Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/lvkhi9/"},{"title":"八皇后问题","date":"2020-10-08T08:53:06.000Z","date_formatted":{"ll":"Oct 8, 2020","L":"10/08/2020","MM-DD":"10-08"},"updated":"2021-02-03T04:20:59.573Z","content":"题目链接 P1219 [USACO1.5]八皇后 Checker Challenge\n力扣题目链接 N Queens\n这是一道经典的搜索题目\n力扣中的 n queens\n暴力朴素解法\n使用到了回溯\n12345678910111213141516backtracking() &#123;    if (终止条件) &#123;        存放结果;    &#125;    for (枚举同一个位置的所有可能性，可以想成节点孩子的数量) &#123;        递归，处理节点;        backtracking();        回溯，撤销处理结果    &#125;&#125;作者：carlsun-2链接：https://leetcode-cn.com/problems/n-queens/solution/51-n-queenshui-su-fa-jing-dian-wen-ti-xiang-jie-by/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();        char[][] board = new char[n][n];        init(board);        helper(board,res,0); // 从第0行开始        return res;    &#125;    private void helper(char[][] board, List&lt;List&lt;String&gt;&gt; res, int rowIndex) &#123;        if(rowIndex==board.length)&#123; // 越过最后一行了            res.add(generate(board));            return;        &#125;        // 遍历这一行的每一个位置        for(int colIndex=0;colIndex&lt;board.length;colIndex++)&#123;            if(isValid(board,rowIndex,colIndex))&#123;                board[rowIndex][colIndex]=&#x27;Q&#x27;;                helper(board, res, rowIndex+1);;                board[rowIndex][colIndex]=&#x27;.&#x27;;            &#125;        &#125;    &#125;    private List&lt;String&gt; generate(char[][] board) &#123;        List&lt;String&gt; list=new ArrayList&lt;&gt;();        for(char[] row:board)&#123;            StringBuffer sb=new StringBuffer();            for(char c:row)                sb.append(c);            list.add(sb.toString());        &#125;        return list;    &#125;    // true 可用, false 不可用    private boolean isValid(char[][] board, int rowIndex, int colIndex) &#123;        for(int i=rowIndex-1;i&gt;=0;i--)&#123;            if(board[i][colIndex]==&#x27;Q&#x27;)                return false;        &#125;        // 主对角线(只包含当前位置的上半部分)        for(int i=rowIndex-1,j=colIndex-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123;            if(board[i][j]==&#x27;Q&#x27;)                return false;        &#125;        // 副对角线(只包含当前位置的上半部分)        for(int i=rowIndex-1,j=colIndex+1;i&gt;=0&amp;&amp;j&lt;board.length;i--,j++)&#123;            if(board[i][j]==&#x27;Q&#x27;)                return false;        &#125;        return true;    &#125;    private void init(char[][] board) &#123;        for(int i=0;i&lt;board.length;i++)&#123;            Arrays.fill(board[i],&#x27;.&#x27;);        &#125;    &#125;&#125;\n使用数组记录\n\n\nhttp://zxi.mytechroad.com/blog/searching/leetcode-51-n-queens/\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        board=vector&lt;string&gt;(n,string(n,&#x27;.&#x27;)); //初始化一个面板        cols=vector&lt;int&gt;(n,0);        diag1=vector&lt;int&gt;(2*n-1,0);        diag2=vector&lt;int&gt;(2*n-1,0);        nqueens(n,0);        return res;    &#125;private:    vector&lt;string&gt; board; // 保存面板    /*第i个位置是否可用, 每次加入皇后都会修改这里的状态*/    vector&lt;int&gt; cols; // 该列是否被占用    vector&lt;int&gt; diag1; // 该对角线是否被占用 (平行于主对角线)    vector&lt;int&gt; diag2; // (偏向于副对角线)    vector&lt;vector&lt;string&gt;&gt; res;    bool isOk(int x,int y,int n)&#123;        return !cols[x]&amp;&amp;!diag1[x+y]&amp;&amp;!diag2[x-y+n-1];    &#125;    /*在board的某个位置加入或者删除皇后都会改变3个状态数组的状态*/    void updateBoard(int x,int y,int n,bool is_put)&#123;        cols[x]=is_put;        diag1[x+y]=is_put;        diag2[x-y+n-1]=is_put;        board[x][y]=is_put?&#x27;Q&#x27;:&#x27;.&#x27;;    &#125;    void nqueens(const int n,const int y)&#123; //大小 行        if(y==n)&#123;            res.push_back(board);            return ;        &#125;        for(int x=0;x&lt;n;x++)&#123;            if(isOk(x,y,n))&#123;                updateBoard(x,y,n,true);                nqueens(n,y+1);                updateBoard(x,y,n,false);            &#125;        &#125;    &#125;&#125;;\n时间复杂度 \n空间复杂度   取决于皇后的数量, 递归调用的层数不会超过 \n使用位运算进行状态压缩\n优点降低了空间复杂度\n\nhttps://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode-solution/\n\n洛谷中的 八皇后\n同力扣, 使用 ‘Q’ 代表该位置有皇后, ‘.’ 代表该位置没有皇后\n洛谷中的下标是从 1 开始的\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=15;int n,res;int cols[maxn];int diag1[maxn*2];int diag2[maxn*2];char board[maxn][maxn];bool isOk(int row_index,int col_index)&#123;    return !cols[col_index]&amp;&amp;!diag1[col_index+row_index]&amp;&amp;!diag2[row_index-col_index+n];&#125;void update(int row_index,int col_index,bool to)&#123;    cols[col_index]=to;    diag1[col_index+row_index]=to;    diag2[row_index-col_index+n]=to;    board[row_index][col_index]=to?&#x27;Q&#x27;:&#x27;.&#x27;;&#125;void print_board()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(board[i][j]==&#x27;Q&#x27;)                cout&lt;&lt;j&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;void solve(int row_index)&#123;    if(row_index==n+1)&#123;        res++;        if(res&lt;=3)&#123;            print_board();        &#125;        return ;    &#125;    for(int col_index=1;col_index&lt;=n;col_index++)&#123;        if(isOk(row_index,col_index))&#123;            update(row_index,col_index,true);            solve(row_index+1);            update(row_index,col_index,false);        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    memset(board,&#x27;.&#x27;,sizeof(board));    solve(1);    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;推荐文章洛谷【搜索】暴力专项训练位运算kuangbin 题单挑战程序设计竞赛-习题Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/ehshi7/"},{"title":"博客文章发布BUG记录","date":"2020-10-08T07:46:28.000Z","date_formatted":{"ll":"Oct 8, 2020","L":"10/08/2020","MM-DD":"10-08"},"updated":"2021-02-03T04:20:59.601Z","content":"因为我是采用的语雀编写文章, 发布之后 , 通过 webhook 触发腾讯云函数执行, 最后通过 coding 构建云端的 hexo 仓库. hexo 仓库通过一个名为 yuque-hexo 的插件以及我的配置文件, 读取我语雀知识库的文档, 并 copy 过去, 然后通过 coding 提供的云主机完成渲染 md, 生成 HTML , 最后发布在部署在 coding 上的另一个静态网站仓库, 最后就呈现在我的网站中了.\n但是最近遇到了一个问题, 在 coding 从语雀读取知识库文档时出现, 最近几天尤为频繁\n\n\n错误信息如下\n\n起初我通过查看语雀 api 文档, 以为是我的认证信息出现了问题, 用户名, 知识库链接, token 等等原因\n\n\n结果并没有解决问题.\n知道仔细的我 (滑稽) 发现了 请求链接 ‘docs’ 后面跟着的诡异字符 ‘upa9py’ , 然后 vscode 搜索 ‘upa9py’, 发现这个是语雀为每一篇文章生成的 slug\n\n到这里我也就明白了, 是这篇文章导致的构建失败.\n对比这篇文章与其他文章的不同, 这篇文章超超超长, 也许是因为这篇文章太长的缘故.\n最后, 我把这篇文章放在了另外一个知识库, 要查看这篇文章也就只能通过语雀查看了\n\nhttps://www.yuque.com/u1296515/zg3mxr/hy3v2n\n\n\n","plink":"https://mvbbb.github.io/lgv9s5/"},{"title":"位运算","date":"2020-10-08T04:34:31.000Z","date_formatted":{"ll":"Oct 8, 2020","L":"10/08/2020","MM-DD":"10-08"},"updated":"2021-02-03T04:20:59.641Z","content":"之前一直放着没学, 现在遇到一道题需要运用到位运算的知识, 也就随便学了一下\nPOJ 3279 Fliptile\n\nBasic\n1234567891011A&lt;&lt;B 结果与 A*pow(2,B) 相同, 不过左移运算速度更快对于 Java 而言 算数右移 &gt;&gt; 原来是符号位是 1 , 右移之后则补 1 , 反之, 则补 0 逻辑右移 &gt;&gt;&gt; 右移之后补 0 , 得到的是一个正数但是在cpp里面 &gt;&gt; 对于无符号数使用的是逻辑右移 对于有符号数使用的是算数右移异或运算是不进位加法如果对应的二进制位不同，结果位为1，否则为0.\n习题 更新二进制位\n\nhttps://www.lintcode.com/problem/update-bits/description\n\n思路: 将 n 的 i~j 的二进制位全部置为 0 , 将 m 串左移 i 位, 之后两个取 **或 **, n 串 i~j 位就全部变成了 m 串的 i~j 位\n考虑如何使 n 串的 i~j 位变成 0, 让其与 一个 i~j 二进制位串全部为 0 的做 且 运算\n但是构造一个这样的串有些困难, 我们可以考虑构造一个 i~j 二进制位串全部为 1 的串, 我们将他叫做 C 串\n所以最后的公式就是 (n&amp;C)|(m&lt;&lt;i)\n那么如何得到这个 C 串呢, 我们知道 -1 的二进制位全部为 1, 长度为 31\n易得 C= (-1&lt;&lt;31-j)&gt;&gt;(31-j+i) 注意要使用逻辑位移\n12345678class Solution &#123;public:    int updateBits(int n, int m, int i, int j) &#123;        u_int16_t  c=(u_int16_t )(-1)&lt;&lt;(31-j);        return (n&amp;(~c&gt;&gt;(31-j+i)))|(m&lt;&lt;i);    &#125;&#125;;\n习题 A+B 问题\n\nhttps://www.lintcode.com/problem/a-b-problem/description\n\n首先异或运算没有解决上一位的进位问题, 我们需要解决进位问题\n什么时候需要进位, 两个串在该位置都为 1 , 我们需要进位问题\n12345678910111213141516class Solution &#123;    /*     * param a: The first integer     * param b: The second integer     * return: The sum of a and b     */    public int aplusb(int a, int b) &#123;        while (b != 0) &#123;            int _a = a ^ b;            int _b = (a &amp; b) &lt;&lt; 1;            a = _a;            b = _b;        &#125;        return a;    &#125;&#125;;\n技巧一: 消去二进制中最右侧的那个 1\n12345x &amp; (x - 1) 用于消去x最后一位的1, 比如x &#x3D; 12, 那么在二进制下就是(1100)2x           &#x3D; 1100x - 1       &#x3D; 1011x &amp; (x - 1) &#x3D; 1000\n应用 1: 判断一个数是否是 2 的幂次\n2 的幂次特点\n\n二进制串中只有 1 个 1\n大于 0\n\n应用二：计算在一个 32 位的整数的二进制表式中有多少个 1.\n不断消去最右边的 1 , 直到为 0, 统计消除次数\n应用三：如果要将整数 A 转换为 B，需要改变多少个 bit 位？\n转化为统计不同位上有多少个位不相同, 检测不相同, 将 AB 做异或\n之后统计位 1 的数量\n技巧二：使用二进制进行子集枚举\n给定一个含 n 个元素的集合, 返回其所有子集\n对于给定集合中的每一个元素, 他是否出现在子集中有两种状态 0/1, 用一个长度为 n 的二进制串来表示\n而长度为 n 的二进制位串对应的 10 进制数为 2 的 n 次方, 也就是 i&lt;&lt;n\n之后考虑如何获得串 P (0~i&lt;&lt;n) 的位状态信息\n我们要判断第 i 位的状态, 将 (1&lt;&lt;i) 与 P 做 且, 结果大于 0 , 证明该位置的二级制位为 1\n\nhttps://leetcode-cn.com/problems/subsets/\n\n123456789101112131415161718class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        int n = nums.size();        for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;            vector&lt;int&gt; t;            for (int i = 0; i &lt; n; ++i) &#123;                if (mask &amp; (1 &lt;&lt; i)) &#123;                    t.push_back(nums[i]);                &#125;            &#125;            ans.push_back(t);        &#125;        return ans;    &#125;&#125;;\n技巧三: 巧用异或运算\na ^ b ^ b = a // 对一个数异或两次等价于没有任何操作！\n应用一：数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数\n所有数做异或, 得到的就是唯一出现一次的数\nMORE\nhttps://www.jiuzhang.com/tutorial/bit-manipulation/84\n其他技巧\n位运算有什么奇技淫巧？ - 力扣（LeetCode）的回答 - 知乎\nhttps://www.zhihu.com/question/38206659/answer/736472332\n推荐文章洛谷【搜索】暴力专项训练八皇后问题kuangbin 题单挑战程序设计竞赛-习题Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/nftmte/"},{"title":"kuangbin 题单","date":"2020-10-07T09:10:05.000Z","date_formatted":{"ll":"Oct 7, 2020","L":"10/07/2020","MM-DD":"10-07"},"updated":"2021-02-03T04:20:59.729Z","content":"\nhttps://vjudge.net/article/752\n\n简单搜索\nPOJ 3984 迷宫问题\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn=100;int maze[6][6];int used[6][6];typedef pair&lt;int,int&gt; P; // 节点坐标P pre[6][6];int dx[4]=&#123;0,1,0,-1&#125;, dy[4]=&#123;1,0,-1,0&#125;;vector&lt;P&gt; v; //save pathvoid bfs()&#123;    queue&lt;P&gt; q;    q.push(P(0,0));    while(q.size())&#123;        P p=q.front(); q.pop();        int x=p.first, y=p.second;        used[x][y]=true;        if(x==4&amp;&amp;y==4)            return ;        for(int i=0;i&lt;4;i++)&#123;            int nx=x+dx[i],ny=y+dy[i];            if(nx&gt;=0&amp;&amp;nx&lt;5&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;5&amp;&amp;!used[nx][ny]&amp;&amp;maze[nx][ny]==0)&#123;                pre[nx][ny]=P(x,y);                q.push(P(nx,ny));            &#125;        &#125;    &#125;&#125;int main()&#123;    for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            cin&gt;&gt;maze[i][j];        &#125;    &#125;    bfs();    P p=pre[4][4];    v.push_back(P(4,4));    do&#123;        v.push_back(p);        p=pre[p.first][p.second];    &#125;while(p.first!=0||p.second!=0);    v.push_back(P(0,0));    reverse(v.begin(),v.end());    for(int i=0;i&lt;v.size();i++)&#123;        cout&lt;&lt;&quot;(&quot;&lt;&lt;v[i].first&lt;&lt;&quot;, &quot;&lt;&lt;v[i].second&lt;&lt;&quot;)&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\nPOJ 2251 Dungeon Master\n找不到为什么一直 tle 的原因\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn=32;int l,r,c;int sx,sy,sz,gx,gy,gz;char dilao[maxn][maxn][maxn];struct node&#123;    int x,y,z,steps;    node(int x,int y,int z,int s):x(x),y(y),z(z),steps(s)&#123;&#125;;&#125;;int dx[6]=&#123;1,-1,0,0,0,0&#125;,dy[6]=&#123;0,0,1,-1,0,0&#125;,dz[6]=&#123;0,0,0,0,1,-1&#125;;int bfs()&#123;    queue&lt;node&gt; que;    que.push(node(sx,sy,sz,0));    while(que.size())&#123;        node n=que.front(); que.pop();        int x=n.x,y=n.y,z=n.z,steps=n.steps;        dilao[x][y][z]=&#x27;#&#x27;;        if(x==gx&amp;&amp;y==gy&amp;&amp;z==gz)            return steps;        for(int i=0;i&lt;6;i++)&#123;            int nx=x+dx[i],ny=y+dy[i],nz=z+dz[i];            if(nx&gt;=0&amp;&amp;nx&lt;l&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;r&amp;&amp;nz&gt;=0&amp;&amp;nz&lt;c&amp;&amp;               (dilao[nx][ny][nz]==&#x27;.&#x27;||dilao[nx][ny][nz]==&#x27;E&#x27;))                que.push(node(nx,ny,nz,steps+1));        &#125;    &#125;    return -1;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c)&#123;        if(l==0&amp;r==0&amp;&amp;c==0) break;        getchar();        for(int i=0;i&lt;l;i++)&#123;            for(int j=0;j&lt;r;j++)&#123;                for(int k=0;k&lt;c;k++)&#123;                    scanf(&quot;%c&quot;,&amp;dilao[i][j][k]);                    if(dilao[i][j][k]==&#x27;S&#x27;)                        sx=i,sy=j,sz=k;                    if(dilao[i][j][k]==&#x27;E&#x27;)                        gx=i,gy=j,gz=k;                &#125;                getchar();            &#125;            getchar();        &#125;        int res=bfs();        if(res!=-1)&#123;            cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;res&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;        &#125;else&#123;            cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;\nHDU 1241 Oil Deposits\n多次 bfs\n注意是 8 个方向\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Example program#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;queue&gt;using namespace std;const int maxn=110;typedef pair&lt;int,int&gt; P;int m,n;char maze[maxn][maxn];void bfs(int x,int y)&#123;    queue&lt;P&gt; que;    que.push(P(x,y));    while(que.size())&#123;        P p=que.front();que.pop();        maze[p.first][p.second]=&#x27;*&#x27;;        for(int dx=-1;dx&lt;=1;dx++)&#123;            for(int dy=-1;dy&lt;=1;dy++)&#123;                int nx=p.first+dx,ny=p.second+dy;                if(nx&gt;=0&amp;&amp;nx&lt;m&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;n&amp;&amp;maze[nx][ny]==&#x27;@&#x27;)&#123;                    que.push(P(nx,ny));                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m&amp;&amp;n)&#123;        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                cin&gt;&gt;maze[i][j];            &#125;        &#125;        int ans=0;        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                if(maze[i][j]==&#x27;@&#x27;)&#123;                    bfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n\n内存超出限制了, 改用 dfs 试试\n1234567891011121314151617181920212223242526272829303132333435363738394041// Example program#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;queue&gt;using namespace std;const int maxn=110;typedef pair&lt;int,int&gt; P;int m,n;char maze[maxn][maxn];void dfs(int x,int y)&#123;    maze[x][y]=&#x27;*&#x27;;    for(int dx=-1;dx&lt;=1;dx++)&#123;        for(int dy=-1;dy&lt;=1;dy++)&#123;            int nx=x+dx,ny=y+dy;            if(nx&gt;=0&amp;&amp;nx&lt;m&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;n&amp;&amp;maze[nx][ny]==&#x27;@&#x27;)                dfs(nx,ny);        &#125;    &#125;&#125;int main()&#123;    while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m&amp;&amp;n)&#123;        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                cin&gt;&gt;maze[i][j];            &#125;        &#125;        int ans=0;        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                if(maze[i][j]==&#x27;@&#x27;)&#123;                    dfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nac 了, 也就只有这种简单的题可以抚慰一下我了\n\n虽然说配张表情包更应景, 但是我没有表情包\n\nPOJ 3278 Catch That Cow\n这应该是一道搜索题\n**BFS 找到的一定是最短路 **细品\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Example program#include &lt;iostream&gt;#include &lt;string.h&gt;#include&lt;queue&gt;using namespace std;const int maxn=100010;const int INF=0x3f3f3f3f;int n,k; // begin endint dis[maxn]; // n 点到其他点的距离void init()&#123;    memset(dis,INF,sizeof(dis));    dis[n]=0;&#125;void bfs()&#123;    queue&lt;int&gt; q;    q.push(n);    while(q.size())&#123;        int t=q.front(); q.pop();        int next[3];        next[0]=t+1;        next[1]=t-1;        next[2]=2*t;        for(int i=0;i&lt;3;i++)&#123;            if(next[i]&gt;=0&amp;&amp;next[i]&lt;maxn)&#123;                int d= dis[next[i]]; // 到这些点的距离                if(d&gt;dis[t]+1)&#123; // 大于一次操作的距离, 证明是第一次到这些点或者有优的方法到达该点                    dis[next[i]]=dis[t]+1; // 更新到这些点的位置的操作次数 是操作数+1                    q.push(next[i]);                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    if(n&gt;k)&#123;        cout&lt;&lt;n-k&lt;&lt;endl;        return 0;    &#125;    init();    bfs();    cout&lt;&lt;dis[k]&lt;&lt;endl;    return 0;&#125;\n**POJ 3279 Fliptile\n给定一个 N*M 格子盘, 翻转格子, 使其全部变成 0 , 翻转一个格子会使周围的格子也翻转. 输出每个位置的格子需要翻转的次数. 如果没有办法全部变成 0 , 输出 “IMPOSSIBLE”\n读懂了, 不会做\n看了看别人的思路:\n一个格子翻转两次是没有意义的, 因此每个格子最多翻转 1 次, 最后要么 1 , 要么 0\n从第一行开始考虑, 第一行的格子决定是否翻转之后, 下面每一个格子是否被翻转的状态都固定下来了.\n也就是第 (i+1,j) 的格子是否需要翻转是由第 (i,j) 的格子的状态决定的, 假如 (i,j)=0, 那么 (i+1,j) 就不能翻转, 翻转次数就为 0 ; 假如 (i,j) =1 , 那么 (i+1,j) 就必须翻转, 翻转次数也就是 1\n假如操作完每一行, 但是最后一行缺不是全为 0 ,那么说明无论怎样翻转都无法得到.\n首先我们要枚举第一行的所有状态\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#define INF 0x3f3f3f3fusing namespace std;int n, m;int map1[35][35];int flip[35][35]; //记录翻转int opt[35][35]; // 记录最优解int Next[5][2] = &#123;0,0,1,0,-1,0,0,1,0,-1&#125;;// 返回[x][y]被翻转后是否为黑色bool isBlack(int x, int y)&#123;    int fliptime = 0;    for(int k = 0; k &lt; 5; ++k)&#123;        int nx = x + Next[k][0];        int ny = y + Next[k][1];        if(nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; nx &lt;= m &amp;&amp; ny &lt;= n)&#123;            fliptime += flip[nx][ny];        &#125;    &#125;    return (map1[x][y] + fliptime) % 2;&#125;// 从第二行开始计算需要反转的次数，如果成功则返回次数int dfs()&#123;    int ret = 0;  // 反转次数    for(int i = 2; i &lt;= m; ++i)        for(int j = 1; j &lt;= n; ++j)            // map1[i-1][j]为黑色则需要反转            if(isBlack(i-1, j))&#123;                flip[i][j] = 1;                ret ++;            &#125;    // 判断最后一行是否全为白色    for(int j = 1; j &lt;= n; ++j)        if(isBlack(m, j))            return -1;    for(int j = 1; j &lt;= n; ++j)        if(flip[1][j]) ret ++;    return ret;&#125;int main()&#123;    while(cin &gt;&gt; m &gt;&gt; n)&#123;        int ans = INF;        memset(map1, 0, sizeof map1);        for(int i = 1; i &lt;= m; ++i)            for(int j = 1; j &lt;= n; ++j)                scanf(&quot;%d&quot;, &amp;map1[i][j]);        for(int i = 0; i &lt; 1 &lt;&lt; n; ++i)&#123;            memset(flip, 0, sizeof flip);            for(int j = 1; j &lt;= n; ++j)                flip[1][j] =  i &gt;&gt; (j-1) &amp; 1;            int temp = dfs();            if(temp &gt; 0)&#123;                if(temp &lt; ans)                    memcpy(opt, flip, sizeof(flip));                ans = min(temp, ans);            &#125;        &#125;        if(ans == INF) puts(&quot;IMPOSSIBLE&quot;);        else&#123;            for(int i = 1; i &lt;= m; ++i)                for(int j = 1; j &lt;= n; ++j)                    printf(&quot;%d%c&quot;, opt[i][j],&quot; \\n&quot;[j == n]);        &#125;    &#125;    return 0;&#125;\n*POJ 1321 棋盘问题\n\nhttps://vjudge.net/problem/POJ-1321\n\n上面那道题花了我很多时间, 而且还没做出来, 结果发现那道题是最后推荐做的, 意思是那道题难度不低, 之前没有发现, 一直耗在上面, 现在来尝试一下这道 “简单” 一点的题\n题意: n*n 的棋盘, 摆放 k 个棋子, 没对棋子不能出现在同一列或者同一行\n不会, 解决这道题之前我先去看看八皇后问题\n好, 看完 八皇后 问题了, 再来看这道题就再简单不过了, 诶 , 不对, 这道题的皇后数不固定, 每一行不一定必须有一个皇后.试着在 n 行生成中 k 行的排列. 枚举以求解\n不过这种解法似乎复杂化了这道题, 我们只需要在递归查找的时候扩大查找范围, 不要局限于一行.\n不过还是没能做出来\n别人都是用深度优先遍历做的, 对于一个节点(棋子), 有两种选择: 左, 不放. 右, 放.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 10;int n, k;char g[N][N];bool st[N];   // 使用st[N]数组表示哪些列已经被占用了int res;int dfs(int u, int s)&#123;    if(s == k) return 1;  // 如果当前棋子数已经满足条件k，说明方案合法，返回1    if(u == n) return 0;  // return -1 // 如果已经走到了第n行，但是没有凑够棋子，表明当前方案不合法，返回0    // 表示这一行可以不放棋子，直接下一行    // 深度优先遍历向左走    int res = dfs(u + 1, s);    // 枚举以下，当前这行中，哪些列可以放棋子    for(int i = 0; i &lt; n; i ++)    &#123;        if(!st[i] &amp;&amp; g[u][i] == &#x27;#&#x27;)        &#123;            // 将当前这列标记一下，表示它已经被用过了            st[i] = true;            // 深度优先遍历 向右走            res += dfs(u + 1, s + 1);            st[i] = false;        &#125;    &#125;    return res;&#125;int main()&#123;    while(cin &gt;&gt; n &gt;&gt; k, n != -1 || k != -1)    &#123;        for(int i = 0; i &lt; n; i ++) cin &gt;&gt; g[i];        cout &lt;&lt; dfs(0, 0) &lt;&lt; endl; // 从第0行开始看，有0个棋子数量的方案数    &#125;    return 0;&#125;\n些许抽象慢慢理解\nPOJ 3414 Pots\n\nhttps://vjudge.net/problem/POJ-3414\n\n题意:\n给定两个锅 1,2, 容量分别为 A B, 有以下操作\n\nFILL(1),FILL(2) 使 锅 1 或者 锅 2 装满水\nDROP(1),DROP(2) 使 锅 1 或者 锅 2 为空\nPOUR(1,2) 把 锅 1 中的水灌入 锅 2. 结束操作之后, 要么 锅 2 满了, 要么 锅 1 为空\n\n找到一个使其中一个锅达到 容量 C 的最小路径\n我的第一思路\n最短路径问题, 采取 bfs\n节点的状态就是 a,b 的余量, 从队列中取出节点之后有 6 种走法, 对于 6 种操作\n由于这道题实在是没什么难度, 写起来还挺麻烦, 我就直接 pass 了\n注意一个技巧, 保存对每个节点的操作使用一个 op 变量就行了, 然后额外使用一个字符串数组来对应.\n最后 print 时使用一个 栈比 vector. reverse 方便\nPOJ 3126 Prime Path\n\nhttps://vjudge.net/problem/POJ-3126\n\n这道题要用到数学的素数知识, 就先去看一看素数的知识\n题意\n给定两个四位素数 a  b，把 a 转换成 b 转换的过程要求每次转换出来的数都是一个 四位素数，而且当前这步的变换所得的素数与前一步得到的素数   只能有一个位不同，而且每步得到的素数都不能重复。\n数据范围在 1-10000 之内, 我们可以直接先把该范围内的素数枚举出来\nUVA 11624 Fire!\n\nhttps://vjudge.net/problem/UVA-11624\n\n最快出去， 使用 bfs\n火是朝 4 个方向蔓延， 但是 J 每次只能走一步\n使用两个队列， 一个用于火， 一个用于 J\n每次火先走， 标记访问过的地方， 之后 J 走， 走火和他自己没有到达过的地方。 可以只用一个标记数组标记\n我感觉我的答案没错, 但是 WA 了\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;struct node&#123;    int x, y, step;    node(int x, int y, int s) :x(x), y(y), step(s)&#123;&#125;;    node()&#123;&#125;;&#125;;const int maxn = 1010;const int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;;int vis[maxn][maxn];int n, c, r;char maze[maxn][maxn];int jx, jy, fx[maxn], fy[maxn], num;int bfs()&#123;    queue&lt;node&gt;q2;    // 每个火源推进去    for (int i = 0; i&lt;num; i++)&#123;        q2.push(node(fx[i], fy[i], 0));        vis[fx[i]][fy[i]] = true;    &#125;    queue&lt;node&gt; q1;    q1.push(node(jx, jy, 0));    vis[jx][jy]=true;    while (q1.size())&#123;        for (int i = 0; i&lt;q2.size(); i++)&#123;            node n = q2.front(); q2.pop();            int x = n.x, y = n.y, step = n.step;            for (int k = 0; k&lt;4; k++)&#123;                int nx = dx[k] + x, ny = dy[k] + y;                if (nx &gt;= 0 &amp;&amp; nx&lt;r&amp;&amp;ny &gt;= 0 &amp;&amp; ny&lt;c&amp;&amp;vis[nx][ny] == false &amp;&amp; maze[nx][ny] != &#x27;#&#x27;)&#123;                    q2.push(node(nx, ny, step + 1));                    vis[nx][ny] = true;                &#125;            &#125;        &#125;        // J 走一步        node n = q1.front(); q1.pop();        int x = n.x, y = n.y, step = n.step;        // retrun        if (x == 0 || x == r - 1 || y == 0 || y == c - 1)&#123;            return step+1;        &#125;        for (int i = 0; i&lt;4; i++) &#123;            int nx = dx[i] + x, ny = dy[i] + y;            if (nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c &amp;&amp; vis[nx][ny] == false &amp;&amp; maze[nx][ny] != &#x27;#&#x27;) &#123;                vis[nx][ny] = true;                q1.push(node(nx, ny, step + 1));            &#125;        &#125;    &#125;    return -1;&#125;int main()&#123;    cin &gt;&gt; n;    while (n--)&#123;        memset(vis, false, sizeof(vis));        num=0;        cin &gt;&gt; r &gt;&gt; c;        for (int i = 0; i&lt;r; i++)&#123;            for (int j = 0; j&lt;c; j++)&#123;                cin &gt;&gt; maze[i][j];                if (maze[i][j] == &#x27;J&#x27;)&#123;                    jx = i; jy = j;                &#125;                if (maze[i][j] == &#x27;F&#x27;)&#123;                    fx[num] = i; fy[num]=j;                    num++;                &#125;            &#125;        &#125;        int res = bfs();        if (res == -1)            cout &lt;&lt; &quot;IMPOSSIBLE&quot;&lt;&lt;endl;        else            cout &lt;&lt; res&lt;&lt;endl;    &#125;    return 0;&#125;\nHDU 2612 Find a way\n\nhttps://cn.vjudge.net/problem/HDU-2612\n\n该题与上一道题不能说不一样\n路径最短 bfs\n两个人同时 bfs , 假如 M 到达一个 KFC 并且 J 已经访问过了, 那么这个店就是他们彼此到达时间最短的店. 这个时候输出较小的 M 的时间\n两个标记数组记录到达该位置的时间/步数\nPOJ 1426 Find The Multiple\n\nhttps://vjudge.net/problem/POJ-1426\n\n给定一个数 n , 输出一个能整除该数的一个数, 要求这个数只能包含 01\n\n暴力枚举: 枚举从 2-&gt;无穷, 直到找到一个数, 他们相乘的倍数只包含 01 (效率极低)\nbfs 枚举所有 01 构成的数, 直到该数为 n 的倍数\n\n1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;typedef  long long ll;ll n;bool flag;void dfs(ll k, int x) //  k 为当前数, x为当前数的长度&#123;\tif (x &gt; 19 || flag == 1)\t\treturn;\telse if (k % n == 0) &#123;\t\tcout &lt;&lt; k &lt;&lt; endl;\t\tflag = 1;\t\treturn;\t&#125;\tdfs(k * 10, x + 1);\tdfs(k * 10 + 1, x + 1);&#125;int main() &#123;\twhile (cin &gt;&gt; n &amp;&amp; n) &#123;\t\tflag = 0;\t\tdfs(1, 1);\t&#125;\treturn 0;&#125;\nFZU 2150 Fire Game\n\nhttps://vjudge.net/problem/FZU-2150\n\n选择 2 个起点（#）代表着火点，每个着火点会向上下左右四个方向蔓延，一秒蔓延一次，问最少多少秒所有的#都能被点燃。\n推荐文章洛谷【搜索】暴力专项训练八皇后问题位运算挑战程序设计竞赛-习题Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/wu5oin/"},{"title":"刷题!刷题!","date":"2020-10-05T13:52:37.000Z","date_formatted":{"ll":"Oct 5, 2020","L":"10/05/2020","MM-DD":"10-05"},"updated":"2021-02-03T04:20:59.741Z","content":"10-5\n\n马马虎虎的把第一章看了, 第二章看了大部分, 不过, 感觉有很大的遗忘, 真的很大.\n距离国庆假期结束还有 6 天, 接下来就得劲的刷题了, 之前的例题也要刷, 课后的习题也要刷. 不会写就背代码. 难搞\n这些天的刷题重点: 穷尽搜索, 基础贪心, 基础 dp, 基础树图, 基础并查集.\n关于第二章的 “数学问题的解题诀窍” 就先放一放, 必须得要回顾之前的内容, 别向前学了.\n明天的话就把书上的例题做一做\n\n\n10-6\n我是傻逼, 不多 bb\n\n把爷看傻了, 他们都说简单,…\n推荐文章Bye! My 2020近期规划-碎碎念想学算法博客配置修改","plink":"https://mvbbb.github.io/taxvu3/"},{"title":"挑战程序设计竞赛-习题","date":"2020-10-04T04:26:00.000Z","date_formatted":{"ll":"Oct 4, 2020","L":"10/04/2020","MM-DD":"10-04"},"updated":"2021-02-03T04:20:59.785Z","content":"希望不要太难\n英文题目看着脑壳痛\n\n第二章\n最基础的&quot;穷竭&quot;搜索\n深度优先搜索\nRed and Black\n\nhttp://poj.org/problem?id=1979\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=30;int res;bool flags[maxn][maxn];char room [maxn][maxn];int w,h;int x,y;int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;void dfs(int x,int y)&#123;    flags[x][y]=true;    res++;    for(int i=0;i&lt;4;i++)&#123;        int nx=x+dx[i],ny=y+dy[i];        if(nx&gt;=0&amp;&amp;nx&lt;h&amp;&amp;ny&gt;=0&amp;&amp;ny&lt; w &amp;&amp;room[nx][ny]==&#x27;.&#x27;&amp;&amp;flags[nx][ny]==false)&#123;            dfs(nx,ny);        &#125;    &#125;&#125;int main()&#123;    while(cin&gt;&gt;w&gt;&gt;h)&#123;        // 读入        if(w==0&amp;&amp;h==0) break;        for(int i=0;i&lt;h;i++)&#123;            for(int j=0;j&lt;w;j++)&#123;                cin&gt;&gt;room[i][j];                if(room[i][j]==&#x27;@&#x27;)&#123;                    x=i;y=j;                &#125;            &#125;        &#125;        // 深度优先搜索        memset(flags, false, sizeof(flags));        res=0;        dfs(x,y);        cout&lt;&lt;res&lt;&lt;endl;    &#125;    return 0;&#125;\n优化方法, 不用 flags 数组, 只需要将访问过的位置标记为 ‘#’, 下次就无法访问了, 效果相同\nProperty Distribution\n\nhttps://vjudge.net/problem/Aizu-0118\n\n题意：有三种水果分别用,‘@’,‘*’,'#'三种符号表示，上下左右相连的同种水果被看做是一个区域，问一共有多少个区域\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=110;char field[maxn][maxn];int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;int h,w;int ans;void dfs(int x,int y,char curr)&#123;    field[x][y]=&#x27;!&#x27;;    for(int i=0;i&lt;4;i++)&#123;        int nx=x+dx[i],ny=y+dy[i];        if(nx&gt;=0&amp;&amp;nx&lt;h&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;w&amp;&amp;field[nx][ny]==curr)&#123;            dfs(nx,ny,curr);        &#125;    &#125;&#125;int main()&#123;    while(cin&gt;&gt;h&gt;&gt;w)&#123;        if(h==0&amp;&amp;w==0) break;        for(int i=0;i&lt;h;i++)&#123;            for(int j=0;j&lt;w;j++)&#123;                cin&gt;&gt;field[i][j];            &#125;        &#125;        ans=0;        for(int i=0;i&lt;h;i++)&#123;            for(int j=0;j&lt;w;j++)&#123;                if(field[i][j]!=&#x27;!&#x27;)&#123;                    // 每次只遍历一个符号                    dfs(i,j,field[i][j]);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;\nBall\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0033\n\n选择放还是不放, 构成一颗决策树\n\nAC 了!!! woc, 不敢相信, 我自己写的, 太感动了\n1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=110;int n;int balls[15];bool rec(int i,int preb,int prec)&#123;    if(i==10)return true;    bool b=balls[i]&gt;=preb?rec(i+1,balls[i],prec):false;    bool c=balls[i]&gt;=prec?rec(i+1,preb,balls[i]):false;    return b||c;&#125;int main()&#123;    cin&gt;&gt;n;    while(n--)&#123;        for(int i=0;i!=10;i++)&#123;            cin&gt;&gt;balls[i];        &#125;        if(rec(0,0,0))            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n*Curling 2.0\n\nhttp://poj.org/problem?id=3009\n\n好难啊\n题目翻译\n每次扔一个球, 撞到墙的话, 墙就被破坏, 该球停在发生撞击的前一个位置. 在该位置继续扔球, 直到扔到终点位置.\n注意, 假如相邻位置上有墙, 就不能朝该位置扔.\n最多扔 10 次\n\nb 为球经过 a 的抛法后剩下的墙\n\na 中只能朝上或者右仍. bc 中, 碰到墙, 该墙被破坏, 球停在墙前.\ne\n碰到墙才开始下一次递归\n\nhttps://blog.csdn.net/xxiaobaib/article/details/78367897?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param &gt; https://blog.csdn.net/c138rick/article/details/78422725?utm_medium=distribute.pc_relevant.none-task-blog-title-9&amp;spm=1001.2101.3001.4242\n\n1先鸽鸽鸽鸽\n广度优先搜索\nCheese\n\nhttps://vjudge.net/problem/Aizu-0558 &gt; https://blog.csdn.net/queque_heiya/article/details/104086807\n\n初始的体力值是 1, 奶酪的硬度依次增加, 可以得出, 每次只能吃硬度等于自身体力值的奶酪\n所以 吃奶酪的顺序是 1-&gt;2-&gt;3…-&gt;n\n我们要求这段的最短距离, 也就是每一小段的最短距离的和\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1010;const int INF=0x3f3f3f3f;int H,W,N; // 高度 宽度 数量char maze[maxn][maxn];int d[maxn][maxn]; // 开始点到每个点的距离int sx,sy,gx,gy; // 开始坐标  结束坐标typedef pair&lt;int,int&gt; P; // 保存坐标int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;void init()&#123;    for(int i=0;i&lt;H;i++)&#123;        for(int j=0;j&lt;W;j++)&#123;            d[i][j]=INF;        &#125;    &#125;&#125;int bfs()&#123;    queue&lt;P&gt; q;    q.push(P(sx,sy));    d[sx][sy]=0;    while(q.size())&#123;        // 从队列中取出一个, 遍历他的4个方向        P p=q.front(); q.pop();        int x=p.first,y=p.second;        if(x==gx&amp;&amp;y==gy)break;        for(int i=0;i&lt;4;i++)&#123;            int nx=x+dx[i],ny=y+dy[i];            if(nx&gt;=0&amp;&amp;nx&lt;H&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;W&amp;&amp;maze[nx][ny]!=&#x27;X&#x27;&amp;&amp;d[nx][ny]==INF)&#123;                q.push(P(nx,ny));                d[nx][ny]=d[x][y]+1;            &#125;        &#125;    &#125;    return d[gx][gy];&#125;int main()&#123;    cin&gt;&gt;H&gt;&gt;W&gt;&gt;N;    for(int i=0;i&lt;H;i++)&#123;        for(int j=0;j&lt;W;j++)&#123;            char temp;            cin&gt;&gt;temp;            if(temp==&#x27;S&#x27;) sx=i,sy=j; // 第一次的开始坐标            else if(temp&gt;=&#x27;0&#x27;&amp;&amp;temp&lt;=&#x27;9&#x27;) maze[i][j]=temp-&#x27;0&#x27;; //奶酪厂            else maze[i][j]=temp;        &#125;    &#125;    int cnt=1; // 当前要去吃的奶酪厂    int ans=0; //路径长度总和    for(int i=0;i&lt;H;i++)&#123;        for(int j=0;j&lt;W;j++)&#123;            if(maze[i][j]==cnt)&#123;                cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot; j=&quot;&lt;&lt;j&lt;&lt;endl;                init();                gx=i,gy=j;                ans+=bfs();                sx=gx,sy=gy;                cnt++;                i=0,j=0;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;/* 对于 bfs 函数, 他只需要知道起点坐标和结束坐标, 放回起点坐标到结束坐标的最短距离 需要使用到 距离数组, 起点, 结束坐标. 使用队列来保持周围的坐标位置 对于main 读取数据, 用 bfs 计算 s-&gt;1, 1-&gt;2 .... n-1-&gt;n 的最短距离的和 他需要提供给 bfs 每一小段的起点坐标, 终点坐标. */\nSeven Puzzle\n\nGitHub 题解\n\n给定输入序列, 通过零号牌与上下左右交换得到 0-8 的有序排列\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int a[8];int d[4]=&#123;-1,1,-4,4&#125;;map&lt;string,int&gt;mymap; // 当前局面与最短路的映射void bfs()&#123;    queue&lt;string&gt; q;    q.push(&quot;01234567&quot;);    mymap[&quot;01234567&quot;]=0;    while(q.size())&#123;        string cur=q.front();        string nxt;        q.pop();        int p=(int)cur.find(&quot;0&quot;); // 找到局面中0的位置        // 朝4个方向试探        for(int i=0;i&lt;4;i++)&#123;            int np=p+d[i];            // 注意这种试探方法, 在第一行末尾不能向右边试探, 在第二行开始不能向左边试探            if(np&gt;=0&amp;&amp;np&lt;8&amp;&amp;(p!=3||d[i]!=1)&amp;&amp;(p!=4||d[i]!=-1))&#123;                nxt = cur;                // 将0与被试探的字符交换                swap(nxt[p],nxt[np]);                // 第一次发现这种字符串                if(mymap.find(nxt)==mymap.end())&#123;                    mymap[nxt]=mymap[cur]+1; //这种局面是在 cur 的基础上多操作一步得来的                    q.push(nxt);                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    // 找出所有的排列可能性    bfs();    while(cin&gt;&gt;a[0])&#123;        for(int i=1;i&lt;8;i++)&#123;            cin&gt;&gt;a[i];        &#125;        // 拼接成字符串        string s=&quot;&quot;;        for(int i=0;i&lt;8;i++)&#123;            s+=a[i]+&#x27;0&#x27;;        &#125;        if(mymap.find(s)==mymap.end())            cout&lt;&lt;-1&lt;&lt;endl;        else            cout&lt;&lt;mymap[s]&lt;&lt;endl;    &#125;    return 0;&#125;\n深度优先搜索\nSmallest Difference\n给定一些数字(0~9), 任意两个数由这些数字组成, 求这个数之差的绝对值的最小值\n它们其实都是图\n最短路问题\nConvenient Location\n\nhttps://vjudge.net/problem/Aizu-0189\n\n最小生成树问题: 使的所有节点连接起来的路径长度最短. 显然不符合本题要求\n本题要求一个城市到其他办公室的和的最短路径, 显然是最短路径问题\n解题思路, 使用 folyd 算法计算不同办公室之间的最短距离, 之后枚举一个办公室到其他办公室的距离之和, 找到最小的那一个\n之后再考虑一下用 dijkstra 算法可以做不, 还没太弄明白\n\nhttps://zhidao.baidu.com/question/2138336660610101908.html\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define min(x,y) (x&gt;y?y:x)using namespace std;const int maxn=50;const int INF=0x3f3f3f3f;int d[maxn][maxn]; // 不同点之间的最短距离int n; // 边的数量int maxx; // 最大的城市编号void folyd()&#123;    for(int k=0;k&lt;=maxx;k++)&#123;        for(int i=0;i&lt;=maxx;i++)&#123;            for(int j=0;j&lt;=maxx;j++)&#123;                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);            &#125;        &#125;    &#125;&#125;int main()&#123;    while(cin&gt;&gt;n&amp;&amp;n)&#123;    \tmemset(d,INF,sizeof(d));        int a,b,c;        maxx=-1;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;            d[a][b]=d[b][a]=c;            maxx=max(maxx,max(a,b));        &#125;        for(int i=0;i&lt;=maxx;i++)&#123;        \td[i][i]=0;\t\t&#125;        folyd(); // 不同点之间的最短距离        int ans=INF;        int pos=0;        for(int i=0;i&lt;=maxx;i++)&#123;            // 遍历某个办公室到其他地方            int sum=0;            for(int j=0;j&lt;=maxx;j++)                sum+=d[i][j];            if(ans&gt;sum)&#123;                ans=sum;                pos=i;            &#125;        &#125;        cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;\nSix Degrees of Cowvin Bacon\n和上一道题类似\n不过还是不知道是否可以使用 dijkstra 算法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int maxn=350;int d[maxn][maxn];int n,m;void folyd()&#123;\tfor(int k=1;k&lt;=n;k++)&#123;\t\tfor(int i=1;i&lt;=n;i++)&#123;\t\t\tfor(int j=1;j&lt;=n;j++)&#123;\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\t\t\t&#125;\t\t&#125;\t&#125;&#125;int main()&#123;\t// 初始化 d 数组\tmemset(d,INF,sizeof(d));\tfor(int i=0;i&lt;maxn;i++)&#123;\t\td[i][i]=0;\t&#125;\tcin&gt;&gt;n&gt;&gt;m;\t// 读入每一个小团体\tfor(int i=0;i&lt;m;i++)&#123;\t\t// 将同一个团体的成员距离设置为1\t\tint k;\t\tcin&gt;&gt;k;\t\tint b[maxn];\t\tfor(int i=0;i&lt;k;i++)cin&gt;&gt;b[i];\t\tfor(int i=0;i&lt;k;i++)&#123;\t\t\tfor(int j=i+1;j&lt;k;j++)&#123;\t\t\t\td[b[i]][b[j]]=d[b[j]][b[i]]=1;\t\t\t&#125;\t\t&#125;\t&#125;\tfolyd();\tint mindissum=INF;\tfor(int i=1;i&lt;=n;i++)&#123;\t\tint sum=0;\t\tfor(int j=1;j&lt;=n;j++)&#123;\t\t\tsum+=d[i][j];\t\t&#125;\t\tmindissum=min(sum,mindissum);\t&#125;\tcout&lt;&lt;mindissum*100/(n-1)&lt;&lt;endl;\treturn 0;&#125;推荐文章洛谷【搜索】暴力专项训练八皇后问题位运算kuangbin 题单Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/wdmukq/"},{"title":"挑战程序设计竞赛-例题","date":"2020-10-03T01:01:01.000Z","date_formatted":{"ll":"Oct 3, 2020","L":"10/03/2020","MM-DD":"10-03"},"updated":"2021-02-03T04:20:59.893Z","content":"准备篇\n三角形\n\n123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int maxn=110;int n,edge[maxn];using namespace std;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;edge[i];    &#125;    int res=0;    for(int i=0;i!=n;i++)&#123;        for(int j=0;j&lt;i;j++)&#123;            for(int k=0;k&lt;j;k++)&#123;                int len=edge[i]+edge[j]+edge[k];                int ma=max(max(edge[i],edge[j]),edge[k]);                int rest=len-ma;                if(ma&lt;rest)&#123;                    res=max(len,res);                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;res;&#125;/*充要条件 最长的一个边小于其他两边之和 */\nAnts\n\nhttp://poj.org/problem?id=1852\n\n1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int maxn=10e6+10;int n,x[maxn],L;using namespace std;#define min(x,y) (x &lt; y ? x : y)int main()&#123;    cin&gt;&gt;L&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;x[i];    &#125;    int minT=0;    int maxT=0;    for(int i=0;i&lt;n;i++)&#123;        minT=max(minT,min(x[i],L-x[i]));        maxT=max(maxT,max(x[i],L-x[i]));    &#125;    cout&lt;&lt;minT&lt;&lt;&quot; &quot;&lt;&lt;maxT;    return 0;&#125;/* 每个蚂蚁的速度都是一样的, 不会出现一个蚂蚁追到另一个蚂蚁然后折返的情况 由此可以看出, 影响结果的就是每只蚂蚁的初始朝向. 对于最短的时间, 只需要初始的时候所有的蚂蚁都朝向距离最短的一个端点前进 对于最长的时间, 只需要初始的时候所有的蚂蚁都朝向距离最远的一个端点前进 每只蚂蚁相遇时, 把他们角色互换, 当做还是在沿原方向走 */\n难度增加的抽签问题\n3 个纸片, 大小分别是 1, 3, 5. 判断抽取 4 次, 是否存在和为 m 的情况. 每次抽取之后放回\n暴力解法 时间复杂度 \n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;const int maxn=10e6+10;using namespace std;int m,n,k[maxn];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;k[i];    &#125;    bool flag=false;    for(int a=0;a&lt;n;a++)&#123;        for(int b=0;b&lt;n;b++)&#123;            for(int c=0;c&lt;n;c++)&#123;                for(int d=0;d&lt;n;d++)&#123;                    if(k[a]+k[b]+k[c]+k[d]==m)&#123;                        flag=true;                    &#125;                &#125;            &#125;        &#125;    &#125;    if(flag==false)        cout&lt;&lt;&quot;NO&quot;;    else        cout&lt;&lt;&quot;YES&quot;;    return 0;&#125;\n二分搜索 \n之前最内层循环可以优化为一个二分查找. 不需要遍历每一个数来与前 3 个数相加凑成 m, 直接看数组内是否存在 (用 m-前三个数的和)\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int maxn=10e6+10;using namespace std;int m,n,k[maxn];bool binary_serach(int x)&#123;    int l=0,r=n;    while(r&gt;l)&#123;        int i=(l+l)/2;        if(k[i]&gt;x)&#123;            r=i;        &#125;else if(k[i]&lt;x)&#123;            l=i+1;        &#125;else&#123;            return true;        &#125;    &#125;    return false;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;k[i];    &#125;    bool flag=false;    for(int a=0;a&lt;n;a++)&#123;        for(int b=0;b&lt;n;b++)&#123;            for(int c=0;c&lt;n;c++)&#123;                int x=m-k[a]-k[b]-k[c];                if(binary_serach(x))                //if(binary_search(k, k+n, x)) stl                    flag=true;            &#125;        &#125;    &#125;    if(flag==false)        cout&lt;&lt;&quot;NO&quot;;    else        cout&lt;&lt;&quot;YES&quot;;    return 0;&#125;\n\n可以使用 stl 里面的二分查找 https://www.cnblogs.com/wkfvawl/p/9475939.html\n\n再次二分算法 时间复杂度 \n同上个思路, 第一种算法的内两层可以优化为在后两个和的集合中查找 (m-前两个的和)\n后两个集合的和\n12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int maxn=10e6+10;using namespace std;int m,n,k[maxn],kk[maxn];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;k[i];    &#125;    // 构造后两个组成的集合    for(int i=0;i!=n;i++)&#123;        for(int j=0;j!=n;j++)&#123;            kk[i*n+j]=k[i]+k[j];        &#125;    &#125;    sort(kk,kk+n*n);    bool flag=false;    for(int a=0;a&lt;n;a++)&#123;        for(int b=0;b&lt;n;b++)&#123;            if(binary_search(kk, kk+n*n, m-k[a]-k[b]))                flag=true;        &#125;    &#125;    if(flag==false)        cout&lt;&lt;&quot;NO&quot;;    else        cout&lt;&lt;&quot;YES&quot;;    return 0;&#125;\n初级篇\n部分和问题\n\n12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int maxn=10e9+10;using namespace std;int n,k,a[maxn];// 现在进行到的数组位置, sum 现在的和bool dfs(int i,int sum)&#123;    if(i==n) return sum==k;    return dfs(i+1,a[i])||dfs(i+1,a[i]+sum);&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    cin&gt;&gt;k;    if(dfs(0,0))        cout&lt;&lt;&quot;YES&quot;;    else        cout&lt;&lt;&quot;No&quot;;    return 0;&#125;\nLakeCounting\n\nhttp://poj.org/problem?id=2386\n\n8 个方向上, 有积水就看成是一个水洼\n12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int maxn=110,maxm=110;using namespace std;char field[maxn][maxm];int n,m;void dfs(int x,int y)&#123;    field[x][y]=&#x27;.&#x27;;    for(int dx=-1;dx&lt;=1;dx++)&#123;        for(int dy=-1;dy&lt;=1;dy++)&#123;            int nx=x+dx;            int ny=y+dy;            if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;field[nx][ny]==&#x27;W&#x27;)                dfs(nx,ny);        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;field[i][j];        &#125;    &#125;    int res=0;    for(int i=0;i!=n;i++)&#123;        for(int j=0;j!=m;j++)&#123;            if(field[i][j]==&#x27;W&#x27;)&#123;                dfs(i,j);res++;            &#125;        &#125;    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;\n时间复杂度 \n重点需要掌握的是在图中向 8 个方向行走的方法\n12345678for(int dx=-1;dx&lt;=1;dx++)&#123;    for(int dy=-1;dy&lt;=1;dy++)&#123;        int nx=x+dx;        int ny=y+dy;        if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;field[nx][ny]==&#x27;W&#x27;)            dfs(nx,ny);    &#125;&#125;\n迷宫的最短路径\n\n在求最短路径时需要反复经过相同的状态, 此时使用广度优先遍历比较好\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=110,maxm=110;const int INF=10e8;typedef pair&lt;int,int&gt; P;char maze[maxn][maxm];int n,m;int sx,sy; // 起点int gx,gy; // 终点int d[maxn][maxm]; // 到起点的最短路径的数组int dx[4]=&#123;1,0,-1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;int bfs()&#123;    queue&lt;P&gt;que;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            d[n][m]=INF;        &#125;    &#125;    que.push(P(sx,sy));    d[sx][sy]=0;    while(!que.empty())&#123;        P p=que.front();que.pop();        if(p.first==gx&amp;&amp;p.second==gy)&#123;// 找到终点了            break;        &#125;        for(int i=0;i&lt;4;i++)&#123;            int nx=p.first+dx[i];            int ny=p.second+dy[i];            if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;maze[nx][ny]!=&#x27;#&#x27;&amp;&amp;d[nx][ny]==INF)&#123;// 可以走, 但是没有来过                que.push(P(nx,ny));                d[nx][ny]=d[p.first][p.second]+1;            &#125;        &#125;    &#125;    return d[gx][gy];&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;maze[i][j];            if(maze[i][j]==&#x27;S&#x27;)&#123;                sx=i;sy=j;            &#125;else if(maze[i][j]==&#x27;G&#x27;)&#123;                gx=i;gy=j;            &#125;        &#125;    &#125;    cout&lt;&lt;bfs()&lt;&lt;endl;    return 0;&#125;\n重点掌握 4 个方向上的遍历方法\n1234567891011int dx[4]=&#123;1,0,-1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;for(int i=0;i&lt;4;i++)&#123;    int nx=p.first+dx[i];    int ny=p.second+dy[i];    if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;maze[nx][ny]!=&#x27;#&#x27;&amp;&amp;d[nx][ny]==INF)&#123;// 可以走, 但是没有来过        que.push(P(nx,ny));        d[nx][ny]=d[p.first][p.second]+1;    &#125;&#125;\n深度优先遍历比广度优先遍历更加节省空间\n剪枝\n剔除不可能得到解的状态\n硬币问题\n经典贪心算法\n\n不断选取最优\n12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define min(x,y) (x&gt;y?y:x)const int V[6]=&#123;1,5,10,50,100,500&#125;;int C[6]; // 对应币值的数量int A; // 需要凑的大小int main()&#123;    for(int i=0;i&lt;6;i++)&#123;        cin&gt;&gt;C[i];    &#125;    cin&gt;&gt; A;    int ans=0;    for(int i=5;i&gt;=0;i--)&#123;        int t=min(A/V[i],C[i]); // 使用硬币的数量        A-=t*V[i]; // 还需要支付        ans+=t;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n区间调度问题\n\n在可选工作中, 每次选择最早结束的工作\n1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=10e5;int n,S[maxn],T[maxn];pair&lt;int,int&gt; itv[maxn];int main()&#123;    cin&gt;&gt;n;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;S[i];    &#125;    for(int j=0;j!=n;j++)&#123;        cin&gt;&gt;T[j];    &#125;    for(int i=0;i!=n;i++)&#123;        itv[i].first=T[i]; // 结束时间        itv[i].second=S[i]; // 开始时间    &#125;    // 让更早结束的工作排前面    sort(itv,itv+n);    int ans=0,t=0;// t 是所选工作的结束时间    for(int i=0;i!=n;i++)&#123;        if(t&lt;itv[i].second)&#123; // 当前工作结束啦            ans++;            t=itv[i].first; // 开始下一个工作        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n字典最小序问题\n\nhttp://poj.org/problem?id=3617\n\n\n每次从 s 的末尾或者开头选择一个较小的, 可以任意的得到贪心方法: 每次选择开头或者结尾较小的那个字母. 如果开头和结尾的字母相同, 我们在正序和逆序中选择字典序较小的那个的开头\n12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=2010;char s[maxn];int n;int main()&#123;    cin&gt;&gt;n&gt;&gt;s;    int a=0,b=n-1;    while(a&lt;=n)&#123; // 比较从s与s&#x27;        bool left=false; //从左边取        for(int i=0;a+i&lt;b;i++)&#123;            if(s[a+i]&lt;s[b-i])&#123;                left=true;                break;            &#125;else if(s[a+i]&gt;s[b-i]) &#123;                left=false;                break;            &#125;        &#125;        if(left)            putchar(s[a++]);        else            putchar(s[b--]);    &#125;    return 0;&#125;\nSaruman’s Army\n\nhttp://poj.org/problem?id=3069\n\n\n从最左边开始, 考虑到右边没有点了, 为了使覆盖的点更多, 第一个标记应该在覆盖最左边这个点的情况下尽可能的在右边选择.\n同理, 选择了一个点之后, 看下一个未被覆盖的点, 在覆盖该点的情况下尽可能选择靠右边的点标记.\n1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;const int maxn=1010;int r,n; // 半径 数量int field[maxn];int main()&#123;    while(cin&gt;&gt;r&gt;&gt;n&amp;&amp;r!=-1&amp;&amp;n!=-1)&#123;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;field[i];        &#125;        sort(field,field+n); // 从小到大排好序        // 在可以庇护当前营地的情况下, 尽可能的靠右边        int i=0,ans=0;        while(i&lt;n)&#123;            // s 位置是当前营地            int s=field[i];            // 之后 i 指向的是无法庇护到的点            while(i&lt;n&amp;&amp;field[i]&lt;=s+r)i++;            // 驻扎点的位置            int p=field[i-1];            // 走出他的覆盖范围之外            while(i&lt;n&amp;&amp;field[i]&lt;=p+r)i++;            ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nFenceRepair\n\nhttp://poj.org/problem?id=3253\n\n\n这就是一个哈夫曼树问题, 每个叶子节点对应需要的木板长度, 求最小编码问题\n对于最优解: 最小的节点一定是深度最大的节点, 其次, 次小的节点是他的兄弟节点. 其他节点都是作为对应根节点的唯一一个左儿子, 不存在兄弟节点\n回顾一下哈夫曼编码. 每次从优先队列选择最小的两个, 之后将他们的和放入到优先队列, 继续选择最小的两个, 直到队列为空.\n1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int maxl=50010;int l[maxl],n;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;l[i]   ;    &#125;    ll ans=0;    while(n&gt;1)&#123;        // 求出当前最短板和次短板的长度        int mii1=0,mii2=1;        if(l[mii1]&gt;l[mii2])swap(mii1,mii2); // 先确保mii1位置的数小于mii2的数        for(int i=2;i&lt;n;i++)&#123;            if(l[i]&lt;l[mii1])&#123;                mii2=mii1;                mii1=i;            &#125;else if(l[i]&lt;l[mii2])&#123;                mii2=i;            &#125;        &#125;        // 将两块板拼合        int t=l[mii1]+l[mii2];        ans+=t;        // 将这两段的和插入到 mii1 的位置, 并且整体长度-1, 末尾的数放入到 mii2        if(mii1==n-1)swap(mii1,mii2);        l[mii1]=t;        l[mii2]=l[n-1];        n--;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n注意从数组中直到最小和次小的数的方法\n1234567891011 // 求出当前最短板和次短板的长度int mii1=0,mii2=1;if(l[mii1]&gt;l[mii2])swap(mii1,mii2); // 先确保mii1位置的数小于mii2的数for(int i=2;i&lt;n;i++)&#123;    if(l[i]&lt;l[mii1])&#123;        mii2=mii1;        mii1=i;    &#125;else if(l[i]&lt;l[mii2])&#123;        mii2=i;    &#125;&#125;\n用堆实现时间复杂度为   时间复杂度的算法\n注意: 向堆中插入一个元素的时间复杂度是 \n12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt; ,greater&lt;int&gt; &gt; que;int n;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int temp;        cin&gt;&gt;temp;        que.push(temp);    &#125;    int ans=0;    while(que.size()!=1)&#123;        int x1=0,x2=0;        x1=que.top(); que.pop();        x2=que.top(); que.pop();        que.push(x1+x2);        ans+=(x1+x2);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n* 01 背包\n\n前 i 件物品放入容量为 j 的背包，所得到的最优价值为 dp[i][j]\n\n朴素搜索\n12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=110;int n,W;int v[maxn],w[maxn];// 价值 重量// 针对每一个物品是否放进背包进行搜索int rec(int i,int j)&#123;    int res; // 价值    if(i==n)&#123;//搜索结束, 没有剩余物品了        res=0;    &#125;else if(j&lt;w[i])&#123;//假如加入这个物品的话超过额定重量        // 无法挑选这个物品        res=rec(i+1,j);    &#125;else &#123;        res=max(rec(i+1,j),rec(i+1,j-w[i])+v[i]);    &#125;    return res;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;W;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i];    &#125;    cout&lt;&lt;rec(0,W)&lt;&lt;endl;    return 0;&#125;\n\ntips: memset 可以快速的对高维数组赋值为 -1, 而 1 则不行\n\n使用记忆化递归\n1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1100;int n,W;int v[maxn],w[maxn];// 价值 重量int dp[maxn][maxn];// 针对每一个物品是否放进背包进行搜索int rec(int i,int j)&#123;    if(dp[i][j]&gt;=0)        return dp[i][j];    int res; // 价值    if(i==n)&#123;//搜索结束, 没有剩余物品了        res=0;    &#125;else if(j&lt;w[i])&#123;//假如加入这个物品的话超过额定重量        // 无法挑选这个物品        res=rec(i+1,j);    &#125;else &#123;        res=max(rec(i+1,j),rec(i+1,j-w[i])+v[i]);    &#125;    dp[i][j]=res;    return res;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;W;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i];    &#125;    memset(dp, -1, sizeof(dp));    cout&lt;&lt;rec(0,W)&lt;&lt;endl;    return 0;&#125;\n从后先前的递推\n1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=11000;int n,W;int v[maxn],w[maxn];// 价值 重量int dp[maxn][maxn];int main()&#123;    cin&gt;&gt;n&gt;&gt;W;    for(int i=0;i!=n;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i];    &#125;    // 从后先前递推    for(int i=n-1;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=W;j++)&#123;            if(j&lt;w[i])&#123; //                dp[i][j]=dp[i+1][j];            &#125;else&#123;                dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i]);            &#125;        &#125;    &#125;    cout&lt;&lt;dp[0][W]&lt;&lt;endl;    return 0;&#125;\n还有一种写法\n1234567891011void solve2()&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;=W;j++)&#123;            if(j&lt;w[i])                dp[i+1][j]=dp[i][j];            else                dp[i+1][j]=max(dp[i][j],dp[i][j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[n][W]&lt;&lt;endl;&#125;\n空间优化\n12345678void solve2()&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=W;j&gt;=w[i];j--)&#123;            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[W]&lt;&lt;endl;&#125; ub\n完全背包问题\n1234567891011// w重量, v价值void solve3()&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;=W;j++)&#123;            for(int k=0;k*w[i]&lt;=j;k++)&#123;                dp[i+1][j]=max(dp[i+1][j],dp[i][j-k*w[i]]+k*v[i]);            &#125;        &#125;    &#125;    cout&lt;&lt;dp[n][W];&#125;\n优化\n1234567891011void solve4()&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;=W;j++)&#123;            if(j&lt;w[i])                dp[i+1][j]=dp[i][j];            else                dp[i+1][j]=max(dp[i][j],dp[i+1][j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[n][W]&lt;&lt;endl;&#125;\n空间优化\n12345678void solve()&#123;    for(int i=0;i&lt;n;i++)&#123;        for(int j=w[i];j&lt;=W;j++)&#123;            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[W]&lt;&lt;endl;&#125;\n最长公共子序列\n\n1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1010;int dp[maxn][maxn];// dp[i][j] 代表 s(1-i) 与 t(1-j) 的最长公共子序列的长度int n,m;string s,t;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(s[i]==t[j])                dp[i+1][j+1]=dp[i][j]+1;            else&#123;                dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);            &#125;        &#125;    &#125;    cout&lt;&lt;dp[n][m];    return 0;&#125;\n背包问题后补\n划分数\n\nExpedition\n\nhttp://poj.org/problem?id=2431\n书上有改动, 建议看书\n\n经过加油站选择加还是不加? 我们可以当做我得到了一次加油的机会, 但是现在不加油, 在之后油用完了, 我们就把这个机会用掉. 可能在用完之前我们会经过几个加油站, 我们的得到了很多机会, 那么我们这么选择呢? 显然, 选择可以加油量最多的那个加油站\n\n注意, 题目只要求加油站的数量, 但是并没有要求是哪个具体的加油站\n使用优先队列从&quot;机会&quot;中选择加油量最多的\n\n当前油箱不为空, 就继续前进, 遇到加油站就放入优先队列, 油用完了, 就从优先队列中取出一个, 如果优先队列为空, 说明汽车无法到达终点\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=10000;int a[maxn],b[maxn]; // 加油站距离开始 加油站加油量priority_queue&lt;int&gt; que;int n,l,p; // 加油站数量, 总长度, 刚开始的汽油int ans=0;void solve()&#123;    // 把终点站看成是加油站    a[n]=l;    b[n]=0;    n++;    // 加油次数 位置 油量    int ans=0,pos=0,tank=p;    for(int i=0;i&lt;n;i++)&#123;        int d=a[i]-pos; // 接下去要行进的距离        while(tank&lt;d)&#123;            if(que.empty())&#123;                cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;                return;            &#125;            // 一直加油, 油箱的余量可以到达下一个加油站            tank+=que.top();            que.pop();            ans++;        &#125;        tank-=d;        pos=a[i];        que.push(b[i]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;l&gt;&gt;p;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int j=0;j&lt;n;j++)&#123;        cin&gt;&gt;b[j];    &#125;    solve();    return 0;&#125;\n编码实现时: 对于该车, 看油箱余量是否可以支持它到下一个加油站, 不够的话就从&quot;机会&quot;里面加油, 如果没有&quot;机会&quot;了, -1. 经过下一个加油站时, 我们就又多了一个机会. 把终点虚拟为一个加油站\n并查集\n管理元素分组情况的数据结构\n\n并查集也是使用树形结构实现的\n判断两个元素是否是同一集合: 找到两个元素所在树形的根元素, 判断是否相同\n合并: 两颗树根与根连接成一个树形, 小树接大树\n\n使用路径压缩来使并查集效率更高. 子节点尽可能的靠近根节点\n\n并查集的时间复杂度低于 \n*食物链\n\nhttps://vjudge.net/problem/POJ-1182\n\n\n\n我怀疑这是一道脑筋急转弯\n解释 1: https://blog.csdn.net/niushuai666/article/details/6981689\n解释 2: https://blog.csdn.net/hitwhylz/article/details/12260377\n\n他们说的话可能是真, 可能是假. 先初步判断真假\n增加一个结构, 存在于动物体之间. 联系并查集树形的特点.\n先将每一个个体看成是一个单独的并查集. 之后根据输入的同类, 捕食关系来合并不同的并查集.\n&lt;–后补–&gt;\n二分图判定\n\n\np97 页\n\n确定一个位置的着色之后, 相邻位置的颜色也就确定了\n使用邻接表的存储方式\n123456789101112131415161718192021222324// 顶点 颜色bool dfs(int v,int c)&#123;    color[v]=c;    for(int i=0;i&lt;G[v].size();i++)&#123;        // 相邻节点被染色了, 并且与当前节点同色        if(color[G[v][i]]==c)            return false;        // 相邻节点未被染色, 则染成 -c        if(color[G[v][i]]==0&amp;&amp;!dfs(G[v][i],-c))            return false;    &#125;    return true;&#125;void solve()&#123;    for(int i=0;i&lt;v;i++)&#123;        if(color[i]==0)            if(!dfs(i,1))&#123;                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;                return ;            &#125;    &#125;    cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;&#125;\n最短路径问题\n\nhttps://www.acwing.com/blog/content/405/\n\nFrod 算法\nFord 算法: 单源最短路径算法, 适用于有边为负值的情况, 是求原点到其他所有点的最短路径, 不是两个点之间的最短路径\n\nhttp://www.wutianqi.com/blog/1912.html &gt; https://endlesslethe.com/bellmanford-spfa-tutorial.html &gt; https://blog.csdn.net/tengweitw/article/details/17451125 &gt; https://juejin.im/post/6844903661395509262\n\n关于形成的最短路径的几个定理\n定理一：只有上一次迭代中松弛过的点才有可能参与下一次迭代的松弛操作\n定理二：如果在边权都为正的图中，最短路一定是一条路径，而不是一个圈，且长度不会大于等于 V\n定理三：对于存在负圈的图，最短路无意义\n定理四：对于不存在负圈的图，最短路一定是一条路径，且长度不会大于等于 V\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int MAX=10000;const int m=10,n=5;// 边数, 顶点数typedef struct&#123;    int startvex;    int endvex;    int length;&#125;edge;edge T[m]; // 边的集合// 返回值为0, 代表存在从源点s可达的负权回路, 否则返回边的个数int BellmanFord(int dist[n][n],int d[n],int i)&#123;    // 初始化到每个顶点的距离为无穷    for(int i=0;i&lt;n;i++)&#123;        d[i]=MAX;    &#125;    d[i]=0;    int num=0;// 用于统计边    for(int k=0;k&lt;n-1;k++)&#123;        // 当前节点是 ii        for(int ii=0;ii&lt;n;ii++)&#123;            for(int jj=0;jj&lt;n;jj++)&#123;                if(dist[ii][jj]!=MAX)&#123;                    // 更新原点到他邻居的节点的距离                    // 如果原点直接到邻居的距离比从原点到该点,再从该点到邻居要远的话                    if(d[jj]&gt;(d[ii]+dist[ii][jj]))&#123;                        d[jj]=d[ii]+dist[ii][jj]; // 更新原点到邻居的最短距离                        T[num].startvex=ii;                        T[num].endvex=jj;                        T[num].length=dist[ii][jj];                        num++;                    &#125;                &#125;            &#125;        &#125;    &#125;    for(int ii=0;ii&lt;n;ii++)&#123;        for(int jj=0;jj&lt;n;jj++)&#123;            if(d[jj]&gt;d[ii]+dist[ii][jj])                return 0;        &#125;    &#125;    return num;&#125;int main()&#123;    int dist[n][n]=&#123;&#123;0,6,MAX,7,MAX&#125;,                    &#123;MAX,0,5,8,-4&#125;,                    &#123;MAX,-2,0,MAX,MAX&#125;,                    &#123;MAX,MAX,-3,0,9&#125;,                    &#123;2,MAX,7,MAX,0&#125;&#125;;//图的邻接矩阵    int d[n];    int num=0; // num 用于统计边    num=BellmanFord(dist, d, 0);// 0 为源点    for(int i=0;i&lt;n;i++)&#123;        printf(&quot;start= %d, end= %d, length= %d\\n&quot;,T[i].startvex,T[i].endvex,T[i].length);    &#125;    return 0;&#125;\n关于这个算法的几个问题\n为什么是循环 n-1 次?\n答：因为最短路径肯定是个简单路径，不可能包含回路的， 如果包含回路，且回路的权值和为正的，那么去掉这个回路，可以得到更短的路径 如果回路的权值是负的，那么肯定没有解了\n图有 n 个点，又不能有回路 所以最短路径最多 n-1 边\n又因为每次循环，至少 relax 一边 所以最多 n-1 次就行了\n第二种版本的代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** About:  Bellman-Ford算法* Author: Tanky Woo* Blog:   www.WuTianqi.com*/#includeusing namespace std;const int maxnum = 100;const int maxint = 99999;// 边，typedef struct Edge&#123;    int u, v;    // 起点，重点    int weight;  // 边的权值&#125;Edge;Edge edge[maxnum];     // 保存边的值int  dist[maxnum];     // 结点到源点最小距离int nodenum, edgenum, source;    // 结点数，边数，源点// 初始化图void init()&#123;    // 输入结点数，边数，源点    cin &gt;&gt; nodenum &gt;&gt; edgenum &gt;&gt; source;    for(int i=1; i&lt;=nodenum; ++i)        dist[i] = maxint;    dist[source] = 0;    for(int i=1; i&lt;=edgenum; ++i)    &#123;        cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].weight;        if(edge[i].u == source)          //注意这里设置初始情况            dist[edge[i].v] = edge[i].weight;    &#125;&#125;// 松弛计算void relax(int u, int v, int weight)&#123;    if(dist[v] &gt; dist[u] + weight)        dist[v] = dist[u] + weight;&#125;bool Bellman_Ford()&#123;    for(int i=1; i&lt;=nodenum-1; ++i)        for(int j=1; j&lt;=edgenum; ++j)            relax(edge[j].u, edge[j].v, edge[j].weight);    bool flag = 1;    // 判断是否有负环路    for(int i=1; i&lt;=edgenum; ++i)        if(dist[edge[i].v] &gt; dist[edge[i].u] + edge[i].weight)        &#123;            flag = 0;            break;        &#125;    return flag;&#125;int main()&#123;    init();    if(Bellman_Ford())        for(int i = 1 ;i &lt;= nodenum; i++)            cout &lt;&lt; dist[i] &lt;&lt; endl;    return 0;&#125;\nDijkstra 算法\n一个点到其他所有点\n\nhttps://www.bilibili.com/video/BV1QK411V7V4/\n\n123456789101112131415161718192021222324252627const int INF =0x3f3f3f;const int maxv=10000;int cost [maxv][maxv]; // i-&gt;j 的花费int d[maxv]; // 顶点出发的最短路径int V;bool used[maxv]; // 已经用过的图void dijkstra(int s)&#123;    fill(d,d+V,INF);    fill(used,used+v,false);    d[s]=0;    while(1)&#123;        int v=-1;        // 从尚未选择的节点中选择一个距离最短的节点        for(int u=0;u&lt;v;u++)&#123;            if(!used[u]&amp;&amp;(v==-1||d[u]&lt;d[v]))                v=u;        &#125;        if(v==-1)break; // 全部都被使用过了        used[v]=true;        for(int u=0;u&lt;v;u++)&#123;            d[u]=min(d[u],d[v]+cost[v][u]);        &#125;    &#125;&#125;\nFloyd 算法\n所有两个点之间的最短路径\n\n123456789void floyd()&#123;    for(int k=0;k&lt;v;k++)&#123;        for(int i=0;i&lt;v;i++)&#123;            for(int j=0;j&lt;v;j++)&#123;                d[i][j]=min(d[i][j],d[k][j]+d[i][k]);            &#125;        &#125;    &#125;&#125;\n路径还原\n使用 prev 来记录最短路径顶点的前驱节点\n12345678910111213141516171819202122232425262728293031323334353637int cost [maxv][maxv]; // i-&gt;j 的花费int d[maxv]; // 顶点出发的最短路径int v;bool used[maxv]; // 已经用过的图int prevs[maxv];void dijkstra(int s)&#123;    fill(d,d+v,INF);    fill(used,used+v,false);    fill(prevs,prevs+v,-1); //默认前驱不存在    d[s]=0;    while(true)&#123;        int v=-1;        for(int i=0;i&lt;v;i++)&#123;            if(!used[i]&amp;&amp;(v==-1||d[i]&lt;d[v]))                v=i;        &#125;        if(v==-1)break;        used[v]=true;        for(int u=0;u&lt;v;u++)&#123;            if(d[u]&gt;d[v]+cost[v][u])&#123;                d[u]=d[v]+cost[v][u];                prevs[u]=u;            &#125;        &#125;    &#125;&#125;vector&lt;int&gt; get_path(int t)&#123;    vector&lt;int&gt; path;    for(; t!=-1;t=prevs[t])        path.push_back(t);    reverse(path.begin(),path.end());    return path;&#125;\n最小生成树问题\nPrim 算法\n加顶点法\n123456789101112131415161718192021222324252627282930const int INF =0x3f3f3f;const int maxv=10000;int cost[maxv][maxv];int mincost[maxv]; // 从集合x出发到每个顶点的最小权值bool used[maxv]; // 节点是否被包含在其中int v;int prim()&#123;    fill(mincost,mincost+v,INF);    fill(used,used+v,false);    mincost[0]=0;    int res=0;    while(true)&#123;        int v=-1;        // 从不属于x集合的顶点中选取x到其权值最小的顶点        for(int u=0;u&lt;v;u++)&#123;            if(!used[u]&amp;&amp;(v==-1||mincost[u]&lt;mincost[v]))                v=u;        &#125;        if(v==-1) break;        used[v]=true;        res+=mincost[v];        for(int u=0;u&lt;v;u++)&#123;            mincost[u]=min(mincost[u],cost[v][u]);        &#125;    &#125;    return res;&#125;\nKruskal 算法\n加边法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344const int INF =0x3f3f3f;const int maxv=10000;struct edge&#123;    int u,v,cost;&#125;bool comp(const edge&amp; e1,const edge&amp; e2)&#123;    return e1.cost&lt;e2.cost;&#125;edge es[maxv];int v,e;int p[maxv]; //并查集的父节点void init_union_find(int size)&#123;    for(int i=0;i&lt;size;i++)&#123;        p[i]=i;    &#125;&#125;int find(int x)&#123;    if(p[x]!=x)        p[x]=find(p[x]);    return p[x];&#125;bool same(int i1,int i2)&#123;    return find(i1)==find(i2);&#125;void unite(int i1,int i2)&#123;    p[i1]=i2;&#125;int kruskal()&#123;    sort(es,es+e,comp); //从小到大排序    init_union_find(v); // 并查集的初始化    int res=0;    for(int i=0;i&lt;e;i++)&#123;        edge e=es[i];        if(!same(e.u,e.v))&#123; // 不是同一个连通分量            unite(e.u,e.v); // 合并两个连通分量            res+=e.cost;        &#125;    &#125;    return res;&#125;推荐文章洛谷【搜索】暴力专项训练八皇后问题位运算kuangbin 题单Go数据结构与算法05-栈下: 深入理解 defer","plink":"https://mvbbb.github.io/po3i4a/"},{"title":"想学算法","date":"2020-10-02T13:50:40.000Z","date_formatted":{"ll":"Oct 2, 2020","L":"10/02/2020","MM-DD":"10-02"},"updated":"2021-02-03T04:20:59.901Z","content":"算法基础薄弱, 想通过参加蓝桥杯来补算法\n\n主要是想白嫖去北京旅游的机会\n\n\n看了一天的紫书, 不出意料的被打击到了. 菜就是菜\n\n被打击到了这句话, 我好像自从上了大学就一直挂在嘴边. shame on myself.\n\n决定明天换一种思路, 换成 挑战程序设计竞赛, 看书的同时做一做真题.\n蓝桥杯得明年 4.5 月去了, 不急不急.\n恩, 我还年轻, 不断试错.\n对了, 还得补 操作系统, 这个也是一个大老虎.\n推荐文章Bye! My 2020近期规划-碎碎念刷题!刷题!博客配置修改","plink":"https://mvbbb.github.io/mce5h4/"},{"title":"算法竞赛入门经典","date":"2020-10-01T13:09:45.000Z","date_formatted":{"ll":"Oct 1, 2020","L":"10/01/2020","MM-DD":"10-01"},"updated":"2021-02-03T04:20:59.921Z","content":"冲冲冲!!\n\n破损的键盘\n\nUVA 11988\n\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;string&gt;const int maxn = 10e5 +5;int last,cur,next[maxn];char s[maxn];int main()&#123;    // 每次处理一行文本    while(scanf(&quot;%s&quot;,s+1)==1)&#123;        int n=strlen(s+1); //字符串长度        cur=last=0; // 空链表, 只有头结点        next[0]=0;        // 遍历每一个字符        for(int i=1;i&lt;=n;i++)&#123;            char ch=s[i];            if(ch==&#x27;[&#x27;) // home                cur=0;            else if(ch==&#x27;]&#x27;) // end                cur=last;            else&#123;                next[i]=next[cur];                next[cur]=i;  // 把当前节点 (位置为i) 接到链表中                if(cur==last) // 更新最后一个字符的编号                    last=i;                cur=i; // 移动光标            &#125;        &#125;        for(int i=next[0];i!=0;i=next[i])&#123;            printf(&quot;%c&quot;,s[i]);        &#125;        printf(&quot;\\n&quot;);    &#125;    return 0;&#125;// this_is_a_[beiju]_text// 使用 cur 记录当前节点的位置, 方便下个节点的连接// 使用 last 记录最后一个节点的位置\n移动盒子\n\nUVA 12657\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;    // std::swapusing namespace std;typedef long long ll;const int maxn=10e5+5;int left[maxn],right[maxn];// 连接两个节点void link(int l ,int r)&#123;    right[l]=r;    left[r]=l;&#125;int main()&#123;    int n,m,kase=0 ;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)&#123;        //初始化一个双向链表        for(int i=1;i&lt;=n;i++)&#123;            left[i]=i-1;            right[i]=(i+1)%(n+1);        &#125;        right[0]=1;left[0]=n;        int op,X,Y,inv=0;        // 读取并执行语句        while(m--)&#123;            scanf(&quot;%d&quot;,&amp;op);            if(op==4) // 如果之前不需要执行过翻转, 则需要执行翻转. 反之则需要执行                inv=!inv;            else&#123;                scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);                if(op==3 &amp;&amp; right[Y] == X )&#123; // 需要交换x,y的位置, 并且y的右边就是x                    swap(X,Y);                &#125;                // 没有真正的翻转链表产生的副作用, 我们只是记录了是否需要翻转链表.                // 因此, 假如需要翻转链表, 那么需要放在左边就变成了需要放在右边, 反之同理                if(op!=3 &amp;&amp; inv)&#123;                    op=3-op;                &#125;                if(op==1 &amp;&amp; X==left[Y]) continue; //需要将x插入到y的左边, 但是x已经在y的左边                if(op==2 &amp;&amp; X==right[Y]) continue; //需要将x插入到y的右边, 但是x已经在y的右边                // 两个节点的左右位置信息                int LX=left[X], RX=right[X],LY=left[Y], RY=right[Y];                if(op==1)&#123; // x 到 y 左边                    link(LX, RX);                    link(LY,X);                    link(X,Y);                &#125;                if(op==2)&#123; // x 到 y 右边                    link(LX, RX);                    link(Y,X);                    link(X,RY);                &#125;                if(op==3)&#123; // x,y 互换                    if(right[X]==Y)&#123;                        link(LX, Y);                        link(Y,X);                        link(X,RY);                    &#125;else&#123;                        link(LX, Y);                        link(Y, RX);                        link(LY, X);                        link(X, RY);                    &#125;                &#125;            &#125;        &#125;        int b=0;        ll ans=0;        // 从左边向右边遍历        for(int i=1;i&lt;=n;i++)&#123;            b=right[b];            if(i%2==1)                ans+=b;        &#125;        // 如果需要翻转, 并且链表长度为偶数的话. ps奇数长度的话, 和是不会变的        if(inv &amp;&amp; n%2==0) ans=(ll)n*(n+1)/2-ans;        printf(&quot;Case %d: %lld\\n&quot;,++kase,ans);    &#125;    return 0;&#125;\n\n复习时看 https://blog.csdn.net/richenyunqi/article/details/86563744?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.channel_param\n\n*小球下落\n\nhttps://www.luogu.com.cn/problem/UVA679\n\n12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxd=20;int s[1&lt;&lt;maxd]; // 2^(maxd)-1int main()&#123;    int D,I;// 深度, 个数    while(scanf(&quot;%d%d&quot;,&amp;D,&amp;I)==2)&#123;        memset(s, 0, sizeof(s));        int k,n=(1&lt;&lt;D)-1; // 最大节点编号为 2^(D-1)        for(int i=0;i&lt;I;i++)&#123;            k=1;            while(1)&#123;                s[k]=!s[k]; // 改变开关状态                k=s[k]?k*2:k*2+1; // 走左边还是右边                if(k&gt;n) break;            &#125;        &#125;        printf(&quot;%d&quot;,k/2); // 最后出界的节点编号    &#125;    return 0;&#125;\n对于一个节点, 使用变量 x 记录滚该位置的小球个数, 小球第 奇数 次滚过该位置时则朝左儿子滚, 小球第 偶数 次滚过时, 则朝右儿子滚.\n使用变量 ans 记录当前位置.\n\n朝左儿子滚的话 ans=2*ans\n朝右儿子滚的话 ans=2*ans+1\n\n当前小球 i 是第几个经过该节点的: (i+1)/2\n1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123;    int d,i;    while(scanf(&quot;%d%d&quot;,&amp;d,&amp;i)==2)&#123;        int j=1,k=1; // j 是当前小球所在节点        for(int k=1;k&lt;d;k++)&#123;  //滚动次数            if(i%2==0) //如果是偶数点(true)                j=j*2+1; //j标记向右            else //如果是奇数点(false)                j*=2;  //j标记向左            i=(i+1)/2; //实际下落        &#125;        printf(&quot;%d&quot;,j);    &#125;&#125;\n树与二叉树\n指针实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include &lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef struct Node&#123;    bool hava_value;    int v;    Node * left,*right;    Node():left(NULL),right(NULL),hava_value(false)&#123;&#125;;&#125;Node;Node* newNode()&#123;return new Node();&#125;const int maxn=10e5+5;char s[maxn];Node* root;bool failed;void addNode(int v,char s[])&#123;    int n=strlen(s);    Node* u=root;    for(int i=0;i!=n;i++)&#123;        char ch=s[i];        if(ch==&#x27;L&#x27;)&#123;            if(u-&gt;left=NULL)                u-&gt;right=newNode();            u=u-&gt;left;        &#125;else if(ch==&#x27;R&#x27;)&#123;            if(u-&gt;left=NULL)                u-&gt;right=newNode();            u=u-&gt;right;        &#125;        if(u-&gt;hava_value) failed=true;        u-&gt;v=v;        u-&gt;hava_value=true;    &#125;&#125;void remove_tree(Node* u)&#123;    if(u==NULL )return ;    if(!u-&gt;left)        remove_tree(u-&gt;left);    if(!u-&gt;right)        remove_tree(u-&gt;right);    delete u;&#125;bool read_input()&#123;    failed=false;    root=newNode();    while(1)&#123;        if(scanf(&quot;%s&quot;,s)!=1) return false;        if(strcmp(s,&quot;()&quot;)) break;        int v;        sscanf(&amp;s[1], &quot;%d&quot;,&amp;v);        addNode(v,strchr(s,&#x27;,&#x27;)+1);    &#125;    return true;&#125;bool bfs(vector&lt;int&gt;&amp; ans)&#123;    queue&lt;Node*&gt; q;    ans.clear();    q.push(root);    while(!q.empty())&#123;        Node* u=q.front();q.pop();        if(!u-&gt;hava_value) failed=true;        ans.push_back(u-&gt;v);        if(!u-&gt;left) q.push(u-&gt;left);        if(!u-&gt;right) q.push(u-&gt;right);    &#125;    return true;&#125;\n数组实现\n12345678910111213141516const int root=1;const int maxn=10e5+5;int left[maxn],right[maxn],have_value[maxn];int cnt;void newTree()&#123;    left[root]=right[root]=0;    have_value[root]=false;    cnt=0;&#125;int newNode()&#123;    int u=++cnt;    left[u]=right[u]=0;    have_value[root]=false;    return u;&#125;\n树\n\nhttps://www.luogu.com.cn/problem/UVA548\n\n做的想吐, 慢慢来慢慢来\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include&lt;queue&gt;#include &lt;algorithm&gt;using  namespace std;// 直接使用权值作为节点编号const int maxv=10e4+10;int in_order[maxv],post_order[maxv],lch[maxv],rch[maxv];int n;bool read_list(int* a)&#123;    string line;    if(!getline(cin,line))return false;    stringstream ss(line);    n=0;    int x;    // 向数组里面吐数据. n 是吐出来数字个数    while(ss&gt;&gt;x)&#123;        a[n++]=x;    &#125;    return n&gt;0;&#125;int build(int L1,int R1,int L2,int R2)&#123;    if(L1&gt;R1)        return 0;    // 根节点是后序遍历的最后一个节点    int root=post_order[R2];    // 找到根节点在中序遍历中的位置    int p=L1;    while(in_order[p]!=root)p++;    int cnt=p-L1; // 左子树节点数量    // 注意这种划分方式, 要考    lch[root]=build(L1,p-1,L2,L2+cnt-1);    rch[root]=build(p+1,R1,L2+cnt,R2-1);    return root;&#125;int best,best_sum;// 到目前的最优解和对应的权值的和void dfs(int u,int sum)&#123;    sum+=u;    if(!lch[u]&amp;&amp;!rch[u])&#123;// 叶子        if(sum&lt;best_sum||(sum==best_sum&amp;&amp;u&lt;best))&#123;            best=u;            best_sum=sum;        &#125;    &#125;    if(lch[u]) dfs(lch[u],sum);    if(rch[u]) dfs(rch[u],sum);&#125;int main() &#123;    while(read_list(in_order)&amp;&amp;read_list(post_order))&#123;        build(0, n-1, 0, n-1);        best_sum=1000000000;        dfs(post_order[n-1],0);        cout&lt;&lt;best&lt;&lt;endl;    &#125;    return 0;&#125;\n*天平\n\nhttps://www.luogu.com.cn/problem/UVA839\n\n令人绝望的递归\n12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;iostream&gt;using  namespace std;bool solve(int&amp; w)&#123;    int w1,d1,w2,d2;    bool b1=true, b2=true;    cin&gt;&gt;w1&gt;&gt;d1&gt;&gt;w2&gt;&gt;d2;    if(w1==0) b1=solve(w1); // 左子树    if(w2==0) b2=solve(w2); // 右子树    w=w1+w2; // 回溯, 记录总重量    return b1&amp;&amp;b2&amp;&amp;(w1*d1==w2*d2); // 左右以及它本身&#125;int main()&#123;    int t,w;    cin&gt;&gt;t;    while(t--)&#123;        if(solve(w))            cout&lt;&lt;&quot;YES\\n&quot;;        else            cout&lt;&lt;&quot;NO\\n&quot;;        if(t)            cout&lt;&lt;endl;    &#125;    return 0;&#125;\n下落的树叶\n\nhttps://www.luogu.com.cn/problem/UVA699\n\n汇总到最左边和最右边的边节点上, 输出边界点\n不会\n","plink":"https://mvbbb.github.io/lsrgfy/"},{"title":"JDBC与mysql数据库交互","date":"2020-09-27T01:07:41.000Z","date_formatted":{"ll":"Sep 27, 2020","L":"09/27/2020","MM-DD":"09-27"},"updated":"2021-02-03T04:20:59.949Z","content":"原生 JDBC 获取数据库连接\n方式一: 最简单的\n12345678910111213141516171819202122@Testpublic void testConnection1() &#123;    try &#123;        //1.提供java.sql.Driver接口实现类的对象        Driver driver = null;        driver = new com.mysql.jdbc.Driver();        //2.提供url，指明具体操作的数据        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        //3.提供Properties的对象，指明用户名和密码        Properties info = new Properties();        info.setProperty(&quot;user&quot;, &quot;root&quot;);        info.setProperty(&quot;password&quot;, &quot;abc123&quot;);        //4.调用driver的connect()，获取连接        Connection conn = driver.connect(url, info);        System.out.println(conn);    &#125; catch (SQLException e) &#123;        e.printStackTrace();    &#125;&#125;\n实现简单\n方式二: 使用反射\n123456789101112131415161718192021222324@Testpublic void testConnection2() &#123;    try &#123;        //1.实例化Driver        String className = &quot;com.mysql.jdbc.Driver&quot;;        Class clazz = Class.forName(className);        Driver driver = (Driver) clazz.newInstance();        //2.提供url，指明具体操作的数据        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        //3.提供Properties的对象，指明用户名和密码        Properties info = new Properties();        info.setProperty(&quot;user&quot;, &quot;root&quot;);        info.setProperty(&quot;password&quot;, &quot;abc123&quot;);        //4.调用driver的connect()，获取连接        Connection conn = driver.connect(url, info);        System.out.println(conn);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n方式三: 使用 DriverManager\n12345678910111213141516171819202122232425262728293031323334@Testpublic void testConnection4() &#123;    try &#123;        //1.数据库连接的4个基本要素：        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        String user = &quot;root&quot;;        String password = &quot;abc123&quot;;        String driverName = &quot;com.mysql.jdbc.Driver&quot;;        //2.加载驱动 （①实例化Driver ②注册驱动）        Class.forName(driverName);        //Driver driver = (Driver) clazz.newInstance();        //3.注册驱动        //DriverManager.registerDriver(driver);        /*            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：            static &#123;                try &#123;                    DriverManager.registerDriver(new Driver());                &#125; catch (SQLException var1) &#123;                    throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);                &#125;            &#125;             */        //3.获取连接        Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n说明：不必显式的注册驱动了。因为在 DriverManager 的源码中已经存在静态代码块，实现了驱动的注册。\n方式四: 使用配置文件\n123456789101112131415161718192021@Testpublic  void testConnection5() throws Exception &#123;    //1.加载配置文件    InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);    Properties pros = new Properties();    pros.load(is);    //2.读取配置信息    String user = pros.getProperty(&quot;user&quot;);    String password = pros.getProperty(&quot;password&quot;);    String url = pros.getProperty(&quot;url&quot;);    String driverClass = pros.getProperty(&quot;driverClass&quot;);    //3.加载驱动    Class.forName(driverClass);    //4.获取连接    Connection conn = DriverManager.getConnection(url,user,password);    System.out.println(conn);&#125;\n其中，配置文件声明在工程的 src 目录下：【jdbc.properties】\n1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver\n说明：使用配置文件的方式保存配置信息，在代码中加载配置文件\n\n使用配置文件的好处：\n① 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码\n② 如果修改了配置信息，省去重新编译的过程。\n\n使用 PreparedStatement 实现 CRUD 操作\n增删改\n1234567891011121314151617181920212223242526//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123;    Connection conn = null;    PreparedStatement ps = null;    try &#123;        //1.获取数据库的连接        conn = JDBCUtils.getConnection();        //2.获取PreparedStatement的实例 (或：预编译sql语句)        ps = conn.prepareStatement(sql);        //3.填充占位符        for(int i = 0;i &lt; args.length;i++)&#123;            ps.setObject(i + 1, args[i]);        &#125;        //4.执行sql语句        ps.execute();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;finally&#123;        //5.关闭资源        JDBCUtils.closeResource(conn, ps);    &#125;&#125;\n查询\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;    Connection conn = null;    PreparedStatement ps = null;    ResultSet rs = null;    try &#123;        // 1.获取数据库连接        conn = JDBCUtils.getConnection();        // 2.预编译sql语句，得到PreparedStatement对象        ps = conn.prepareStatement(sql);        // 3.填充占位符        for (int i = 0; i &lt; args.length; i++) &#123;            ps.setObject(i + 1, args[i]);        &#125;        // 4.执行executeQuery(),得到结果集：ResultSet        rs = ps.executeQuery();        // 5.得到结果集的元数据：ResultSetMetaData        ResultSetMetaData rsmd = rs.getMetaData();        // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值        int columnCount = rsmd.getColumnCount();        if (rs.next()) &#123;            T t = clazz.newInstance();            for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列                // 获取列值                Object columnVal = rs.getObject(i + 1);                // 获取列的别名:列的别名，使用类的属性名充当                String columnLabel = rsmd.getColumnLabel(i + 1);                // 6.2使用反射，给对象的相应属性赋值                Field field = clazz.getDeclaredField(columnLabel);                field.setAccessible(true);                field.set(t, columnVal);            &#125;            return t;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        // 7.关闭资源        JDBCUtils.closeResource(conn, ps, rs);    &#125;    return null;&#125;\n使用 Druid 数据库连接池获取数据库连接\n123456789public class TestDruid &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\tProperties pro = new Properties();        pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\t\tDataSource ds = DruidDataSourceFactory.createDataSource(pro);\t\tConnection conn = ds.getConnection();\t\tSystem.out.println(conn);\t&#125;&#125;\nApache-DBUtils 实现 CRUD 操作\n增删改\n1234567891011121314151617181920212223242526// 测试添加@Testpublic void testInsert() throws Exception &#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;\tint count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);\tSystem.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);\tJDBCUtils.closeResource(conn, null);&#125;// 测试删除@Testpublic void testDelete() throws Exception &#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;delete from customers where id &lt; ?&quot;;\tint count = runner.update(conn, sql,3);\tSystem.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);\tJDBCUtils.closeResource(conn, null);&#125;\n查询\nResultSetHandler 接口及实现类, 用于接收查询结果.\n该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\nResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。\n接口的主要实现类：\n\n\nArrayHandler：把结果集中的第一行数据转成对象数组。\n\n\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到 List 中。\n\n\n**BeanHandler：**将结果集中的第一行数据封装到一个对应的 JavaBean 实例中。\n\n\n**BeanListHandler：**将结果集中的每一行数据都封装到一个对应的 JavaBean 实例中，存放到 List 里。\n\n\nColumnListHandler：将结果集中某一列的数据存放到 List 中。\n\n\nKeyedHandler(name)：将结果集中的每一行数据都封装到一个 Map 里，再把这些 map 再存到一个 map 里，其 key 为指定的 key。\n\n\n**MapHandler：**将结果集中的第一行数据封装到一个 Map 里，key 是列名，value 就是对应的值。\n\n\n**MapListHandler：**将结果集中的每一行数据都封装到一个 Map 里，然后再存放到 List\n\n\n**ScalarHandler：**查询单个值对象\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;select id,name,email,birth from customers where id = ?&quot;;\tBeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);\tCustomer customer = runner.query(conn, sql, handler, 23);\tSystem.out.println(customer);\tJDBCUtils.closeResource(conn, null);&#125;/* * 测试查询:查询多条记录构成的集合 * 使用ResultSetHandler的实现类：BeanListHandler */@Testpublic void testQueryList() throws Exception&#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;;\tBeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);\tList&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);\tlist.forEach(System.out::println);\tJDBCUtils.closeResource(conn, null);&#125;/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;select id,name,email,birth from customers where id = ?&quot;;\tResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;\t\t@Override\t\tpublic Customer handle(ResultSet rs) throws SQLException &#123;\t\t\tSystem.out.println(&quot;handle&quot;);            if(rs.next())&#123;                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                String email = rs.getString(&quot;email&quot;);                Date birth = rs.getDate(&quot;birth&quot;);                return new Customer(id, name, email, birth);\t\t\t&#125;\t\t\treturn null;\t\t&#125;\t&#125;;\tCustomer customer = runner.query(conn, sql, handler, 23);\tSystem.out.println(customer);\tJDBCUtils.closeResource(conn, null);&#125;/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */@Testpublic void testQueryValue() throws Exception&#123;\tQueryRunner runner = new QueryRunner();\tConnection conn = JDBCUtils.getConnection3();\tString sql = &quot;select max(birth) from customers&quot;;\tScalarHandler handler = new ScalarHandler();\tDate birth = (Date) runner.query(conn, sql, handler);\tSystem.out.println(birth);\tJDBCUtils.closeResource(conn, null);&#125;\n数据库事务\n12345678910111213141516171819202122232425262728293031323334353637public void testJDBCTransaction() &#123;\tConnection conn = null;\ttry &#123;\t\t// 1.获取数据库连接\t\tconn = JDBCUtils.getConnection();\t\t// 2.开启事务\t\tconn.setAutoCommit(false);\t\t// 3.进行数据库操作\t\tString sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;\t\tupdate(conn, sql1, &quot;AA&quot;);\t\t// 模拟网络异常\t\t//System.out.println(10 / 0);\t\tString sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;\t\tupdate(conn, sql2, &quot;BB&quot;);\t\t// 4.若没有异常，则提交事务\t\tconn.commit();\t&#125; catch (Exception e) &#123;\t\te.printStackTrace();\t\t// 5.若有异常，则回滚事务\t\ttry &#123;\t\t\tconn.rollback();\t\t&#125; catch (SQLException e1) &#123;\t\t\te1.printStackTrace();\t\t&#125;    &#125; finally &#123;        try &#123;\t\t\t//6.恢复每次DML操作的自动提交功能\t\t\tconn.setAutoCommit(true);\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125;        //7.关闭连接\t\tJDBCUtils.closeResource(conn, null, null);    &#125;&#125;\n参考文档\n推荐文章使用 Java 实现简单的 WebServer《码出高效》笔记Java 细节Practical Java筆記","plink":"https://mvbbb.github.io/hy5u9w/"},{"title":"LeetCode 数据库","date":"2020-09-21T09:29:48.000Z","date_formatted":{"ll":"Sep 21, 2020","L":"09/21/2020","MM-DD":"09-21"},"updated":"2021-02-03T04:20:59.961Z","content":"176 第二高的薪水\n\nhttps://leetcode-cn.com/problems/second-highest-salary\n\n1234select ifnull(    (select distinct salary from Employee order by salary desc limit 1,1),    null)as &#x27;SecondHighestSalary&#x27;;\n181   超过经理收入的员工\n\nhttps://leetcode-cn.com/problems/employees-earning-more-than-their-managers/\n\n123select e1.name as Employee from Employee e1join Employee e2on e1.ManagerId=e2.Id and e1.Salary &gt; e2.Salary;\n182 查找重复的电子邮箱\n\nhttps://leetcode-cn.com/problems/duplicate-emails/\n\n看到“找重复”的关键字眼，首先要用分组函数（group by），再用聚合函数中的计数函数 count()给姓名列计数。\n123select Email from Persongroup by Emailhaving count(Email)&gt;1;推荐文章MySQL 基础","plink":"https://mvbbb.github.io/ce37t7/"},{"title":"MySQL 基础","date":"2020-09-19T03:49:05.000Z","date_formatted":{"ll":"Sep 19, 2020","L":"09/19/2020","MM-DD":"09-19"},"updated":"2021-02-03T04:21:00.225Z","content":"练习网站 学习 MySQL 这一篇就够了\nSQL 教程 MySQL 教程\n\nMySQL 命令\n表中具有几个概念：列、行、主键。 列叫做字段(Column),行叫做表中的记录,每一个字段都有:字段名称/字段数据类型/字段约束/字段长度\n那么 SQL 语句包括增删改查，SQL 语句怎么分类呢？\n\nDQL（数据查询语言 Data Query Language）: 查询语句，凡是 select 语句都是 DQL。\nDML（数据操作语言 Data Manipulation Language）：insert delete update，对表当中的数据进行增删改。\nDDL（数据定义语言 Data Definition Language）：create drop alter，对表结构的增删改。\nTCL（事务控制语言 Transactional Control Language）：commit 提交事务，rollback 回滚事务。(TCL 中的 T 是 Transaction)\nDCL（数据控制语言 Data Control Language）: grant 授权、revoke 撤销权限等。\n\n常见 SQL 命令\nshow datebases;\ncreate database ;\nuse ;\nshow tables;\n删除数据库：drop database ;\n查看表结构: desc ;\n查看表内容:  select * from ;\n查看 MySQL 版本: select version();\n查看当前数据库名称: select database();\n退出: exit;\n查看别的数据库的表: show tables from ;\n查看创建表的语句：show create table ;\n什么是 sql 脚本呢？\n当一个文件的扩展名是.sql，并且该文件中编写了大量的 sql 语句，我们称这样的文件为 sql 脚本。\n注意：直接使用 source 命令可以执行 sql 脚本。\nsql 脚本中的数据量太大的时候，无法打开，请使用 source 命令完成初始化。\n基本 SELECT\n简单的查询语句:\n语法格式：  select 字段名 1,字段名 2,字段名 3,… from 表名;\n\nsql 语句不区分大小写。\n\n查询员工的年薪？（字段可以参与数学运算。）\nselect ename,sal * 12 from emp; \n  给查询结果的列重命名？\nselect ename,sal * 12 as yearsal from emp; \n  别名中有中文？\nselect ename,sal * 12 as 年薪 from emp; // 错误 \nselect ename,sal * 12 as '年薪' from emp; \n注意：标准 sql 语句中要求字符串使用单引号括起来。虽然 mysql 支持双引号，尽量别用。\nas 关键字可以省略？\nmysql&gt; select empno,ename,sal * 12 yearsal from emp;\n条件查询需要用到 where 语句，where 必须放到 from 语句表的后面\n\n在数据库当中 NULL 不是一个值，代表什么也没有，为空。\n空不是一个值，不能用等号衡量。\n必须使用 is null 或者 is not null\nand 和 or 联合起来用：找出薪资大于 1000 的并且部门编号是 20 或 30 部门的员工。\nselect ename,sal,deptno from emp where sal &gt; 1000 and deptno = 20 or deptno = 30; // 错误的 \nselect ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30); // 正确的。 \n**   注意：当运算符的优先级不确定的时候加小括号。**\nin 等同于 or：\nselect ename,job from emp where job in('SALESMAN', 'MANAGER');\n*模糊查询 like **\n找出名字当中含有 O 的？\n   （在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是）\n   %代表任意多个字符，*代表任意 1 个字符。\n   select ename from emp where ename like '%O%'; \n找出名字中第二个字母是 A 的？\nselect ename from emp where ename like '_A%'; \n找出名字中最后一个字母是 T 的？\nselect ename from emp where ename like '%T'; \n查询结果去重 distinct  distinct 只能出现在所有字段的最前面。\nselect distinct job from emp;\n排序 ORDER BY\n默认是升序. asc 表示升序，desc 表示降序。\n123select ename , sal from emp order by sal; // 升序select ename , sal from emp order by sal asc; // 升序select ename , sal from emp order by sal desc; // 降序。\n按照工资的降序排列，当工资相同的时候再按照名字的升序排列。\n12select ename,sal from emp order by sal desc;select ename,sal from emp order by sal desc , ename asc;\n注意：越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。\norder by 是最后执行的\n分组/聚合函数\ncount 计数, sum 求和, avg 平均值, max 最大值, min 最小值\n1select sum(sal) from emp where JOB=&#x27;CLERK&#x27;;\n所有的分组函数都是对“某一组”数据进行操作的。\n找出工资总和？\n select sum(sal) from emp;\n找出最高工资？\n select max(sal) from emp;\n找出最低工资？\n select min(sal) from emp;\n找出平均工资？\n select avg(sal) from emp;\n找出总人数？\n select count(*) from emp;\n select count(ename) from emp;\n分组函数一共 5 个。\n分组函数还有另一个名字：多行处理函数。\n多行处理函数的特点：输入多行，最终输出的结果是 1 行。\n分组函数自动忽略 NULL。\n所有数据库都是这样规定的，只要有 NULL 参与的运算结果一定是 NULL。\n使用 ifnull 函数：ifnull(可能为 NULL 的数据,被当做什么处理) ： 属于单行处理函数。\nselect ename,(sal+ifnull(comm,0))*12 as yearsal from emp; \nsum 函数自动忽略 null\n分组函数也能组合起来用：\nselect count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;\ncount(*)和 count(具体的某个字段)，他们有什么区别？\ncount(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）\ncount(comm): 表示统计 comm 字段中不为 NULL 的数据总数量。\ngroup by ： 按照某个字段或者某些字段进行分组。\nhaving : having 是对分组之后的数据进行再次过滤。\n注意：分组函数一般都会和 group by 联合使用，这也是为什么它被称为分组函数的原因。\n并且任何一个分组函数（count sum avg max min）都是在 group by 语句执行结束之后才会执行的。\n当一条 sql 语句没有 group by 的话，整张表的数据会自成一组。\n为什么 where 里面不能用分组函数 where avl(sal)&gt; 10; ?\n因为只有等 where 执行之后~~ group by 才能执行~~, 之后才会去分组函数, 在组内运算.\n123456789101112select\t\t5\t\t..\tfrom\t\t\t1\t\t..\twhere\t\t\t2\t\t..\tgroup by\t\t3\t\t..\thaving\t\t4\t\t..\torder by\t\t6\t\t..\n记住一个规则：当一条语句中有 group by 的话，select 后面只能跟分组函数和参与分组的字段。\n分组查询\n分组查询主要涉及到两个子句，分别是：group by 和 having\n一个完整的 select 语句格式如下\n123456select 字段from 表名where …….group by ……..having …….(就是为了过滤分组后的数据而存在的—不可以单独的出现)order by ……..\n以上语句的执行顺序\n\n首先执行 where 语句过滤原始数据\n执行 group by 进行分组\n执行 having 对分组数据进行操作\n执行 select 选出数据\n执行 order by 排序\n原则：能在 where 中过滤的数据，尽量在 where 中过滤，效率较高。having 的过滤是专门对分组之后的数据进行过滤的。\n\n连接查询 JOIN\n在表的连接查询方面有一种现象被称为：笛卡尔积现象。\n笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。\n关于表的别名：\nselect e.ename,d.dname from emp e,dept d; \n表的别名有什么好处？\n  第一：执行效率高。\n  第二：可读性好。\n内连接中的等值连接\n12345678select\te.ename,d.dnamefrom\temp ejoin\tdept don\te.deptno = d.deptno;\n内连接的非等值连接\n工资-&gt;工资等级\n1234mysql&gt; select e.ename , e.sal,s.grade    -&gt; from emp e    -&gt; join salgrade s    -&gt; on e.sal between s.losal and s.hisal;\n自连接: 一张表看出两张不同的表\n什么是外连接，和内连接有什么区别？\n内连接：\n  假设 A 和 B 表进行连接，使用内连接的话，凡是 A 表和 B 表能够匹配上的记录查询出来，这就是内连接。\n AB 两张表没有主副之分，两张表是平等的。\n外连接：\n  假设 A 和 B 表进行连接，使用外连接的话，AB 两张表中有一张表是主表，一张表是副表，主要查询主表中\n  的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出 NULL 与之匹配。\n外连接的分类？\n  左外连接（左连接）：表示左边的这张表是主表。\n  右外连接（右连接）：表示右边的这张表是主表。\n  左连接有右连接的写法，右连接也会有对应的左连接的写法。\n123456789外连接：（右外连接/右连接）select\ta.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from\temp bright join\temp aon\ta.mgr = b.empno;\nUNION 并集\n123select * from emp where job=&#x27;MANAGER&#x27;unionselect * from emp where job=&#x27;SALESMAN&#x27;\n合并结果集的时候，需要查询字段对应个数相同。在 Oracle 中更严格，不但要求个数相同，而且还要求类型对应相同。\nLIMIT 的使用\nselect * from table limit m,n \n其中 m 是指记录开始的 index，从 0 开始，表示第一条记录\nn 是指从第 m+1 条开始，取 n 条。\nselect * from tablename limit 2,4 \n即取出第 3 条至第 6 条，4 条记录\n123456789101112131415limit是sql语句最后执行的一个环节：\tselect\t\t5\t\t...\tfrom\t\t\t1\t\t...\twhere\t\t\t2\t\t...\tgroup by\t\t3\t\t...\thaving\t\t4\t\t...\torder by\t\t6\t\t...\tlimit\t\t\t7\t\t...;\n分页的 sql 语句 limit (PageNo-1)*PageSize, PageSize;\n表\n创建表\n1234567891011121314create table tableName(   columnName dataType(length),   ………………..   columnName dataType(length));set character_set_results=&#x27;gbk&#x27;;show variables like &#x27;%char%&#x27;;创建表的时候，表中有字段，每一个字段有：     * 字段名     * 字段数据类型     * 字段长度限制     * 字段约束\n常用数据类型\n int   整数型 (java 中的 int)\n bigint 长整型 (java 中的 long)\n float   浮点型 (java 中的 float double)\n char   定长字符串 (String)\n varchar 可变长字符串 (StringBuffer/StringBuilder)\n date   日期类型 （对应 Java 中的 java.sql.Date 类型）\n BLOB   二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应 java 中的 Object）\n CLOB   字符大对象（存储较大文本，比如，可以存储 4G 的字符串。）\nCharacter Large OBject（对应 java 中的 Object）\n增/删/改 DDL\n1234567891011//删除表drop table if exists t_student;//添加字段alter table t_student add  contact_tel varchar(40);//修改字段alter table t_student modify student_name varchar(100) ;alter table t_student change sex gender char(2) not null;//删除字段alter table t_student drop contact_tel;\n增/删/改 DML\n123//添加记录insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10)insert into emp values(9999,&#x27;zhangsan&#x27;,&#x27;MANAGER&#x27;, null, null,3000, 500, 10);\n如何插入日期：\n第一种方法，插入的日期格式和显示的日期格式一致\n第二种方法，采用 str_to_date\n第三种方法，添加系统日期（now()）\n123insert into emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) values(9997,&#x27;zhangsan&#x27;,&#x27;MANAGER&#x27;, null, &#x27;1981-06-12&#x27;,3000, 500, 10);insert into emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) values(9996,&#x27;zhangsan&#x27;,&#x27;MANAGER&#x27;,null,str_to_date(&#x27;1981-06-12&#x27;,&#x27;%Y-%m-%d&#x27;),3000, 500, 10);insert into emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) values(9995,&#x27;zhangsan&#x27;,&#x27;MANAGER&#x27;,null,now() ,3000, 500, 10);\n表复制\n1create table emp_bak as select empno,ename,sal from emp;\n以上方式，会自动创建表，将符合查询条件的数据自动复制到创建的表中\n如何将查询的数据直接放到已经存在的表中，可以使用条件\n1insert into emp_bak select * from emp where sal=3000;\n数据更新\n可以修改数据，可以根据条件修改数据\n1update 表名 set 字段名称1=需要修改的值1, 字段名称2=需要修改的值2 where ……\n数据删除\n1delete from表名 where 。。。。。\n创建表加入约束\n常见的约束\na) 非空约束，not null\nb) 唯一约束，unique  \nc) 主键约束，primary key\nd) 外键约束，foreign key\ne) 自定义检查约束，check（不建议使用）(在 mysql 中现在还不支持)\n**非空约束，**针对某个字段设置其值不为空，如：学生的姓名不能为空\n12345678910drop table if exists t_student;create table t_student(\tstudent_id  \tint(10),\tstudent_name \tvarchar(20) not null,\tsex\t\tchar(2)  default  &#x27;m&#x27;,\tbirthday\tdate,\temail\t\tvarchar(30),\tclasses_id\tint(3))//加入不符合约束条件的内容会报错\n**唯一约束 unique **唯一性约束，它可以使某个字段的值不能重复，如：email 不能重复：[每个字段一个约束-列级约束]\n123456789101112drop table if exists t_student;create table t_student(\tstudent_id  \tint(10),\tstudent_name \tvarchar(20) not null,\tsex\t\tchar(2)  default  &#x27;m&#x27;,\tbirthday\tdate,\temail\t\tvarchar(30)  unique,\tclasses_id\tint(3))insert into t_student(student_id, student_name , sex, birthday, email, classes_id)values(1001,&#x27;zhangsan&#x27;,&#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10)\n给两个列或者多个列添加 unique [多个字段联合添加一个约束-表级约束]\n1234567drop table if exists t_user;create table t_user(  \tid int,  \tusercode varchar(255),  \tusername varchar(255),  \tunique(usercode,username) // 多个字段联合起来添加1个约束unique 【表级约束】);\n注意：not null 约束只有列级约束。没有表级约束。\n主键约束: 不为空且不能重复\n123456drop table if exists t_user;create table t_user(  id int primary key,  // 列级约束  username varchar(255),  email varchar(255));\n主键约束, 主键值, 主键字段\n主键有什么作用？\n\n表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。\n主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。）\n\n**  主键的分类:**\n  根据主键字段的字段数量来划分：\n\n单一主键（推荐的，常用的。）\n复合主键 (多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）\n\n根据主键性质来划分：\n\n自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）\n业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。\n\n一张表的主键约束只能有 1 个。（必须记住）\nmysql 提供主键值自增：（非常重要。）\n12345drop table if exists t_user;  create table t_user(  \tid int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。  \tusername varchar(255)  );\n外键约束: 子表引用父表的某一字段\n关于外键约束的相关术语：\n\n外键约束: foreign key\n外键字段：添加有外键约束的字段\n外键值：外键字段中的每一个值。\n\n删除先删子, 再删除父表\n创建的时候先创建父表, 后创建子表\n外键可以为 NULL。 \n外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？\n注意：被引用的字段不一定是主键，但至少具有 unique 约束。\n12345678910111213drop table if exists t_student;create table t_student(\tstudent_id  \tint(10),\tstudent_name \tvarchar(20),\tsex\t\tchar(2),\tbirthday\tdate,\temail\t\tvarchar(30),\tclasses_id\tint(3),\tconstraint student_id_pk primary key(student_id),  // 外键约束\tconstraint fk_classes_id foreign key(classes_id) references t_classes(classes_id))\nMySQL 函数\n\n数字函数\n\n\n日期函数\n\n\n\n\n字符函数\n\n\n条件函数\n\n\n事务 TCL\n12345678SET AUTOCOMMIT=false;START TRANSACTION ;SELECT * FROM dept;UPDATE dept set LOC=&#x27;BEIJIN&#x27; WHERE LOC=&#x27;NEW YORK&#x27;;SELECT * FROM  dept;ROLLBACK ;# COMMITSELECT * FROM  dept;\n关于事务\n一个事务是一个完整的业务逻辑单元，不可再分。\n比如：银行账户转账，从 A 账户向 B 账户转账 10000.需要执行两条 update 语句：\n12update t_act set balance = balance - 10000 where actno = &#x27;act-001&#x27;;update t_act set balance = balance + 10000 where actno = &#x27;act-002&#x27;;\n以上两条 DML 语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。\n要想保证以上的两条 DML 语句同时成功或者同时失败，那么就需要使用数据库的**“事务机制”**。\n和事务相关的语句只有：DML 语句。（insert delete update）\n为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。\n事务的存在是为了保证数据的完整性，安全性。\n假设所有的业务都能使用 1 条 DML 语句搞定，还需要事务机制吗？\n不需要事务。\n但实际情况不是这样的，通常一个“事儿（事务【业务】）”需要多条 DML 语句共同联合完成。\n事务的特性？\n事务包括四大特性：ACID\nA(Atomicity): 原子性：事务是最小的工作单元，不可再分。\nC(Consistency): 一致性：事务必须保证多条 DML 语句同时成功或者同时失败。\nI(Isolation)：隔离性：事务 A 与事务 B 之间具有隔离。\nD(Durability)：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。\n事务中存在一些概念：\na) 事务（Transaction）：一批操作（一组 DML）\nb) 开启事务（Start Transaction）\nc) 回滚事务（rollback）\nd) 提交事务（commit）\ne) SET AUTOCOMMIT：禁用或启用事务的自动提交模式\n并发过程中存在的问题\n1 . 丢失更新问题\n2 . 读&quot;脏&quot;数据问题\n3 . 不可重复读\n关于隔离级别\n关于事务之间的隔离性\n  事务隔离性存在隔离级别，理论上隔离级别包括 4 个：\n**   第一级别：读未提交（read uncommitted）**\n允许一个事务可以看到其他事务未提交的修改。\n    对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。\n    读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。\n**   第二级别：读已提交（read committed）**\n允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。\n    这种隔离级别解决了: 脏读现象没有了。\n    读已提交存在的问题是：不可重复读。\n每次对方修改, 都读取不到之前的数据, 不可重复读\n**   第三级别：可重复读（repeatable read）**\n确保如果在一个事务中执行两次相同的 SELECT 语句，都能得到相同的结果，不管其他事务是否提交这些修改。 （银行总账）\n    这种隔离级别解决了：不可重复读问题。\n事务期间, 读取的数据不变, 不管别的事务是否对硬盘数据进行操作\n    这种隔离级别存在的问题是：读取到的数据是幻象。\n**   第四级别：序列化读/串行化读（serializable）  **\n别的事务结束了, 本事务才能操作\n    解决了所有问题。\n将一个事务与其他事务完全地隔离。 \n    效率低。需要事务排队。\noracle 数据库默认的隔离级别是：读已提交。\nmysql 数据库默认的隔离级别是：可重复读。\nmysql 事务默认情况下是自动提交的。\n什么是自动提交？只要执行任意一条 DML 语句则提交一次。）怎么关闭自动提交？\n1mysql&gt; start transaction;\n设置隔离级别\n**通过修改配置文件设置  **\n可以在 my.ini 文件中使用 transaction-isolation 选项来设置服务器的缺省事务隔离级别。  \n该选项值可以是：  \n– READ-UNCOMMITTED\n– READ-COMMITTED\n– REPEATABLE-READ\n– SERIALIZABLE\n例如：\n12[mysqld]transaction-isolation = READ-COMMITTED\n通过命令动态设置隔离级别\n隔离级别也可以在运行的服务器中动态设置，应使用 SET TRANSACTION ISOLATION LEVEL 语句。  \n其语法模式为：\nSET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; \n其中的可以是：\n– READ UNCOMMITTED\n– READ COMMITTED\n– REPEATABLE READ\n– SERIALIZABLE\n例如：\n1SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n查看隔离级别\n服务器变量 tx_isolation  包括会话级和全局级两个变量）中保存着当前的会话隔离级别。  \n为了查看当前隔离级别，可访问 tx_isolation  变量：  \n查看会话级的当前隔离级别：\n12mysql&gt; SELECT @@tx_isolation;mysql&gt; SELECT @@session.tx_isolation;\n查看全局级的当前隔离级别：\n1mysql&gt; SELECT @@global.tx_isolation;\n索引\n什么是索引？有什么用？\n索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。\n在数据库方面，查询一张表的时候有两种检索方式：\n  第一种方式：全表扫描\n  第二种方式：根据索引检索（效率很高）\n索引为什么可以提高检索效率呢？ 其实最根本的原理是缩小了扫描的范围。\n索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。\n添加索引是给某一个字段，或者说某些字段添加索引。\n select ename,sal from emp where ename = ‘SMITH’;\n  当 ename 字段上没有添加索引的时候，以上 sql 语句会进行全表扫描，扫描 ename 字段中所有的值。\n  当 ename 字段上添加索引的时候，以上 sql 语句会根据索引扫描，快速定位。\n什么时候考虑给字段添加索引？（满足什么条件）\n\n数据量庞大。（根据客户的需求，根据线上的环境）\n该字段很少的 DML(插入,删除)操作。（因为字段进行修改操作，索引也需要维护）\n该字段经常出现在 where 子句中。（经常根据哪个字段查询）\n该字段经常出现在连接操作的连接条件中.\n\n注意：主键和具有 unique 约束的字段自动会添加索引。根据主键查询效率较高。尽量根据主键检索。\n12给薪资sal字段添加索引：create index emp_sal_index on emp(sal);\n索引底层采用的数据结构是：B + Tree\n索引的分类\n\n单一索引：给单个字段添加索引\n复合索引: 给多个字段联合起来添加 1 个索引\n主键索引：主键上会自动添加索引\n唯一索引：有 unique 约束的字段上会自动添加索引\n\n索引的实现原理？\n通过 B Tree 缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。\n123select ename from emp where ename = &#x27;SMITH&#x27;;通过索引转换为：select ename from emp where 物理地址 = 0x3;\n索引什么时候失效？\nselect ename from emp where ename like '%A%'; \n模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。\n视图\n什么是视图？\n站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。\n怎么创建视图？怎么删除视图？\n12create view myview as select empno,ename from emp;drop view myview;\n注意：只有 DQL 语句才能以视图对象的方式创建出来。\n对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）\n可以对视图进行 CRUD 操作。\n1234create table emp_bak as select * from emp;create view myview1 as select empno,ename,sal from emp_bak;// 创建视图update myview1 set ename=&#x27;hehe&#x27;,sal=1 where empno = 7369; // 通过视图修改原表数据。delete from myview1 where empno = 7369; // 通过视图删除原表数据。\n视图的作用\n视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java 程序员只对视图对象进行 CRUD。\n通过多表连接产生的视图, 每次修改只能修改来自其中一张表的数据.\n数据库设计三范式\n\nhttps://segmentfault.com/a/1190000013695030 &gt; https://blog.csdn.net/wuyanxiaxia/article/details/22933021\n\n第一范式: 原子性\n每个字段都必须是原子的, 不可再分. 一个字段只存储一项信息\n在某个业务需求中: 字段 年月日 假如可以被分成 年,月,日 ,就必须将改字段分为 3 个字段\n第二范式: 唯一性\n每一行都必须满足唯一性,   不同属性完全依赖于同一个主键. 任意一个字段都只依赖表中的同一个字段. 假如依赖于两个字段就需要将该表拆分为两个表.\neg:比如不符合第二范式\n\n\n学生证 名称\n学生证号\n学生证办理时间\n借书证名称\n借书证号\n借书证办理时间\n\n\n改成 2 张表如下\n学生证表\n\n\n学生证\n学生证号\n学生证办理时间\n\n\n借书证表\n\n\n借书证\n借书证号\n借书证把你拉时间\n\n\n第三范式: 冗余性\n要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖\neg:爸爸资料表，不满足第三范式\n\n\n爸爸\n儿子\n女儿\n女儿的小熊\n女儿的海绵宝宝\n\n\n改成\n爸爸信息表：\n\n\n爸爸\n儿子\n女儿\n\n\n女儿信息表\n\n\n女儿\n女儿的小熊\n女儿的海绵宝宝\n\n\n一对一设计，有两种设计方案:\n第一种设计方案：主键共享\n第二种设计方案：外键唯一\n推荐文章LeetCode 数据库P2P系统后端设计","plink":"https://mvbbb.github.io/zwggs9/"},{"title":"换了一个评论系统","date":"2020-09-17T14:50:17.000Z","date_formatted":{"ll":"Sep 17, 2020","L":"09/17/2020","MM-DD":"09-17"},"updated":"2021-02-03T04:21:00.229Z","content":"之前用的来必力评论系统, 前端感觉挺丑的, 后台管理系统也挺丑的, 还经常无法登录后台, 加载还有点慢\n\n现在发现一个新的评论系统 utteranc.es, 基于 GithubIssue\n\n\n\n先使用一段时间, 之后写篇对比\n","plink":"https://mvbbb.github.io/yn4ex1/"},{"title":"原来","date":"2020-09-11T05:54:40.000Z","date_formatted":{"ll":"Sep 11, 2020","L":"09/11/2020","MM-DD":"09-11"},"updated":"2021-02-03T04:21:00.237Z","content":"原来我的小破站还是有浏览量的嘛. 虽然说还是很少\n\n应该都是通过链接直接访问的吧.\nSEO 的优化不到位 !\n\n\n之后再改改\n","plink":"https://mvbbb.github.io/gp9wvc/"},{"title":"D(la)P(ji)","date":"2020-09-10T07:39:28.000Z","date_formatted":{"ll":"Sep 10, 2020","L":"09/10/2020","MM-DD":"09-10"},"updated":"2021-02-03T04:21:00.281Z","content":"https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns\n被 dp 整的不要不要的, 要命, 要命\n看不懂就背下来\n\ndp 模板分类\n\nMinimum (Maximum) Path to Reach a Target 到达目标的最小(最大)路径\nDistinct Ways 不同路径\nMerging Intervals 合并区间\nDP on Strings 字符串上的 dp\nDecision Making 决策问题\n\n最大(小)路径\n模板类似于\n12345678for (int i = 1; i &lt;= target; ++i) &#123;   for (int j = 0; j &lt; ways.size(); ++j) &#123;       if (ways[j] &lt;= i) &#123;           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;       &#125;   &#125;&#125;return dp[target]\n类似的问题: 爬楼梯, 最小路径, 零钱兑换, 下降路径最小和…\n931 下降路径最小和\n有点像那个三角形最小路径和的问题, 不过现在变成了正方形\n从下面开始向上遍历\n1234567891011121314151617181920212223class Solution &#123;    public int minFallingPathSum(int[][] A) &#123;        int n=A.length;        for(int i=n-2;i&gt;=0;i--)&#123;            for(int j=0;j!=n;j++)&#123;                int min=A[i+1][j];                if(j&gt;0)&#123;                    min=Math.min(min,A[i+1][j-1]);                &#125;                if(j&lt;n-1)&#123;                    min=Math.min(min,A[i+1][j+1]);                &#125;                A[i][j]+=min;            &#125;        &#125;        int res=Integer.MAX_VALUE;        for(int i=0;i!=n;i++)&#123;            res=Math.min(A[0][i],res);        &#125;        return res;    &#125;&#125;\n983 最低票价\n记忆化递归\ndp[i]\n\n在没有任何通行证生效时, 能够从第 i 天到最后的旅行计划的最小花费, 如果你需要在第 i 天出行, 你的最小花费是\ndp[i+30]+costs[2]  表示购买为期 30 天的火车票的花费+第 (i+30) 旅行到最后的花费\n假如第 i 天通行证有效, 那么 \n\n123456789101112131415161718192021222324252627282930class Solution &#123;    int[] costs;    Integer[] memo;    Set&lt;Integer&gt; dayset;    public int mincostTickets(int[] days, int[] costs) &#123;        this.costs = costs;        memo = new Integer[366];        dayset = new HashSet();        for (int d: days) &#123;            dayset.add(d);        &#125;        return dp(1);    &#125;    public int dp(int i) &#123;        if (i &gt; 365) &#123;            return 0;        &#125;        if (memo[i] != null) &#123;            return memo[i];        &#125;        if (dayset.contains(i)) &#123;            memo[i] = Math.min(Math.min(dp(i + 1) + costs[0], dp(i + 7) + costs[1]), dp(i + 30) + costs[2]);        &#125; else &#123;            memo[i] = dp(i + 1);        &#125;        return memo[i];    &#125;&#125;\n动态规划\n1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;    public int mincostTickets(int[] days, int[] costs) &#123;        //判断        if(days == null || days.length == 0 ||                costs == null || costs.length == 0) &#123;            return 0;        &#125;        int maxDay=days[days.length - 1];        //dp表示到了当天花的最低票价        int[] dp = new int[days[days.length - 1]+1]; //dp数组涵盖最长的天数        dp[0] = 0;//        //标记一下需要买票的日子        for(int day: days) &#123;            dp[day] = Integer.MAX_VALUE;        &#125;        for(int i = 1; i &lt; dp.length; i++) &#123;            //不需要买票            if(dp[i] == 0) &#123;                //不需要买票花费的钱就是前一天的花费                dp[i] = dp[i - 1];            &#125;else &#123;                int n1 = dp[i - 1] + costs[0];                /**如果今天距离第一天已经超过7天了                 * 则花费: dp[i-7](7天前已经花费的钱)+cost[1](7天前买了一张7天的票)                 * 否则就是直接第一天买了一张7天票                 */                int n2 = i &gt; 7 ? dp[i - 7] + costs[1] : costs[1];                //30天与7天 同理                int n3 = i &gt; 30 ? dp[i - 30] + costs[2] : costs[2];                dp[i] = Math.min(n1, Math.min(n2, n3));            &#125;        &#125;        //最后一天花费多少钱        return dp[maxDay];    &#125;&#125;\n650 只有两个键的键盘\n素数分解\n对于一个非素数 i, 他总是可以分解成两个数相乘 x*j , 把这 j 个数目字符 copy 1 次, paste x-1 次\n1234567891011121314class Solution &#123;    public int minSteps(int n) &#123;        int []dp=new int[n+1];        for(int i=2;i&lt;=n;i++)&#123;            int min=Integer.MAX_VALUE;            for(int j=1;j&lt;i;j++)&#123;                if(i%j==0)                    min=Math.min(dp[j]+i/j,min);            &#125;            dp[i]=min;        &#125;        return dp[n];    &#125;&#125;\n*279 完全平方数\n123456789101112class Solution &#123;    public int numSquares(int n) &#123;        int[] dp = new int[n + 1]; // 默认初始化值都为0        for (int i = 1; i &lt;= n; i++) &#123;            dp[i] = i; // 最坏的情况就是每次+1            for (int j = 1; i - j * j &gt;= 0; j++) &#123;                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程            &#125;        &#125;        return dp[n];    &#125;&#125;\n不同路径\n\n给定一个目标，找到达到给目标的方法数\n\n123456789for (int i = 1; i &lt;= target; ++i) &#123;   for (int j = 0; j &lt; ways.size(); ++j) &#123;       if (ways[j] &lt;= i) &#123;           dp[i] += dp[i - ways[j]];       &#125;   &#125;&#125;return dp[target]\n*1155 掷骰子的 N 种方法\n从前向后的递推\ndp[i][j]=x;\n扔 i 个骰子, 数字总和为 j 的方法数为 x\n在骰子数为 i 的情况下, 得到 target=j 的方法数为 骰子数为 i-1 的情况下, 得到 target=j-(1…f) 的求和总数\n\n1234567891011121314151617181920class Solution &#123;    private static final int MOD = 1000000007;    public int numRollsToTarget(int d, int f, int target) &#123;        int[][] dp =new int[31][1001];        int min=Math.min(f,target);        for(int i=1;i&lt;=min;i++)&#123;            dp[1][i]=1;// 扔了一个骰子,        &#125;        int targetMax=d*f;// 每次扔到值为1的骰子,达到 target 的次数为 d*f        for(int i=2;i&lt;=d;i++)&#123; // 骰子数目递增            for(int j=i;j&lt;=targetMax;j++)&#123; // 在骰子数固定的情况下, 达到               // 新投的一个骰子面值为 k               for (int k = 1; j - k &gt;= 0 &amp;&amp; k &lt;= f; k++) &#123;                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD;                &#125;            &#125;        &#125;        return dp[d][target];    &#125;&#125;\n合并区间\n字符串上的 dp\n决策问题\n推荐文章自顶向下与自底向上力扣-动态规划Leetbook 初级算法动态规划系列-子数组最大和","plink":"https://mvbbb.github.io/vf5dyb/"},{"title":"《码出高效》笔记","date":"2020-09-08T02:43:20.000Z","date_formatted":{"ll":"Sep 8, 2020","L":"09/08/2020","MM-DD":"09-08"},"updated":"2021-02-03T04:21:00.457Z","content":"one more flag!\n感觉这本书比较的基础, 阅读难度不大, 但是干货很多. 可以说是极其不错的一本 BeginnerFriendlyBook\n适合人群: 学完 Java 语法基础, 想要学习部分底层知识的人群.\n\n\n第一章 计算机基础\n暂时跳过\n第二章 面向对象\nOOP 理念\n\n慎用 Object 类的 clone() 方法来拷贝对象, 因为对象的 clone() 方法默认是浅拷贝, 若想实现深拷贝需要覆写 clone() 方法实现引用对象的深度遍历式拷贝\n里氏代换原则 LSP: 任何父类出现的地方, 子类都能够出现. 实际代码环境中, 如果父类引用直接使用子类对象的引用来替代, 可以正确的编译执行, 说明两个类之间符合 LSP 原则, 可以使用继承关系\n继承树过高可能会产生方法爆炸, 所以提倡使用组合优先的原则来扩展类的能力, 即优先采用组合或聚合的类关系来复用其他类的能力, 而不是继承.\n严格意义上来说, 多态并不是面向对象的一种特性, 而是一种由继承衍生而来的一种能力\n\n初始 Java\nJava 很优秀 :)\n类\n\ngetter/setter 方法一般放在类方法最后\n接口与抽象类的区别 详见 p54\n\n当纠结定义接口还是抽象类的时候, 优先推荐定义为接口, 遵循接口隔离原则, 按照某个维度划分为多个接口, 然后用抽象类去实现某些接口, 这样做可以方便后续的扩展和重构\n内部类本身是类的一个属性, 与其他属性定义方式一致\n\n使用静态内部类的好处\n\n作用域不会扩散到包外\n可以使用 外部类.内部类 的方式直接访问\n内部类可以访问外部类的所有静态属性和方法\n\n\n访问权限控制 详见 p59\n\n权限从严\n\n如果子类调用父类的某个构造方法, super 就会不断往上回溯, 如果没有指定, 则默认调用 super(), 如果父类没有提供默认构造的方法, 子类在继承的时候会报错.\n如果父类坚持不提供默认的无参构造方法, 必须在本类的误餐构造方法中显式的使用 super 调用父类的有参构造方法\nsuper 与 this 的异同点\n\n类之间的关系\n\n常见的序列化方法\n\nJava 原生序列化: 实现 Serializable 接口(不推荐使用)\nHessian 序列化: 将复杂对象的所有属性存储在一个 Map 中进行序列化\nJSON 序列化: 将数据对象转化为 JSON 字符串\n\n\n\n方法\n\nJVM 标识方法的唯一索引: 方法签名, 包括方法名称和参数列表. 可以解释为什么返回类型不能作为函数重载判断元素的原因\n(函数风格约定)函数传参过程中: 每一个逗号后面都必须要一个空格\nJava 中只有值传递\n尽量不要使用可变参数编程\n函数参数的规约 p70 页\n类定义时提供了一个默认的无参构造函数, 但是假如我们定义了一个有参构造函数, 则无参构造函数会被覆盖. 若还想拥有必须显示定义\n类在创建的过程中会先执行父类和子类的静态代码块, 之后再执行父类和子类构造函数. 静态代码块之后被执行一次\n当字节码文件 .class 被加载之后, 实例方法并不会被分配方法入口地址, 只有在对象创建之后才会分配. 实例方法可以调用静态变量和静态方法.\n调用静态方法时尽量使用 类名.静态方法 , 提高运行效率\n静态方法中不能使用实例成员变量和实例方法\n静态方法中不能使用 this.super 关键字, 这两个关键字指代的都是需要被创建出来的对象\n工具类的静态方法与单例模式相伴而生\n非静态代码块 (局部代码块) 不推荐使用\n静态代码块不能包含于任何方法体中\n类中方法的定义顺序: 公有方法或保护方法&gt;私有方法&gt;getter/setter 方法\ngetter/setter 方法容易出现的问题\n\ngetter/setter 中添加业务逻辑\n同时定义 isXxx() 和 getXxx() 方法: iBATIS 的反射机制会筛选出以 get 和 is 开头的方法, 但是只会保留一个, 容易造成业务冲突\n相同的属性名容易带来歧义: 对于非 getter/setter 方法参数名称不能和成员变量相同\n\n\n如果某个类覆写了父类的某个方法, 则方法表中的方法指向引用会指向子类的实现处. 这是实现多态的重要因素.\n向上转型通过父类引用调用子类的方法需要注意的几点\n\n\n无法调用子类中存在而父类中不存在的方法\n可以调用到子类中覆写的父类的方法, 这是一种多态实现\n\n\n想要成功覆写父类的方法需要注意一下几点:\n\n\n访问权限不能变小\n返回类型能够向上转型为父类的返回类型\n异常也要能向上转型成为父类的异常 方法名,参数个数, 参数类型必须全部一致\n覆写只能针对非静态, 非 final, 非构造方法\n\n重载\n\nJVM 在重载方法中的选择优先级\n\n精确匹配\n如果是基本数据类型, 自动转型为更大表示范围的基本类型\n通过自动拆箱与装箱\n通过子类向上转型路径依次匹配\n通过可变参数匹配\n\n\n重载又被称为静态绑定\n\n泛型\n\n尖括号里面的每一个元素都指代一种未知类型.  与 String 指代的是不同的\n尖括号的位置非常讲究, 必须在类名之后, 或者方法返回值之前\n泛型在定义处只具备执行 Object 方法的能力\n对于编译之后的字节码文件, 其实没有花头花脑的方法签名, 充分说明了泛型只是一种编写代码时的语法检查\n使用泛型的好处\n\n类型安全\n提升可读性\n代码重用\n\n\n\n数据类型\n\n\n引用变量均占 4b 空间, 实际对象初始的分配空间至少是 16b\n对象头最小占用空间为 12b\n对象分为 3 块存储区域\n\nInteger 会缓存 -127 到 128 之间的值. 推荐包装类之间的比较全部通过 .equals() 方法\n选择包装类还是基本数据类型, 推荐如下方法\n\n\n第三章 代码风格\n\n在 Java 中, 所有的变量均不能以 ‘_’ 开始或者结尾\n类名一般采用大驼峰式命名\n方法名, 变量(参数,成员变量) 一般采用小驼峰式命名\n全局常量和类常量的命名: 全部大写, 字母之间使用下划线连接\n局部常量使用小驼峰式命名\n包名统一使用小写, 使用单数形式, 但是如果类名有复数含义, 则可以使用复数形式\n抽象类名采用 Abstract/Base 开头, 异常类使用 Exception 结尾, 测试类使用 被测试的类名+Test\n数组定义: int[] a\n枚举类名带上 Enum 后缀, 枚举成员名称需要全部大写, 单词之间使用下划线分割\n不要在代码中直接使用 “魔法值”\n使用 4 个空格代替 tab\n空格的使用规约\n\n单个方法的长度不要超过 80 行\n换行规约\n\nif-else. 即使只有一条语句也需要 {}\n在条件表达式中不能出现赋值运算, 也不允许在条件表达式中出现复杂的逻辑组合\n多层嵌套不要超过 3 次\n避免使用逻辑取反 ! 运算符\n对枚举的注释\n\n\n第四章 走进 JVM\n\n在我能力范围之外了, 难\n之后再回过头来翻阅吧, 现在看的迷迷糊糊的\n\n字节码\n\n\n字节码是 Java 程序运行的中间文件, JVM 将字节码文件解释执行, 屏蔽对底层操作系统的依赖\n\n\n字节码文件的主要指令\n\n加载或者存储指令\n\n将局部变量加载在操作栈\n将操作栈存储到局部变量表\n将常量加载到操作栈顶, 这是极其高频的使用指令\n\n\n运算指令: 对两个操作栈帧进行运算, 并将结果写入操作栈顶\n类型转换指令: 显示地转换两种不同的数据类型\n对象的创建与访问指令: 根据类进行对象的创建, 初始化, 方法调用相关指令\n操作栈管理指令\n\n出栈操作\n复制栈顶元素并压入栈\n\n\n方法调用与返回指令: 调用对象的实例方法, 调用静态方法, 返回 VOID 类型, 调用实例初始化方法,私有方法,父类方法等.\n同步指令\n\n\n\n\n词法解析形成 token 信息流, 语法解析时将 token 信息流按照语法组装成一颗语法树, 在语义分析阶段需要检查关键词的使用是否合理, 类型是否匹配等, 语义分析完成之后即可生成字节码\n\n\nJIT 的作用: 将字节码多态编译成可以直接发送给处理器指令执行的机器码\n\n\n字节码的执行模式: (1) 解释执行 (2) JIT 编译执行 (3) JIT 编译与解释混合执行(主流 JVM 默认方式)\n\n\n混合执行的优势: 在解释器启动的时候先解释执行, 省去编译的时间, 之后 JVM 通过热点代码统计分析, 基于 JIT 多态编译技术, 将热点代码转换为机器码, 交给 CPU 执行\n\n\n类加载过程\n\nClassLoader 的任务是提前加载 .class 字节码文件到内存中\n加载类时使用的是 双亲委派模型\n类加载: 将 .class 字节码文件实例化为 Class 对象并进行初始化的过程.\n类加载过程\n\nLoad 阶段: 读取类文件产生二进制文件, 进行初步校验, 之后创建对应类的 Class 实例\nLink 阶段: 验证, 准备, 解析三个步骤. 验证是进行更加详细的检查. 准备阶段为静态变量分配内存, 设定默认值. 解析类和方法确保类与类之间相互引用的正确性,完成内存结构布局\nInit 阶段执行类构造器  方法\n\n\n\n\n\nClass 是所有 class 的类\n\n\n针对某个类, 底层次的类加载器只有在高层次的类加载器加载了该类之后才能加载该类. 逐级向上询问是否已经加载该类, 之后逐级向下尝试是否可以加载该类\n需要自定义类加载器的情形:\n\n隔离加载类\n修改类加载方式: 除了 Bootstrap 之外其他的加载不一定非要引入\n扩展加载源\n防止源码外泄\n\n\n实现自定义类加载器的步骤: 继承 ClassLoader, 重写 finalClass() 方法, 调用 defineClass() 方法\n\n内存布局\n\n\n堆区存储着几乎所有的实例对象, 堆由垃圾收集器自动回收, 堆区由各子线程共享\n堆分为两大块: 新生代和老年代. 新生代=1 个 Eden 区+2 个 Survivor 区\n\n元空间在本地内存中分配, JDK8 中, 除了字符串常量移至堆内存, 其他内容包括类元信息, 字段, 静态属性, 方法, 常量等都移动至元空间内\nJVM 是基于栈结构的运行环境.\n在活动线程中只有栈顶的帧才是有效的, 称为当前帧. 正在运行的方法称为当前方法, 栈帧是方法运行的基本结构\n\n\n对象实例化\n后补\n垃圾回收\n后补\n第五章 异常与日志\nthrow 用在方法内部, throws 用在方法签名处\n异常分类\n\n| 可预测异常\n| 空指针异常, 边界条件有误 |\n| — | — |\n| 需捕捉的异常 | 链接超时, 可以尝试重试, 或者降级处理 |\n| 可透出异常 | 使用框架时产生的异常, 并且框架可以处理 |\n| 引起注意型 | 不可避免,需要由开发者处理 |\n| 坦然处理型 | 授权失败, 重新授权 |\ntry 代码块\n\nfinally 语句没有执行的原因:\n\n\n注意 finally 语句在 return 语句之后执行, 先将 return 的结果暂存下来, 即使 finally 中改变了 return 的值, 返回值仍然不会变, 为之前暂存的值\n\n不要在 finally 语句中使用 return 语句\n对象加锁应该在 try 代码块之前, 不然即使加锁失败也会触发 finally 执行解锁, 会抛出异常\n\n异常的抛与接\n\n远程服务调用中推荐使用 Result 对象封装异常信息\n\n日志\n后补\n第六章 数据结构与集合\n集合框架图\n\n\nQueue 由于其本身的 FIFO 的特性和阻塞操作的特点, 经常被作为 Buffer 使用\nMap 类提供三种 Collection 视图: values(), entrySet(), keySet()\n多线程环境中推荐使用 ConcurrentHashMap, 而不是 HashMap\n\n集合初始化\nbookmark 154\nArrayList 扩容机制\n\n第一次 add , 发现数组大小等于待填入的数组索引, 使用 grow 扩容得到一个大小为 10 (由 newCapacity 判断数组为空) 的数组\n扩容公式: newCapacity=oldCapacity+(oldCapacity&gt;&gt;1). 如果 newCapacity 发生 int 溢出, 如果 newCapacity 大小比 minCapacity (2147483639) 要小的话, 就返回 newCapacity , 否则返回值为 size+1 的 minCapacity\n\nHashMap 中有两个比较重要的参数 Capacity(容量) 和 Load Factor(填充比例,一般为 0.75)\n参数 threshold = Capacity* Loadfactor 表示 HashMap 中可以放入的元素个数\n在第一次 put 时完成创建\n\nHashMap 的默认值大小为 16, ArrayList 大小为 10\n数组与集合\n使用 Arrays.adList() 之后, 它会把数组变成一个集合, 但是不可以使用 LIst 中修改集合相关的方法. set()是允许的, 但是 add(), remove() 是错误的. 这是适配器模式, List 的底层仍然是该数组, asList() 的返回对象是一个 Arrays 的内部类, 该类并没有实现集合个数修改的相关方法. 该类继承至抽象类 AbstractList , 但是只实现了一部分功能, 所以在使用有些 ArrayList 方法时会抛出异常\n解决方法\n1ArrayList&lt;Integer&gt; arrayList1 = new ArrayList&lt;&gt;(Arrays.asList(new Integer[]&#123;1, 2, 3&#125;));\n使用 集合.toArray() 会导致泛型丢失\n关于 toArray() 方法 Arr 分析参见 162 页\n使用集合的 toArray(T[] array) 方法, 转换为数组时, 注意需要传入类型完全一样的数组, 并且它的容量为 list.size();\nBookMark161\n集合与泛型\n推荐文章使用 Java 实现简单的 WebServerJDBC与mysql数据库交互Java 细节Go工程化(一) 架构整洁之道阅读笔记","plink":"https://mvbbb.github.io/sn0gdd/"},{"title":"Java 细节","date":"2020-09-06T10:58:03.000Z","date_formatted":{"ll":"Sep 6, 2020","L":"09/06/2020","MM-DD":"09-06"},"updated":"2021-02-03T04:21:00.497Z","content":"主要是 Java 学习过程中的小知识点\n\n集合\n\n参考 https://blog.csdn.net/ThinkWon/article/details/104588551\n\n\nHashSet, LinkedHashSet 实现的是 Collection 接口, 但是底层确是基于 HashMap\n实现 Collection 接口的集合的遍历: 可以随机访问的可以使用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。\n数组与 List 之间的转换\n\n\n数组转 List：使用 Arrays. asList(array) 进行转换。\nList 转数组：使用 List 自带的 toArray() 方法。\n\n\n线程不安全的情况下如何使用 ArrayList: 使用 Collections 提供的方法, 将 arrayList 转化为线程安全的\n\n1List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);\n\n向 HashMap 中添加 K/V 对: HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V。\n两个对象有相同的 hashcode 值，它们不一定是相等的. HashMap 里面添加元素, 出现 key 的 hashcode 相同时会进一步调用 equals. 相同, 原 K/V 被替换. 不相同, 放入该位置的链表中.\n在 Java 中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。\nJDK 1.7 与 JDK 1.8 中 HashMap 底层的区别\n\n\n类与对象\n\n\nJava 中主类是指 **类名与文件名一致, **且包含 main 的类\n\n\n公共类是指: public 修饰的类,该类名必须与文件名一致\n\n\n如果源文件中有多个类，这些类必须有一个 public 类\n\n\n可以把任何一种数据类型的变量赋给 Object 类型的变量。\n\n基本数据类型会自动装箱\n\n\n\n包提供可见性控制机制.\n\n\n在类方法中调用本类的类方法时可直接调用, 不能使用 this\n\n本类的方法是指 static 方法\n\n\n\n调用指向 null 的对象的静态方法是可以正确运行的, 属于静态绑定\n\n\ni =  ++(i++); 编译错误\n\n++（  ）   括号里面必须是一个变量，而 i ++   是一个字面量。\n\n\n\n在使用匿名内部类的过程中，我们需要注意如下几点：\n\n使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n匿名内部类中是不能定义构造函数的。\n匿名内部类中不能存在任何的静态成员变量和静态方法。\n匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n\nhttps://www.nowcoder.com/questionTerminal/9cbffe1607ff450580ae665d2625bce9\n\n\n\n\n\nInteger 的缓存区间是 [-128,127] , 在该区间内 120==120 true\n\n\nJava 在序列化时不会实例化 static 变量和 transient 修饰的变量，因为 static 代表类的成员，transient 代表对象的临时数据，被声明这两种类型的数据成员不能被序列化\n\n\n++/-- 优先级问题\n\n\n\nhttps://www.nowcoder.com/test/question/done?tid=37584420&amp;qid=304925#summary\n\n\nJava 提供的事件处理模型是一种人机交互模型。它有三个基本要素 1)事件源 2)事件对象 3)事件监听器\n\n异常处理\n\n不管有多少个 catch，只会匹配一个 catch\nfinally 一定会在 return 之前执行，但是如果 finally 使用了 return 或者 throw 语句，将会使 trycatch 中的 return 或者 throw 失效\nSimpleDateFormat 是线程不安全的\nConcurrentHashMap 使用 segment 来分段和管理锁，segment 继承自 ReentrantLock，因此 ConcurrentHashMap 使用 ReentrantLock 来保证线程安全。\n\n推荐文章使用 Java 实现简单的 WebServerJDBC与mysql数据库交互《码出高效》笔记Practical Java筆記","plink":"https://mvbbb.github.io/nwg3e5/"},{"title":"博客配置修改","date":"2020-08-19T04:16:53.000Z","date_formatted":{"ll":"Aug 19, 2020","L":"08/19/2020","MM-DD":"08-19"},"updated":"2021-02-03T04:21:00.601Z","content":"https://www.yzh.im/about/\n\n语雀防盗链和行内公式\n问题 语雀同步之后 latex 公式以图片的形式嵌入在了 md 文档中\n\n语雀的图片做了防盗链处理, 无法访问, 导致公式无法显示\n该主题的图片不能在行内显示, 也就是说尺寸比较小的图片都只能独行显示.\n\n解决方法\n\n防盗链问题: https://github.com/x-cold/yuque-hexo/issues/41 看不懂\n图片行内显示问题: css+html, 我在 css 文件中写了\n\n123img &#123;  display: inline-block;&#125;\n虽然是看起来是这么写,但是没什么卵用, 不知道怎么解决\n修改\n问题一解决了, 可算让我找到了插入的地方\n\n问题二也解决了\n\n1234路径themes\\yun\\layout\\_partial\\layout.pugmeta(name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot;)路径: themes\\yun\\scripts\\filters\\index.jsstyle&#x3D;&quot;display: inline-block; vertical-align:middle&quot;\n实现主题标题跳转到语雀\n\n路径: themes\\yun\\layout\\_partial\\post\\post-edit.pug\n123456789101112a.post -  edit -  link(    (href = theme.post_edit.url + &quot;/&quot; + page.urlname),    (target = &quot;_blank&quot;),    (title = __(&quot;post.edit&quot;)),    (rel = &quot;noopener&quot;)  ) +  icon(&quot;icon-edit-line&quot;);//- a.post-edit-link(href=theme.post_edit.url + page.source, target=&#x27;_blank&#x27;, title=__(&#x27;post.edit&#x27;), rel=&#x27;noopener&#x27;)//-   +icon(&#x27;icon-edit-line&#x27;)\n解决 localsearch 的相对地址问题\n地址 themes\\yun\\source\\js\\search\\local-search.js\n\n12345//str += `&lt;li&gt;&lt;a href=&quot;$&#123;data_url&#125;&quot; class=&quot;search-result-title&quot;&gt;$&#123;data_title&#125;&lt;/a&gt;`;str += `&lt;li&gt;&lt;a href=&quot;$&#123;data_url.substring(  1,  data_url.length)&#125;&quot; class=&quot;search-result-title&quot;&gt;$&#123;data_title&#125;&lt;/a&gt;`;推荐文章Bye! My 2020近期规划-碎碎念刷题!刷题!想学算法","plink":"https://mvbbb.github.io/qtd9qr/"},{"title":"自顶向下与自底向上","date":"2020-08-18T14:01:58.000Z","date_formatted":{"ll":"Aug 18, 2020","L":"08/18/2020","MM-DD":"08-18"},"updated":"2021-02-03T04:21:00.609Z","content":"参考 知乎回答 与算法导论第 15 章, 动态规划\n\n自顶向下: 斐波那契数列的递归实现, 阶乘\n1234int factorial(int n)&#123;    if(n==1) retrun 1;    return n*factorial(n--);&#125;\n求解问题时, 调用一个还未得到的函数, 子问题的答案未知.\n通常情况下, 在 dp 问题中, 使用递归的时候需要使用备忘录 memo 来减少重复计算\n**自底向上: **迭代法\n在求解问题时, 子问题的答案已经知道\n推荐文章D(la)P(ji)力扣-动态规划Leetbook 初级算法动态规划系列-子数组最大和","plink":"https://mvbbb.github.io/aa32vk/"},{"title":"力扣-动态规划","date":"2020-08-15T01:37:22.000Z","date_formatted":{"ll":"Aug 15, 2020","L":"08/15/2020","MM-DD":"08-15"},"updated":"2021-02-03T04:21:00.813Z","content":"终于算是迈入动态规划的学习了, 希望别被打击信心\n完美主义是使人停滞不前的主要原因. 不要总想着准备好了才开始做. 🌞\nhttps://leetcode-cn.com/problemset/all/?topicSlugs=dynamic-programming\n\n爬楼梯问题\n\nhttps://leetcode-cn.com/problems/climbing-stairs/\n\n好像在学离散数学的时候碰到过这道题\n暴力搜索, 回溯法\n\n当前可以走一步, 回溯法求剩下 n-1 阶的走法\n当前可以走两步, 回溯法求上下 n-2 阶的走法\n\n结果是 1+2 的方法总数\n12345public int climbStairs(int n) &#123;    if(n==1||n==2)        return n;    return climbStairs(n-1)+climbStairs(n-2);&#125;\n超时, 重复计算太多, 重复计算可以联想到斐波那契数列\n动态规划\n解题\n到达楼梯的第 i 阶有多少种爬法, 与第几阶的爬法直接相关, 如何递推的求出第 i 阶楼梯的爬法 ?\n第 i 阶爬法的数量 = 第 i-1 阶爬法的数量 + 第 i-2 阶爬法的数量\n\n\n123456789101112class Solution &#123;    public int climbStairs(int n) &#123;        // p是 i-2 , q是 i-1, r是当前        int p=0,q=0,r=1;        for(int i=1;i&lt;=n;i++)&#123;            p=q;            q=r;            r=p+q;        &#125;        return r;    &#125;&#125;\n总结\n\n确定原问题和子问题\n原问题是求 n 阶台阶的走法, 子问题是求 1 阶, 2 阶, 3 阶… n 阶台阶的走法\n确定状态\n本题的动态规划状态单一, 第 i 个状态即为 i 阶台阶的走法数量\n确定边界状态的值\n边界状态为 1 阶与 2 阶台阶的走法, 1 阶有一种走法, 2 阶有 2 种走法.\n确定状态转移方程\n将求第 i 个状态的值转换为求 i-1 和 i-2 状态的值, 动态规划转移方程是  \n\n打家劫舍\n\nhttps://leetcode-cn.com/problems/house-robber/\n\n枚举\n在不触发警报的情况下选择总和最大的子集. 最多有   种可能, 时间复杂度是 \n动态规划\n思路\n\n一下两种情况去最大值\n\n不偷这间房, 前 i 的最优解是 dp[i-1]\n偷这间房, 前 i 的最优解是 dp[i-2]+nums[i]\n\n这两种情况下不会产生同时偷相邻两间房的情况\n解答\n使用额外数组空间\n1234567891011121314class Solution &#123;    public int rob(int[] nums) &#123;        if(nums.length==0)            return 0;        int N=nums.length;        int[] dp=new int[N+1];        dp[0]=0;//没有房子        dp[1]=nums[0];//只有一间房子        for(int i=2;i&lt;=N;i++)&#123;            dp[i]=Math.max(dp[i-1],nums[i-1]+dp[i-2]);        &#125;        return dp[N];    &#125;&#125;\n时间复杂度  \n使用滚动数组\n在求解第 i 个时, 我们只用到了   的结果, 使用两个遍历来保存值\n12345678910111213141516public int rob(int[] nums) &#123;    int prev = 0;    int curr = 0;    // 每次循环，计算“偷到当前房子为止的最大金额”    for (int i : nums) &#123;        // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]        // dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;        int temp = Math.max(curr, prev + i);        prev = curr;        curr = temp;        // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]    &#125;    return curr;&#125;\n最大子序和\n动态规划\n思路\n若像前两道题一样思考, 假如求出来了前 i-1 个数 (dp[i-1]) 和前 i 个数 (dp[i]) 的最大子序和, 根据第 i 个数, 我们是否可以推导出 dp[i] 与 dp[i-1] 之间的关系?\n\n针对与每一个数组中的数, 找到它的最大子序和, 之后返回数组中最大子序和最大\n解答\n12345678910111213141516class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int[] dp=new int[nums.length];        dp[0]=nums[0];        int maxSub=dp[0];        for(int i=1;i!=nums.length;i++)&#123;            if(dp[i-1]&gt;0)                dp[i]=dp[i-1]+nums[i];            else                dp[i]=nums[i];            if(dp[i]&gt;maxSub)                maxSub=dp[i];        &#125;        return maxSub;    &#125;&#125;\n由于我们在求 dp[i] 时只使用了 dp[i-1], 空间优化版\n12345678910class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int pre=0,maxAns=nums[0];        for(var i:nums)&#123;            pre=Math.max(pre+i, i);            maxAns=Math.max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;\n买卖股票的最佳时机\n\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n\n枚举\n对于每一个数组中的元素, 遍历它之后的元素, 算出对应的盈利额, 最后找出最大的盈利额\n1234567891011121314151617class Solution &#123;      public int maxProfit(int[] prices) &#123;        int [] arr=new int[prices.length*prices.length/2+1];        int size=0;        for(int i=0;i!=prices.length;i++)&#123;            for(int j=0;j!=prices.length;j++)&#123;                if(j&gt;i)&#123;                    arr[size++]=prices[j]-prices[i];                &#125;            &#125;        &#125;        Arrays.sort(arr);       // System.out.println(Arrays.toString(arr)+arr[arr.length-1]);        return arr[arr.length-1]&gt;0?arr[arr.length-1]:0;      &#125;&#125;\n不出意外,  超时了\n其实大可不必使用一个数组来存储枚举结果. 优化后的枚举\n12345678910111213public int maxProfit(int[] prices) &#123;       int res=Integer.MIN_VALUE;       for(int i=0;i!=prices.length;i++)&#123;           for(int j=0;j!=prices.length;j++)&#123;               if(j&gt;i)&#123;                   int temp=prices[j]-prices[i];                   if(temp&gt;res)                       res=temp;               &#125;           &#125;       &#125;       return res;   &#125;\n\ntoo slow 时间复杂度 \n一次遍历\n\n依次遍历数组, 用 min_value 记录目前为止的最小值, 对于 prices[i]-min_value 得到一个当前利润, 使用 max_profit 来记录当前利润的最大值. 如果 prices[i]-min_value&lt;0 , 更新 min_value. prices[i]-min_value&gt;max_profit, 更新 max_profit\n12345678910111213141516class Solution &#123;    public int maxProfit(int[] prices) &#123;        int min_value=Integer.MAX_VALUE;        int max_profit=0;        for(int i=0;i!=prices.length;i++)&#123;            if (prices[i] &lt; min_value)                min_value = prices[i];            else if (prices[i] - min_value &gt; max_profit)                max_profit = prices[i] - min_value;        &#125;        return max_profit;    &#125;    public static void main(String[] args) &#123;        new Solution().maxProfit(new int[]&#123;7,1,5,3,6,4&#125;);    &#125;&#125;\n最小路径和\n状态的设置: dp[i][j] 代表从 (i,j)-&gt;(m-1,n-1) 的最小路径和\n状态转移方程: 考虑如何求出 dp[i][j]\n\n(i-1,j)-&gt;(i,j) dp[i][j] 的前继状态 dp[i-1][j]\n(i,j-1)-&gt;(i,j) dp[i][j] 的前继状态 dp[i][j-1]\n\n\n需要更新数组的值为到左上角的最短路径\n123456789101112131415161718192021222324class Solution &#123;    public int minPathSum(int[][] grid) &#123;        if(grid==null||grid.length==0)            return 0;        int rows=grid.length,columns=grid[0].length;        int [][]dp=new int[rows][columns];        dp[0][0]=grid[0][0];        //先解决数组第一列        for (int i = 1; i &lt; rows; i++) &#123;            dp[i][0] = dp[i - 1][0] + grid[i][0];        &#125;        //解决数组第一行        for (int j = 1; j &lt; columns; j++) &#123;            dp[0][j] = dp[0][j - 1] + grid[0][j];        &#125;        for(int i=1;i!=rows;i++)&#123;            for(int j=1;j!=columns;j++)&#123;                dp[i][j]=Math.min(dp[i-1][j], dp[i][j-1])+grid[i][j];            &#125;        &#125;        return dp[rows-1][columns-1];    &#125;&#125;\n时间复杂度与空间复杂度为 \n不同路径\n\nhttps://leetcode-cn.com/problems/unique-paths/\n\n这不就是排列组合吗, 并且类似于上一道题\n我的思路: 建立一个 dp 数组, 到达 dp[i][j] 的路径数是 dp[i-1][j]+dp[i][j-1], 初始条件是 dp[0][0]=1\n12345678910111213141516171819202122class Solution &#123;    public int uniquePaths(int m, int n) &#123;        int dp[][]=new int[m][n];        if(m==0||n==0)            return 0;        dp[0][0]=1;        for(int i=0;i!=m;i++)&#123;            dp[i][0]=1;        &#125;        for(int j=0;j!=n;j++)&#123;            dp[0][j]=1;        &#125;        for(int i=1;i!=m;i++)&#123;            for(int j=1;j!=n;j++)&#123;                dp[i][j]=dp[i-1][j]+dp[i][j-1];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;\n\n第一次自己过 dp ,感动\n时间复杂度   空间复杂度 \n尝试空间复杂度 思路: dp 中的每一个数的值是左边和上边的和, 假如尝试使用一维数组, 先全部初始化为 1\n123456789101112class Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[] cur = new int[n];        Arrays.fill(cur,1);        for (int i = 1; i &lt; m;i++)&#123;            for (int j = 1; j &lt; n; j++)&#123;                cur[j] += cur[j-1] ;            &#125;        &#125;        return cur[n-1];    &#125;&#125;\n一次只记一行，当换行的时候数组里存放的是第 i-1 行的数据. 遍历每一行的时候, 某个位置的值的左边是更新之后的值, 但是该位置的值是上一行的数据, +=得到该位置更新后的数据.\n判断子序列\n注意, 不是判断子串\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。\n\n双指针\np1 遍历 s, p2 遍历 t\n1234567891011121314151617class Solution &#123;    public boolean isSubsequence(String s, String t) &#123;        int p1=0,p2=0;        for(;p1!=s.length();p1++)&#123;            char c=s.charAt(p1);            while(p2&lt;t.length()&amp;&amp; t.charAt(p2)!=c)                p2++;            if(p2&gt;=t.length())                return false;            p2++;//记得跳过查找到的字符        &#125;        return true;    &#125;    public static void main(String[] args) &#123;        System.out.println(new Solution().isSubsequence(&quot;aaaaaa&quot;, &quot;bbaaaa&quot;));    &#125;&#125;\n\n更加简洁的代码\n12345678910111213class Solution &#123;    public boolean isSubsequence(String s, String t) &#123;        int n = s.length(), m = t.length();        int i = 0, j = 0;        while (i &lt; n &amp;&amp; j &lt; m) &#123;            if (s.charAt(i) == t.charAt(j)) &#123;                i++;            &#125;            j++;        &#125;        return i == n;    &#125;&#125;\n动态规划\n大多数时间花在根据指定字符之后在 t 里面去查找的过程中. 我们可以预处理出对于 tt 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。(力扣题解) 令  f[i][j] 表示字符串  t  中从位置  i  开始往后字符  j 第一次出现的位置。f[位置 i][字符j]= i 之后字符 j 第一次出现的位置\n\n12345678910111213141516171819202122232425262728293031class Solution &#123;    public boolean isSubsequence(String s, String t) &#123;        int n = s.length(), m = t.length();        int[][] f = new int[m + 1][26];        for (int i = 0; i &lt; 26; i++) &#123;            f[m][i] = m;        &#125;        for (int i = m - 1; i &gt;= 0; i--) &#123;            for (int j = 0; j &lt; 26; j++) &#123;                if (t.charAt(i) == j + &#x27;a&#x27;)                    f[i][j] = i;                else                    f[i][j] = f[i + 1][j];            &#125;        &#125;        int add = 0;        for (int i = 0; i &lt; n; i++) &#123;            if (f[add][s.charAt(i) - &#x27;a&#x27;] == m) &#123;                return false;            &#125;            add = f[add][s.charAt(i) - &#x27;a&#x27;] + 1;        &#125;        return true;    &#125;    public static void main(String[] args) &#123;        System.out.println(new Solution().isSubsequence(&quot;aaaaaa&quot;, &quot;bbaaaa&quot;));    &#125;&#125;\n三角形最小路径和\n\nhttps://leetcode-cn.com/problems/triangle/\n\n注意, 这道题的最短路径不是每次选择子节点的最小值, 步步最优不一定全局最优\n递归\n类似于求二叉树的最短路径\n123456789101112class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        return  dfs(triangle, 0, 0);    &#125;    private int dfs(List&lt;List&lt;Integer&gt;&gt; triangle, int i, int j) &#123;        if (i == triangle.size()) &#123;            return 0;        &#125;        return Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)) + triangle.get(i).get(j);    &#125;&#125;\ndfs 的任务, 得到根节点的值, 递归地得到子节点的最小值\n\nhttps://leetcode-cn.com/problems/triangle/solution/di-gui-ji-yi-hua-dp-bi-xu-miao-dong-by-sweetiee/\n\n写得还是不够熟练\n递归+记忆化\n使用二维数组来存储计算过后的值, 避免重复计算. 类似于斐波那契数列的优化方法\n123456789101112131415class Solution &#123;    Integer[][] memo;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        this.memo=new Integer[triangle.size()][triangle.size()]    ;        return dfs(triangle,0,0);    &#125;    public int dfs(List&lt;List&lt;Integer&gt;&gt; triangle,int i,int j)&#123;        if(i==triangle.size())            return 0;        if(memo[i][j]!=null)            return memo[i][j];        else            return Math.min(dfs(triangle,i+1,j),dfs(triangle,i+1,j+1))+triangle.get(i).get(j);    &#125;&#125;\n时间复杂度和空间复杂度都是 \n动态规划\n定义二维 dp 数组，将解法二中「自顶向下的递归」改为「自底向上的递推」。\n\nhttps://leetcode-cn.com/problems/triangle/solution/di-gui-ji-yi-hua-dp-bi-xu-miao-dong-by-sweetiee/\n\n怎么说呢, 这有点像递归的 for 循环迭代版 😄\ndp[i][j]  表示从点 (i, j) 到底边的最小路径和。\n状态转移方程:  \n边界条件  多定义一行一列（默认初始值 0），就不用判断边界了，动态规划常用方法\n12345678910111213class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        int minPath=0;        int height=triangle.size();        int[][] dp=new int[height+1][height+1];        for(int i=height-1;i&gt;=0;i--)&#123;            for(int j=0;j!=triangle.get(i).size();j++)&#123;                dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);            &#125;        &#125;        return dp[0][0];    &#125;&#125;\n时间复杂度和空间复杂度都是 \n动态规划空间优化\n优化思路类似于 “不同路径” 的优化思路\n定义一维数组\n在一轮遍历中使用 dp 方程时, 我们只是用到了数组中的一行数据. 执行 i 次遍历时, 数组中保存的是 i+1 行遍历时的数据\n123456789101112class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        int height=triangle.size();        int[] dp=new int[height+1];        for(int i=height-1;i&gt;=0;i--)&#123;            for(int j=0;j!=triangle.get(i).size();j++)&#123;                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);            &#125;        &#125;        return dp[0];    &#125;&#125;\n时间复杂度   空间复杂度 \n不同路径 Ⅱ\n动态规划\ndp[i][j] 定义为 (0,0) 到 (i,j) 的路径数目\n边界条件: dp[0][0]=1, dp[i][0]=1 , i 为 1 出现的前面的位置. dp[i][0]=0 ,i 为 1 出现及其后面的位置, dp[0][j] 同理\n状态转移方程: , 假如 , 证明该位置存在障碍物, .\n1234567891011121314151617181920class Solution &#123;    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        int dp[][]=new int[obstacleGrid.length][obstacleGrid[0].length];        int m=dp.length;        int n=dp[0].length;        for(int i=0;i!=m&amp;&amp;obstacleGrid[i][0]==0;i++)            dp[i][0]=1;        for(int j=0;j!=n&amp;&amp;obstacleGrid[0][j]==0;j++)            dp[0][j]=1;        for(int i=1;i!=m;i++)&#123;            for(int j=1;j!=n;j++)&#123;                if(obstacleGrid[i][j]==0)                    dp[i][j]=dp[i-1][j]+dp[i][j-1];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;\n时间复杂度和空间复杂度都是 \n我们还可以优化一下边界条件, 之前我们需要初始化 dp 数组的第一列和第一行, 更佳的方式是多给 dp 数组一行一列, 这是一种常用的优化方法.\n动态规划空间优化\n原理同 “不同路径-空间优化版”, 使用一位数组代替二维数组, 当开始遍历第 i 行时, 数组中存储的是 i-1 行的数据.\n同样的, 有障碍的位置的路径数为 0.\n123456789101112131415class Solution &#123;       public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        int m=obstacleGrid.length;        int n=obstacleGrid[0].length;        int dp[]= new int[n+1];        dp[1] = 1; //边界条件        for(int i=1;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                dp[j] = obstacleGrid[i-1][j-1] == 1 ? 0 : dp[j] + dp[j-1];            &#125;        &#125;        return dp[n];    &#125;&#125;\n空间复杂度是 , n 是列数\n*零钱兑换\n不是步步最优, 全局最优. 假如存在币值 1,5,7, 贪心算法会失效.\n\nhttps://leetcode-cn.com/problems/coin-change/solution/javadi-gui-ji-yi-hua-sou-suo-dong-tai-gui-hua-by-s/\n\n暴力递归\n考虑组成 amount 的硬币组合的最后一个硬币\n\n1234567891011121314151617181920212223class Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        if(coins.length==0)            return 0;        int res=helper(coins,amount,0);        return res==Integer.MAX_VALUE?-1:res;    &#125;    public int helper(int [] coins,int amount,int count)&#123;        if(amount&lt;0)            return Integer.MAX_VALUE;        if(amount==0)            return count;        int minCost=Integer.MAX_VALUE;        for(var lastCoin: coins)&#123;            int cost=helper(coins,amount-lastCoin,count+1);            if(cost&lt;minCost)                minCost=cost;        &#125;        return minCost;    &#125;&#125;\n记忆化搜索\n解决递归中存在的重复计算问题. 使用备忘录 memo \nmemo[n]  表示 amount=n  时需要的最小硬币数\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    int[] memo;    public int coinChange(int[] coins, int amount) &#123;        if(coins.length == 0)&#123;            return -1;        &#125;        memo = new int[amount+1];        return findWay(coins,amount);    &#125;    // findWay函数的目的是为了找到 amount数量的零钱可以兑换的最少硬币数量，返回其值int    public int findWay(int[] coins,int amount)&#123;        if(amount &lt; 0)&#123;            return -1;        &#125;        if(amount == 0)&#123;            return 0;        &#125;        if(memo[amount] != 0)&#123;            return memo[amount];        &#125;        int min = Integer.MAX_VALUE;        for(int coin:coins)&#123;            int res = findWay(coins,amount-coin);            if(res &gt;= 0 &amp;&amp; res &lt; min)&#123;                min = res + 1; // 加1，是为了加上得到res结果的那个步骤中，兑换的一个硬币            &#125;        &#125;        memo[amount] = (min == Integer.MAX_VALUE ? -1 : min);        return memo[amount];    &#125;    public static void main(String[] args) &#123;        System.out.println(new Solution().coinChange(new int[]&#123;1,2,5&#125;, 100));    &#125;&#125;\n动态规划: 自顶向下\ndp[i]=x, amout=i  时需要的最小硬币数是 x\n思想类似与递归问题的翻转, 我们递归之前是取出一个硬币, 之后求组成剩余 amount 的最小值. 转换思路, 从币值为 1 开始, 逐渐递增得到额定 amount 的最小值. 币值逐渐递增的过程中存在一个状态转移方程\n边界条件: dp[0]=0\n状态转移方程: , 其中 coin 为 coins 中的某一个\n1234567891011121314class Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        int[] dp = new int[amount+1];        for(int i=0; i&lt;=amount; i++) &#123;            dp[i] = i == 0 ? 0 : amount+1; //amount+1为不可能的值. dp[0]=0            for(int coin : coins) &#123;//不同币值的都来试一试, 凑出来                if( i -coin &gt;=0 ) &#123;                    dp[i] = Math.min(dp[i-coin] + 1, dp[i]);                &#125;            &#125;        &#125;        return dp[amount] == amount+1 ? -1 : dp[amount];    &#125;&#125;\n时间复杂度  s 是金额, n 是币值数\n空间复杂度   为 dp 数组空间\n贪心+DFS\nBFS\n最长公共子序列\n自底向上   动态规划\n最长公共子序列\n题解\n123456789101112131415161718class Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;        int n=text1.length();        int m=text2.length();        int dp[][]=new int[n+1][m+1];        for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(text1.charAt(i-1)==text2.charAt(j-1))                    dp[i][j]=dp[i-1][j-1]+1;                else                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;        return dp[n][m];    &#125;&#125;\n*动态规划 空间优化\n\n使用一维数组进行空间优化, 每次使用了 (i,j) 的左上方, 左边, 右边\n使用一维数组时, 遍历第 i 行时, 数组存储的是 i-1 行的数据, 遍历到第 j 个时, 前 j-1 个存储的是使用二维数组时 dp[i][j-1] 的数据 (左边) . 一维数组本身 dp[j] 存储的是原来二维数组 dp[i-1,j] 的数据(上边). 但是左上方的数据被覆盖了, 因此, 我们需要额外使用一个变量来存储左上角的数据\n123456789101112131415161718192021class Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;        int n=text1.length();        int m=text2.length();        int dp[]=new int[m+1];        int temp;        for(int i=1;i&lt;=n;i++)&#123;            int last=0;//保存相对于下次遍历的 (i-1,j-1) 的数(左上角)            for(int j=1;j&lt;=m;j++)&#123;                temp=dp[j];                if(text1.charAt(i-1)==text2.charAt(j-1))&#123;                    dp[j]=last+1;//左上角                &#125;else                    dp[j]=Math.max(dp[j],dp[j-1]);                last=temp;            &#125;        &#125;        return dp[m];    &#125;&#125;\n递归\n\n123456789101112131415161718class Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;        return  helper(text1,0,text2,0,0);    &#125;    public int helper(String text1,int i,String text2,int j,int res)&#123;        if(i==text1.length()||j==text2.length())            return res;        if(text1.charAt(i)==text2.charAt(j))&#123;            return helper(text1,i+1,text2,j+1,res+1);        &#125;else&#123;            return Math.max(helper(text1,i+1,text2,j,res),helper(text1,i,text2,j+1,res));        &#125;    &#125;    public static void main(String[] args) &#123;        System.out.println(new Solution().longestCommonSubsequence(&quot;abc&quot;,&quot;def&quot;));    &#125;&#125;\n暴力搜索\n使用备忘录的自顶向下的递归\n12345678910111213141516171819202122232425class Solution &#123;      int[][] memo;      public int longestCommonSubsequence(String text1, String text2) &#123;          memo=new int[text1.length()+1][text2.length()+1];          return  helper(text1,0,text2,0);      &#125;      public int helper(String text1,int i,String text2,int j)&#123;            if(i==text1.length()||j==text2.length())                return 0;            if(text1.charAt(i)==text2.charAt(j))&#123;               memo[i][j]= 1+helper(text1, i+1, text2, j+1);               return memo[i][j];            &#125;            else&#123;                int l1=memo[i+1][j]==0? helper(text1, i+1, text2, j): memo[i+1][j];                int l2=memo[i][j+1]==0? helper(text1, i, text2, j+1): memo[i][j+1];                memo[i][j]=Math.max(l1, l2);                return memo[i][j];            &#125;      &#125;      public static void main(String[] args) &#123;        System.out.println(new Solution().longestCommonSubsequence(&quot;pmjghexybyrgzczy&quot;,&quot;hafcdqbgncrcbihkd&quot;));    &#125;  &#125;\n\n最长上升子序列\n注意: 是上升子序列, 不一定连续\n\n题解\n\n动态规划\n状态定义: dp[i]  表示以 nums[i] 结尾的「上升子序列」的长度。注意：这个定义中  nums[i] 必须被选取，且必须是这个子序列的最后一个元素。\n**边界条件: **dp[1]=1\n123456789101112131415161718public int lengthOfLIS(int[] nums) &#123;    int[] dp = new int[nums.length];    // base case：dp 数组全都初始化为 1    Arrays.fill(dp, 1);    for (int i = 0; i &lt; nums.length; i++) &#123;        //我们这里不是要去数小于 nums[i] 的个数有多少个, 而是根据小于nums[i]对应的 LIS 来更新 nums[i]        for (int j = 0; j &lt; i; j++) &#123;            if (nums[i] &gt; nums[j])                dp[i] = Math.max(dp[i], dp[j] + 1);        &#125;    &#125;    int res = 0;    for (int i = 0; i &lt; dp.length; i++) &#123;        res = Math.max(res, dp[i]);    &#125;    return res;&#125;\n时间复杂度   空间复杂度 \n二分法\n见题解\n不同的二叉搜索树\n\nhttps://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-cong-yuan-shi-de-di-/\n\n递归\n选定一个节点 i 做为根节点, [1,i-1] 放在左子树, [i+1,n]放在右子树. 对左子树和右子树递归操作\n123456789101112class Solution    public int numTrees(int n) &#123;        if (n == 0 || n == 1) &#123;            return 1;        &#125;        int ans = 0;        for (int i = 1; i &lt;= n; i++) &#123;            ans += numTrees(i - 1) * numTrees(n - i);        &#125;        return ans;    &#125;&#125;\n备忘录+递归\n因为个数固定, 二叉搜索树的数量固定.\n使用备忘录记录数量为 n 的二叉搜索树的个数\n动态规划\n递归的迭代版\n条件转移: \ndp[i] 表示用 i 个节点构造出的二叉搜索树的方法总数\n12345678910111213class Solution &#123;    public int numTrees(int n) &#123;        int[] dp = new int[n + 1];        dp[0] = 1;        dp[1] = 1;        for (int i = 2; i &lt;= n; i++) &#123;            for (int j = 0; j &lt;= i - 1 ; j++) &#123;                dp[i] += dp[j] * dp[i - j - 1];            &#125;        &#125;        return dp[n];    &#125;&#125;\n完全平方数\n类似于零钱兑换问题, 不同的是, 这里的 零钱兑换中 coins 数组是不变的, 这道题要变\n123456789101112131415161718192021222324252627class Solution &#123;    public int numSquares(int n) &#123;        //dp[i]=x; 组成整数i的完全平方数的个数为x        int[] dp=new int[n+1];        for(int i=0;i!=dp.length;i++)            dp[i]=i;        int[] table=new int[(int) (Math.sqrt(n) + 1)];        for(int i=1;i&lt;table.length;i++)&#123;            table[i]= i*i;        &#125;        for(int i=1;i&lt;= n;i++)&#123;            for(int j=1;j!=table.length;j++)&#123;                if(i&gt;=table[j])&#123;                    dp[i]=Math.min(dp[i], dp[i-table[j]]+1);                &#125;            &#125;        &#125;        return  dp[n];    &#125;    public static void main(String[] args) &#123;         int x=new Solution().numSquares(13);         System.out.println(x);    &#125;&#125;\n时间复杂度\n代码优化\n123456789101112class Solution &#123;    public int numSquares(int n) &#123;        int[] dp = new int[n + 1]; // 默认初始化值都为0        for (int i = 1; i &lt;= n; i++) &#123;            dp[i] = i; // 最坏的情况就是每次+1            for (int j = 1; i - j * j &gt;= 0; j++) &#123;                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程            &#125;        &#125;        return dp[n];    &#125;&#125;推荐文章D(la)P(ji)自顶向下与自底向上Leetbook 初级算法动态规划系列-子数组最大和","plink":"https://mvbbb.github.io/evg4uw/"},{"title":"排序算法","date":"2020-08-04T16:03:06.000Z","date_formatted":{"ll":"Aug 4, 2020","L":"08/04/2020","MM-DD":"08-04"},"updated":"2021-02-03T04:21:00.877Z","content":"\n排序算法\n可视化程序\n算法学习总结（2）——温故十大经典排序算法\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define SIZE 10;/*交换元素的函数*/void swap(int arr[],int index1,int index2);/*冒泡排序*/void BulleSort(int arr[],int size);/*简单选择排序*/void SelectionSort(int arr[],int size);/*直接插入排序*/void InsertionSort(int arr[],int size);/*归并排序*/void MergeSort(int arr[],int size);void Recursion(int arr[],int begin,int end,int size);void Merge(int arr[],int right,int mid,int left,int size);/*快速排序*/void QuickSort(int arr[],int length);void  QuickSortRe(int array[],int L,int R);int main()&#123;    /*初始化一个数组*/    int size=SIZE;    int arr[size];    srand((unsigned)time(NULL));    for(int i=0;i!=size;i++)    &#123;        int a = rand() % 51 + 13;    //产生10~63的随机数        arr[i]=a;    &#125;    //BulleSort(arr,size);    //SelectionSort(arr,size);    //InsertionSort(arr,size);    //MergeSort(arr,size);    QuickSort(arr,size);    return 0;&#125;void swap(int arr[],int index1,int index2)&#123;    int temp=arr[index1];    arr[index1]=arr[index2];    arr[index2]=temp;&#125;\n简单选择排序\n对比数组中未排序元素大小找到最值\n然后放到数组中已排序列的末尾\n时间复杂度 \n12345678910111213141516void SelectionSort(int arr[],int size)&#123;    for(int i=0;i!=size;i++)    &#123;        int min_index=i;        for(int j=i;j!=size;j++)        &#123;            if(arr[min_index]&gt;arr[j])            &#123;                min_index=j;            &#125;        &#125;\tif(i!=min_index)\t   swap(arr,i,min_index);    &#125;&#125;\n冒泡排序\n123456789101112void BulleSort(int arr[],int size)&#123;    /*冒泡排序*/    for(int i=0;i&lt;size-1;i++)    &#123;        for(int j=0;j!=size-i-1;j++)        &#123;            if(arr[j+1]&lt;arr[j])//升序排列                swap(arr,j,j+1);        &#125;    &#125;&#125;\n直接插入排序\n1234567891011121314151617181920212223242526272829303132333435void InsertionSort(int arr[], int size)&#123;    for (int sorting=1;sorting&lt;size; sorting++)    &#123;        int flag=0,d;        int temp = arr[sorting]; //保存现在正在排序的值        for (d=sorting-1; d&gt;=0; d--)        &#123;            if (arr[d] &gt; temp) /*需要向后移动? */            &#123;                arr[d+1]=arr[d];                flag=1;            &#125;            else  /*d 之前的元素都小于该值*/                break;        &#125;        if (flag==1)  /*需要插入? */            arr[d+1]=temp;   //值得注意的是: 原来d+1位置的元素已经向后移动了,直接插入不会影响    &#125;&#125;/*另外一个版本*/void InsertionSort(int arr[], int size)&#123;        int current;        for(int i=0;i!=size-1;i++)&#123;            current=arr[i+1];            int preIndex=i;            while(preIndex&gt;=0&amp;&amp;current&lt;arr[preIndex])&#123;                arr[preIndex+1]=arr[preIndex];                preIndex--;            &#125;            arr[preIndex+1]=current;        &#125;&#125;\n归并排序\n分而治之,两路比较,之后合并,repeat\n合并时要比较大小之后插入\n123456789101112131415161718192021222324252627282930313233343536373839404142void MergeSort(int arr[],int size)&#123;    int right=0,left=size-1;    Recursion(arr,right,left,size);&#125;/*排序的工作其实最后都交给了Merge()*/void Recursion(int arr[],int begin,int end,int size)&#123;    /*放回条件是只有1个元素,这个时候begin=end*/    if(begin&lt;end)    &#123;        int mid=(end+begin)/2;//中间对半分        /*左边排序*/        Recursion(arr,begin,mid,size);        /*右边排序*/        Recursion(arr,mid+1,end,size);        /*两边两边分别排序之后合并到一个数组*/        Merge(arr,begin,mid,end,size);    &#125;&#125;void Merge(int arr[],int left,int mid,int right,int size)&#123;    /*需要一个数组来保存合并两个的结果*/    int temp[size];    /*需要探针来指向左右和目标的元素*/    int p1=left,p2=mid+1,k=left;    while(p1&lt;=mid&amp;&amp;p2&lt;=right)    &#123;        if(arr[p1]&lt;=arr[p2])            temp[k++]=arr[p1++];        else            temp[k++]=arr[p2++];    &#125;    /*左右数组的大小可能不一致,因此还需要将没有搬的数字移动到结果数组*/    while(p1&lt;=mid)  temp[k++]=arr[p1++];    while(p2&lt;=right)    temp[k++]=arr[p2++];    /*将结果数组拷贝到传入的数组*/    for(int i=left;i&lt;=right;i++)        arr[i]=temp[i];&#125;\n快速排序\n与归并排序的算法有一定的相似之处, 适合于数据规模较大的排序\n从待排序数组里面随便选一个做主元 (pivot), 分成两大块, 小于主元的放左边, 大于主元的放右边.\n使用左右探针记录比比主元小的数和比主元大的数, 交换他们的位置\n对于一个主元一次性的放到了正确位置上, 以后再也不会移动\n递归地处理左边右边\n123456789101112131415161718192021222324252627282930313233343536373839void QuickSort(int arr[],int length)&#123;    QuickSortRe(arr,0,length-1);&#125;void  QuickSortRe(int array[],int L,int R)&#123;    if(L&gt;=R)        return ;/*只有一个元素*/    int left=L,right=R;/*用于遍历元素的探针*/    int pivot =array[left];/*将中心轴设为左边第一个元素*/    /*嵌套while循环移动,内层的while实现探针移动*/    while(left&lt;right)    &#123;        while(array[right]&gt;=pivot&amp;&amp;left&lt;right)/*右边的数大于等于中心轴的话,继续先中间推进探针*/            right--;        while(array[left]&lt;=pivot&amp;&amp;left&lt;right)/*左边的数小于等于中心轴的话,继续向中间推进探针*/            left++;        /*现在的左探针指向的数大于中心轴的数,右探针的数小于中心轴的数.        *交换这两个指向的数,实现左边放较小的数,右边放较大的数*/        if(left&lt;right)        &#123;            int temp=array[left];            array[left]=array[right];            array[right]=temp;        &#125;        /*只进行了一次对称交换,因此还需要循环,将全部较小的数放到中心轴右边,        * 值得注意的是,在上面两个并列的while循环中,左探针左边的都小于中心轴,右边的都大于中心轴,\t* 因此下一次while循环只在两个探针中间进行*/    &#125;    /*经过上面的循环,现在左右探针应该指向的是同一个位置*/    /*基准数归位: 意思是将中心轴的数放在左右两个子序列之间, 原来该位置的数放到原来中心轴的位置*/    array[L]=array[left];    array[left]=pivot;/*将中心轴数字放在重合的位置*/    /*得到了两个子序列*/    QuickSortRe(array,L,left-1);/*处理基准数左边*/    QuickSortRe(array,left+1,R);/*处理基准数右边*/&#125;\n注意: 在进行基准数归位时, right 和 left 重合的位置的数肯定要比基准数小, 因为在内层循环中, 我们是先移动 right, 之后再移动 left, 肯定是 left “追上” right 导致的外层循环停止, 而在内层循环里面 right 停止之后指向的是刚好小于中心轴的数\n以 [1,5,2,9,4,3]为例\n\n不带注释的版本\n1234567891011121314151617181920212223242526272829void QuickSort(int arr[],int length)&#123;    QuickSortRe(arr,0,length-1);&#125;void  QuickSortRe(int array[],int L,int R)&#123;    if(L&gt;=R)        return ;    int left=L,right=R;    int pivot =array[left];    while(left&lt;right)    &#123;        while(array[right]&gt;=pivot&amp;&amp;left&lt;right)            right--;        while(array[left]&lt;=pivot&amp;&amp;left&lt;right)            left++;        if(left&lt;right)        &#123;            int temp=array[left];            array[left]=array[right];            array[right]=temp;        &#125;    &#125;    array[L]=array[left];    array[left]=pivot;    QuickSortRe(array,L,left-1);    QuickSortRe(array,left+1,R);&#125;\n随机快速排序\n计数排序\n基数排序\n参见算法动画 RADIX\n桶内采用队列结构存储\n基数排序分两种\n\n链式存储. 从桶里面取出元素并排好的过程就是将上一个桶的 front.next 指向下一位非空桶的 rear\n普通的存储结构. 队列或者数组, 取出元素的过程就是使用另外一个辅助数组, 吐到辅助数组里面去\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 求出数组中最大数的位数的函数int MaxBit(vector&lt;int&gt; input) &#123;    // 数组最大值\tint max_data = input[0];\tfor (int i = 1; i &lt; input.size(); i++) &#123;    \tif (input[i] &gt; max_data) &#123;        \tmax_data = input[i];        &#125;    &#125;    // 数组最大值的位数\tint bits_num = 0;\twhile (max_data) &#123;    \tbits_num++;    \tmax_data /= 10;    &#125;\treturn bits_num;&#125;// 取数xxx上的第d位数字int digit(int num, int d) &#123;\tint pow = 1;\twhile (--d &gt; 0) &#123;    \tpow *= 10;    &#125;\treturn num / pow % 10;&#125;// 基数排序vector&lt;int&gt; RadixSort(vector&lt;int&gt; input, int n) &#123;    // 临时数组，用来存放排序过程中的数据\tvector&lt;int&gt; bucket(n);    // 位记数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数\tvector&lt;int&gt; count(10);    // 从低位往高位循环\tfor (int d = 1; d &lt;= MaxBit(input); d++) &#123;        // 计数器清0    \tfor (int i = 0; i &lt; 10; i++) &#123;        \tcount[i] = 0;        &#125;        // 统计各个桶中的个数    \tfor (int i = 0; i &lt; n; i++) &#123;        \tcount[digit(input[i], d)]++;        &#125;        /*        * 比如某次经过上面统计后结果为：[0, 2, 3, 3, 0, 0, 0, 0, 0, 0]则经过下面计算后 结果为： [0, 2,        * 5, 8, 8, 8, 8, 8, 8, 8]但实质上只有如下[0, 2, 5, 8, 0, 0, 0, 0, 0, 0]中        * 非零数才用到，因为其他位不存在，它们分别表示如下：2表示比较位为1的元素可以存放在索引为1、0的        * 位置，5表示比较位为2的元素可以存放在4、3、2三个(5-2=3)位置，8表示比较位为3的元素可以存放在        * 7、6、5三个(8-5=3)位置        */    \tfor (int i = 1; i &lt; 10; i++) &#123;        \tcount[i] += count[i - 1];        &#125;        /*        * 注，这里只能从数组后往前循环，因为排序时还需保持以前的已排序好的顺序，不应该打        * 乱原来已排好的序，如果从前往后处理，则会把原来在前面会摆到后面去，因为在处理某个        * 元素的位置时，位记数器是从大到到小（count[digit(arr[i], d)]--）的方式来处        * 理的，即先存放索引大的元素，再存放索引小的元素，所以需从最后一个元素开始处理。        * 如有这样的一个序列[212,213,312]，如果按照从第一个元素开始循环的话，经过第一轮        * 后（个位）排序后，得到这样一个序列[312,212,213]，第一次好像没什么问题，但问题会        * 从第二轮开始出现，第二轮排序后，会得到[213,212,312]，这样个位为3的元素本应该        * 放在最后，但经过第二轮后却排在了前面了，所以出现了问题        */    \tfor (int i = n - 1; i &gt;= 0; i--) &#123;        \tint k = digit(input[i], d);        \tbucket[count[k] - 1] = input[i];        \tcount[k]--;        &#125;        // 临时数组复制到 input 中    \tfor (int i = 0; i &lt; n; i++) &#123;        \tinput[i] = bucket[i];        &#125;    &#125;\treturn input;&#125;void main() &#123;\tint arr[] = &#123; 50, 123, 543, 187, 49, 30, 0, 2, 11, 100 &#125;;\tvector&lt;int&gt; test(arr, arr + sizeof(arr) / sizeof(arr[0]));\tcout &lt;&lt; &quot;排序前:&quot;;\tfor (int i = 0; i &lt; test.size(); i++) &#123;    \tcout &lt;&lt; test[i] &lt;&lt; &quot; &quot;;    &#125;\tcout &lt;&lt; endl;\tvector&lt;int&gt; result = test;\tresult = RadixSort(result, result.size());\tcout &lt;&lt; &quot;排序后:&quot;;\tfor (int i = 0; i &lt; result.size(); i++) &#123;    \tcout &lt;&lt; result[i] &lt;&lt; &quot; &quot;;    &#125;\tcout &lt;&lt; endl;\tsystem(&quot;pause&quot;);&#125;\n时间复杂度 \n堆排序\n用数组存储堆\n算法思路\n\n将待排序数组构造为一个大根堆. 大根堆的顶端就是数组最大值\n将顶端的数与末尾的数交换, 此时末尾为最大值, 待排序的数组大小-1\n将剩余的 n-1 个数在构造成大根堆, 再将顶端的数与 n-1 位置的数交换, 循环往复, 得到有序数组\n\n构造初始大根堆的过程\n每次从数组里面 “取” 一个数, 在原有的大根堆的基础上找到合理的位置 “插入”\n\n在这里插入是抽象的, 其实就是调整他在数组中的位置, 通过合理的交换达到插入效果\n当然你也可以这样理解, 本身给定一个数组就确立了一个完全二叉树, 我们只是在层序遍历每一个结点. 刚刚开始的时候 0 号结点自然构成大根堆, 遍历到 1 号结点的位置, 我们就可能需要调整, 来构成大根堆, repeat, 直到遍历完所有二叉树结点\n\n具体的:\n遍历到一个结点时\n1234 while(他的父结点的值是否比他小&amp;&amp;i!&#x3D;0)&#123;  true: 交换父结点与他的值  &#x2F;&#x2F;具体在数组中就是交换他们的位置&#125;\n“取出” 最大值, 构造新堆\n“取出”: 将最大值移到完全二叉树的末尾, 在数组中也就是末尾位置\n此时 0 号位置是原来数组末尾的值, 我们要调整他的位置, 使大根堆结构合理\n比较他与左右儿子中的最大值, 如果他比儿子的最大值小, 就交换位置\n调整之后, 我们固定现在处于顶部的结点 [把他放到无序数组的末尾]\nrepeat. 结束条件是他的\n总结\n想要得到升序序列, 需要构造大根堆. 反之构造小根堆\n固定一个最大值之后需要调整二叉树顶结点的位置, 得到一个结构合理的大根堆, repeat\n代码\n代码上面各种语言都差不多, 为了方便我是用的 Java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class heapsort &#123;    public static void heapSort(int arr[])&#123;        heapInsert(arr);        int size=arr.length;        while(size&gt;1)&#123;            swap(arr,0,size-1);            size--;            heapify(arr,0,size);        &#125;    &#125;    private static void heapify(int[] arr, int index, int size) &#123;        int left=index*2+1;        int right=left+1;        while(left&lt;size)&#123;            int largestIndex=(arr[left]&lt;arr[right]&amp;&amp;right&lt;size)?right:left;            if(arr[index]&gt;arr[largestIndex])&#123;                largestIndex=index;            &#125;            if(index==largestIndex)                break;            swap(arr,largestIndex,index);            index=largestIndex;            left=2*index+1;            right=left+1;        &#125;    &#125;  /*还有一种简洁的办法*/    private static void heapify(int[] arr, int index, int size) &#123;        int temp=arr[index];        for(int k=2*index+1;k&lt;size;k=2*k+1)&#123;            //找到较大的儿子            if(k+1&lt;size&amp;&amp;arr[k]&lt;arr[k+1])&#123;                k=2*index+2;            &#125;            //如果他比他儿子都要大就break            if(temp&gt;=arr[k])                break;            //他的大儿子向上移动            arr[index]=arr[k];            //继续处理该结点, 使用index记录他现在的下标            //我们之前使用temp保存了他的值, 不用交换儿子与父亲            index=k;        &#125;        //插入结点        arr[index]=temp;    &#125;    private static void swap(int[] arr, int i, int i1) &#123;        int temp=arr[i];        arr[i]=arr[i1];        arr[i1]=temp;    &#125;    private static void heapInsert(int[] arr) &#123;        //遍历每一个结点, 看他爸爸与他的值的大小        for(int i=0;i!=arr.length;i++)&#123;            int currentIndex=i;            int fatherIndex=(currentIndex-1)/2;            while(arr[currentIndex]&gt;arr[fatherIndex])&#123;                swap(arr,currentIndex,fatherIndex);                currentIndex=fatherIndex;                fatherIndex=(currentIndex-1)/2;            &#125;        &#125;    &#125;    public static void main(String[] args)&#123;        int arr[]=new int[]&#123;3,2,4,5,8,5,2&#125;;        heapSort(arr);        System.out.println(&quot;排序结果:  &quot;+Arrays.toString(arr));    &#125;&#125;\n时间复杂度 \n折半插入排序\n原来的直接插入排序在有序序列里面查找合适的插入位置是使用的顺序遍历, 我们也可以使用类似二分查找的方法找到插入位置\n希尔排序\n是插入排序的一种\n以 dk 为间隔, 数组里面 dk 间隔位置上的无序元素进行插入排序\n之后逐渐减小 dk 循环\ndk=1 处理完就结束排序\n逐渐让无序序列趋向有序, 减少插入排序的\n推荐文章力扣-二叉树Leetbook 初级算法第一个不重复的字符系列","plink":"https://mvbbb.github.io/iixrxk/"},{"title":"力扣-二叉树","date":"2020-08-04T16:02:51.000Z","date_formatted":{"ll":"Aug 4, 2020","L":"08/04/2020","MM-DD":"08-04"},"updated":"2021-02-03T04:21:01.093Z","content":"遍历树叶\n题目描述\n\nhttps://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624\n\n\n思路\n\n题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历\n使用 queue 实现层序遍历\n利用数组来保存结点信息 [静态链表]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;#include&lt;queue&gt;struct node &#123;    int  left;    int right;&#125;;//层序遍历void LevelTra(node tree[], int root_index) &#123;    queue&lt;int&gt; myqueue;    bool flag = true;    myqueue.push(root_index);    while (!myqueue.empty()) &#123;        int T = myqueue.front();        myqueue.pop();        if (tree[T].left == -1 &amp;&amp; tree[T].right == -1)        &#123;            if (flag)                cout &lt;&lt; T;            else                cout &lt;&lt; &quot; &quot; &lt;&lt; T;            flag = false;        &#125;        if (tree[T].left!=-1) myqueue.push( tree[T].left);        if (tree[T].right!=-1) myqueue.push(tree[T].right);    &#125;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    node* tree=new node[n];    char left, right;    //写入树    int root[100]&#123;0&#125;;    for (int i = 0; i != n; i++)    &#123;        cin &gt;&gt; left &gt;&gt; right;        if (left == &#x27;-&#x27;)            tree[i].left = -1;        else &#123;            tree[i].left = left - &#x27;0&#x27;;            root[left-&#x27;0&#x27;] = 1;        &#125;        if (right == &#x27;-&#x27;)            tree[i].right = -1;        else &#123;            tree[i].right = right - &#x27;0&#x27;;            root[right-&#x27;0&#x27;] = 1;        &#125;    &#125;    int root_index;    for (int i = 0; i != n; i++)    &#123;        if (root[i] == 0)            root_index = i;    &#125;    LevelTra(tree, root_index);    return 0;&#125;\n先序遍历顺序建立二叉树链表\n\n代码实现:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct node &#123;    node*  left;    node* right;    char data;&#125;;void createBiTree(node*&amp; T) &#123;    char ch;    cin &gt;&gt; ch;    if (ch == &#x27;#&#x27;) T = NULL;    else    &#123;        T = new node;        T-&gt;data = ch;        createBiTree(T-&gt;left);        createBiTree(T-&gt;right);    &#125;&#125;void inOders(node* tree)&#123;    cout &lt;&lt; &quot;中序遍历&quot; &lt;&lt; endl;    node* T = tree;    stack&lt;node*&gt; mystack;    while (T || !mystack.empty()) &#123;        if (T) &#123;            mystack.push(T);            T = T-&gt;left;        &#125;        else        &#123;            T = mystack.top();            mystack.pop();            cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;            T = T-&gt;right;        &#125;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    node* tree = new node;    createBiTree(tree);    inOders(tree);    return    0;&#125;\n测试案例: ABC##DE#G##F###\n建立结果:\n复制二叉树\n\n代码实现:\n123456789101112void Copy(node* T, node*&amp; newT) &#123;    if (T == NULL) &#123;        newT = NULL;    &#125;    else    &#123;        newT = new node;        newT-&gt;data = T-&gt;data;        Copy(T-&gt;left, newT-&gt;left);        Copy(T-&gt;right, newT-&gt;right);    &#125;&#125;\n测试案例: ABC##DE#G##F###\n打印结果: \n计算二叉树的深度\n\n递龟实现:\n123456789int Depth(node* T) &#123;    if (T == NULL)return 0;    int m = Depth(T-&gt;left);    int n = Depth(T-&gt;right);    if (m &gt; n)        return m + 1;    else        return n + 1;&#125;\n统计二叉树中结点的个数\n二叉树的可视化\n\n1234567891011121314151617181920212223242526272829void output_impl(Node* n, bool left, string const&amp; indent)&#123;    if (n-&gt;right)    &#123;        output_impl(n-&gt;right, false, indent + (left ? &quot;|     &quot; : &quot;      &quot;));    &#125;    cout &lt;&lt; indent;    cout &lt;&lt; (left ? &#x27;\\\\&#x27; : &#x27;/&#x27;);    cout &lt;&lt; &quot;-----&quot;;    cout &lt;&lt; n-&gt;data &lt;&lt; endl;    if (n-&gt;left)    &#123;        output_impl(n-&gt;left, true, indent + (left ? &quot;      &quot; : &quot;|     &quot;));    &#125;&#125;void output(Node* root)&#123;    cout &lt;&lt; &quot;左边在下面,右边在上面&quot; &lt;&lt; endl;    if (root-&gt;right)    &#123;        output_impl(root-&gt;right, false, &quot;&quot;);    &#125;    cout &lt;&lt; root-&gt;data &lt;&lt; endl;    if (root-&gt;left)    &#123;        output_impl(root-&gt;left, true, &quot;&quot;);    &#125;&#125;\n二叉树的后序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-postorder-traversal/\n\n递归方法很简单\n123456789101112131415class Solution &#123;public:    vector&lt;int&gt; v1;    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        rec(root);        return v1;    &#125;    void rec(TreeNode* T) &#123;        if (T) &#123;            rec(T-&gt;left);            rec(T-&gt;right);            v1.push_back(T-&gt;val);        &#125;    &#125;&#125;;\n对于这样一颗树, 我们有三种情况会访问 A 结点, 1 第一次结果他访问他的左子树, 2 他的左子树访问完了开始访问他的右子树, 3 他的左右子树都访问完了,开始访问他本身.\n使用栈迭代, 先把最左边的结点入栈.\n第三种情况需要我们判断他的右子树是否已经访问,或者上他的右子树为空,满足条件之一我们就访问 A 结点.\n使用一个指针来标记上一次完成访问的结点. 如果 A 的右子树不为空, 那么在 A 之前访问的结点一定是 A 的右子树. 如果 A 的右子树为空, 那么我们可以直接访问 A 结点.\n如果上面的条件不满足, 证明 A 的右子树还没有访问我们进入他的右子树继续迭代\n123456789101112131415161718192021222324252627282930class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; v;        stack&lt;TreeNode*&gt; s;        TreeNode* T = root, *p = NULL;        while (T || !s.empty()) &#123;            if (T)            &#123;                s.push(T);                T = T-&gt;left;            &#125;            else            &#123;                T = s.top();                s.pop();                if (T-&gt;right != p &amp;&amp; T-&gt;right != NULL) &#123;                    s.push(T);                    T = T-&gt;right;                &#125;                else &#123;                    v.push_back(T-&gt;val);                    p = T;                    T = NULL;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;\n\n二叉树的最大深度\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/\n\n递归解法简单\n12345678910class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (!root) return 0;        int m = maxDepth(root-&gt;left);        int n = maxDepth(root-&gt;right);        int depth = (m &gt; n ? m : n)+1;        return depth;    &#125;&#125;;\n复杂度分析:\n时间复杂度 \n翻转二叉树\n\nhttps://leetcode-cn.com/problems/invert-binary-tree/submissions/\n\n递归简单\n12345678910111213141516class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        rec(root);        return root;    &#125;    void rec(TreeNode*&amp; T) &#123;        if (!T) return;        TreeNode* temp = T-&gt;left;        T-&gt;left = T-&gt;right;        T-&gt;right = temp;        rec(T-&gt;left);        rec(T-&gt;right);    &#125;&#125;;\n二叉树的层序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n\n和普通的层序遍历不太一样的是, 普通的层序遍历无法得知他的层数信息, 但是这个要返回一个二维数组\n从队列中取出一个结点, 把他的儿子结点 push 进去. 每次遍历一层我们都会把这一层的结点的儿子都 push 进来, push 进来的总数是儿子节点的总数.\n我们要一次性从队列里面取出这一层的全部结点. queue.size() 作为我们取出的个数\n123456789101112131415161718192021class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; qu;        vector&lt;vector&lt;int&gt;&gt; vve;        if(root!=NULL) qu.push(root);        while (!qu.empty()) &#123;            vector&lt;int&gt; temp;            int size = qu.size();            for (int i = 0; i != size; i++) &#123;                TreeNode* T = qu.front();                temp.push_back(1);                qu.pop();                if (T-&gt;left)qu.push(T-&gt;left);                if (T-&gt;right)qu.push(T-&gt;right);            &#125;            vve.push_back(temp);        &#125;        return vve;    &#125;&#125;;\n这道题花了我很长时间, 不能直接用 qu.size() 作为循环条件, 因为 size 会变\n二叉搜索树的范围和\n\nhttps://leetcode-cn.com/problems/range-sum-of-bst/\n\n其实是二叉树中序遍历得到的序列, 在 L 和 R 之间的数求和\n最简单的思路\n\n使用迭代栈中序遍历\n使用 falg 判断该数是否在 L 和 R 之间\n\n12345678910111213141516171819202122232425262728293031class Solution &#123;public:    int rangeSumBST(TreeNode* root, int L, int R) &#123;        int sum = 0;        bool flag=false;        stack&lt;TreeNode*&gt; s;        TreeNode* T = root;        while (T || !s.empty()) &#123;            if (T)            &#123;                s.push(T);                T = T-&gt;left;            &#125;            else &#123;                T = s.top();                s.pop();                if (T-&gt;val == L) &#123;                    flag = true;                &#125;                if (flag)                    sum += T-&gt;val;                if (T-&gt;val == R &amp;&amp; flag)                    flag = false;                T = T-&gt;right;            &#125;        &#125;        return sum;    &#125;&#125;;\nN 叉树的后序遍历\n\nhttps://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\n\n递归方法很简单\n\n123456789101112131415class Solution &#123;public:    vector&lt;int&gt; v;    vector&lt;int&gt; postorder(Node* root) &#123;        rec(root);        return v;    &#125;    void rec(Node* root) &#123;        if (!root)return;        for (int i = 0; i != root-&gt;children.size(); i++) &#123;            rec(root-&gt;children[i]);        &#125;        v.push_back(root-&gt;val);    &#125;&#125;;\n迭代思路\n后序遍历，首先最简单的做法是 记住前序 翻转就实现 (直接利用 1.前序遍历 2.翻转)\n访问栈顶, val 放入到 ve 中, 将栈顶 pop 出来, 将其子树全部按照顺序地放入到栈中. 循环该过程\n循环结束的条件是栈空, 在访问完最后一个结点时栈肯定是空的, 其余情况栈肯定不为空\n123456789101112131415161718192021222324class Solution &#123;public:    vector&lt;int&gt; postorder(Node* root) &#123;        vector&lt;int&gt; v;        if(!root) return v;        stack&lt;Node*&gt; s;        s.push(root);        while(!s.empty())&#123;            Node* T=s.top();            s.pop();            if(T)&#123;                v.push_back(T-&gt;val);                for(int i=0;i!=T-&gt;children.size();i++)&#123;                     s.push(T-&gt;children[i]);                &#125;            &#125;        &#125;        reverse(v.begin(),v.end());        return v;    &#125;&#125;;\n\nN 叉树的前序遍历\n\nhttps://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/\n\n递归法很简单\n123456789101112131415class Solution &#123;public:    vector&lt;int&gt; v;    vector&lt;int&gt; preorder(Node* root) &#123;        rec(root);        return v;    &#125;    void rec(Node* T)&#123;        if(!T) return ;        v.push_back(T-&gt;val);        for(int i=0;i!=T-&gt;children.size();i++)&#123;            rec(T-&gt;children[i]);        &#125;    &#125;&#125;;\n迭代法就相当于上一道题不用 reverse(v.begin(),v.end());\n将有序数组转换为二叉搜索树\n\nhttps://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\n\n只有一个中序/后序/前序遍历序列无法唯一确定一颗平衡二叉搜索树\n给定了有序数组, 中序遍历时根结点一定处于有序数组的中间部分, 可以递归的每次选数组中间部分作为根结点\n方法一：中序遍历：始终选择中间位置左边元素作为根节点\n\n1234567891011121314151617class Solution &#123;public:    vector&lt;int&gt; nums;    TreeNode* helper(int left, int right)    &#123;        if (left &gt; right) return NULL;        int mid = (left + right)/2;        TreeNode* T = new TreeNode(nums[mid]);        T-&gt;left = helper(left, mid - 1);        T-&gt;right = helper(mid+1,right);        return T;    &#125;    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        this-&gt;nums = nums;        return helper(0, nums.size() - 1);    &#125;&#125;;\n方法二：中序遍历：始终选择中间位置右边元素作为根节点\n方法三：中序遍历：选择任意一个中间位置元素作为根节点\n*特定深度节点链表\n\nhttps://leetcode-cn.com/problems/list-of-depth-lcci/\n\n很明显, 采取层次遍历, 每一层变成一条链表\n队列实现层次遍历, 链表的创建采取后插法, 函数返回一个数组, 数组元素是链表头指针\n二叉树的中序遍历\n\nhttps://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/\n\n12345678910111213141516171819202122class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        TreeNode* T=root;        vector&lt;int&gt; ve;        while(T||!st.empty())&#123;            if(T)&#123;                st.push(T);                T=T-&gt;left;            &#125;            else            &#123;                T=st.top();                st.pop();                ve.push_back(T-&gt;val);                T=T-&gt;right;            &#125;        &#125;        return ve;    &#125;&#125;;\n祖父节点值为偶数的节点和\n\nhttps://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/\n\n使用三元组来存储结点关系 (grandparent, parent, node) , 之后判断 node.left, node.right\n官方思路还是比较普通的, 没我想的那么复杂\n123456789101112131415161718192021class Solution &#123;    int ans = 0;public:    void dfs(TreeNode* grandparent, TreeNode* parent, TreeNode* node) &#123;        if (!node)return;        if (grandparent-&gt;val % 2 == 0)ans += node-&gt;val;        //遍历下一层        dfs(parent, node, node-&gt;left);        dfs(parent, node, node-&gt;right);    &#125;    int sumEvenGrandparent(TreeNode* root) &#123;        if (root-&gt;left != NULL) &#123;            dfs(root, root-&gt;left, root-&gt;left-&gt;left);            dfs(root, root-&gt;left, root-&gt;left-&gt;right);        &#125;if (root-&gt;right) &#123;            dfs(root, root-&gt;right, root-&gt;right-&gt;left);            dfs(root, root-&gt;right, root-&gt;right-&gt;right);        &#125;        return ans;    &#125;&#125;;\n在上一种方法中, 由于根节点没有父结点, 他的根节点的子结点没有祖父结点, 因此我们是从 root-&gt;left-&gt;right 开始的, 因此我们必须使用if (root-&gt;left != NULL)来判断他有没有子结点. 我们可以简化这个过程, 根结点是没有父结点和祖父结点的, 但是我们可以假设他的父结点的值是 1 , 效果是一样的\n123456789101112131415161718192021class Solution &#123;private:    int ans = 0;public:    void dfs(int gp_val, int p_val, TreeNode* node) &#123;        if (!node) &#123;            return;        &#125;        if (gp_val % 2 == 0) &#123;            ans += node-&gt;val;        &#125;        dfs(p_val, node-&gt;val, node-&gt;left);        dfs(p_val, node-&gt;val, node-&gt;right);    &#125;    int sumEvenGrandparent(TreeNode* root) &#123;        dfs(1, 1, root);        return ans;    &#125;&#125;;\n\n根据前序和后序遍历构造二叉树\n\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\n\n\n只记得上课讲过, 知道是什么原理, 代码就是写不出来, 递归传哪些参数之类的拎不清\n祭上一段优美的代码\n12345678910111213class Solution &#123;   int pre_index=0, post_index=0;public:  TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) &#123;      TreeNode* root = new TreeNode(pre[pre_index++]);      if (root-&gt;val != post[post_index])          root-&gt;left = constructFromPrePost(pre, post);      if(root-&gt;val != post[post_index])          root-&gt;right = constructFromPrePost(pre, post);      post_index++;      return root;  &#125;&#125;;\n\n二叉搜索树中的众数\n\nhttps://leetcode-cn.com/problems/find-mode-in-binary-search-tree/\n\n怎么说呢, 感觉这道题怪怪的\n思路: 使用 map 来保存数和它出现的频率, 最后再将出现频率最高的数放到 vector, 里面\nmap 中 value 是出现频率, key 是某个数.\n回顾一下 map 的特性: 使用 [] 访问不存在的 key, map 会把它自动添加进去, 并返回他的 value\n就懒得自己写了, 太恼人了\n12345678910111213141516171819202122232425262728class Solution &#123;    public:    map&lt;int, int &gt; mmp;    void dfs(TreeNode* root) &#123;        if (root == NULL)return;        mmp[root-&gt;val]++;        dfs(root-&gt;left);        dfs(root-&gt;right);    &#125;    vector&lt;int&gt; findMode(TreeNode* root) &#123;        vector&lt;int&gt; v;        dfs(root);        int maxn = 0;        for (auto it = mmp.begin(); it != mmp.end(); it++) &#123;            if (it-&gt;second == maxn) &#123;                v.push_back(it-&gt;first);            &#125;            else if (it-&gt;second &gt; maxn) &#123;                maxn = it-&gt;second;                v.clear();                v.push_back(it-&gt;first);            &#125;        &#125;        return v;    &#125;&#125;;\n*恢复二叉搜索树\n\nhttps://leetcode-cn.com/problems/recover-binary-search-tree/\n\n路径总和\n\nhttps://leetcode-cn.com/problems/path-sum/\n\n哎呀, 不就是递归吗, 多简单啊, 轻轻松松的啦\n\n123456789101112131415161718class Solution &#123;public:    int sum=0;    bool flag=false;    bool hasPathSum(TreeNode* root, int sum) &#123;        //遍历每一条路径,求和        this-&gt;sum=sum;        rec(root,0);        return flag;    &#125;    void rec(TreeNode* T,int pre_sum)&#123;        if(!T)return;        pre_sum+=T-&gt;val;        if(pre_sum==sum&amp;&amp;T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL)flag=true;        rec(T-&gt;left,pre_sum);        rec(T-&gt;right,pre_sum);    &#125;&#125;;\n不过相较于别人的代码还是过于臃肿\n12345678910class Solution &#123;public:    bool hasPathSum(TreeNode* root, int sum) &#123;        if(!root)            return false;        if(root-&gt;val==sum&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)            return true;        return hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val);    &#125;&#125;;\n*二叉树的最近公共祖先\n\nhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\n\n嗅到了递归的气息,   回溯算法\n\nhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment &gt; https://www.youtube.com/watch?v=xzKrRf-SLqM\n\n犯糊涂了, 之前以为必须是两个结点的直接祖先, 题没看清楚, 不过肯定逃不了递归思路\n公共祖先 situation:\n\np q 在 roo 的左右两边\n1=root, p 在左边或者右边\np=root, q 在左边或者右边\n\n时间复杂度\n\n12345678910class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root == NULL||root==q||root==p) return root;        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);        if (left != NULL &amp;&amp; right != NULL)return root;        return left == NULL ? right : left;    &#125;&#125;;\n\n因为是递归，使用函数后可认为左右子树已经算出结果\n\n*出现次数最多的子树元素和\n\nhttps://leetcode-cn.com/problems/most-frequent-subtree-sum/\n\n二叉搜索树的第 k 大节点\n\nhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)\n\n还是比较简单的\n二叉搜索树的特点: 中序遍历序列递增\n思路: 访问结点, 放入vector ,最后返回 vector 里面倒数第 k 个数\n1234567891011121314class Solution &#123;public:    vector&lt;int&gt; ve;    int kthLargest(TreeNode* root, int k) &#123;        rec(root);        return ve[ve.size()-k];    &#125;    void rec(TreeNode* T)&#123;        if(!T) return;        rec(T-&gt;left);        ve.push_back(T-&gt;val);        rec(T-&gt;right);    &#125;&#125;;\n从上到下打印二叉树 II\n\nhttps://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)\n\n噗, 又是层序遍历\n123456789101112131415161718192021class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; qu;        vector&lt;vector&lt;int&gt;&gt; vve;        qu.push(root);        while(!qu.empty())&#123;            int size=qu.size();            vector&lt;int&gt; temp;            for(int i=0;i!=size;i++)&#123;                TreeNode* T=qu.front();                qu.pop();                temp.push_back(T-&gt;val);                if(T-&gt;left)qu.push(T-&gt;left);                if(T-&gt;right)qu.push(T-&gt;right);            &#125;            vve.push_back(temp);        &#125;        return vve;    &#125;&#125;;\n平衡二叉树\n\nhttps://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/\n\n12345678910111213141516class Solution &#123;public:    bool flag=true;    bool isBalanced(TreeNode* root) &#123;        rec(root);        return flag;    &#125;    int rec(TreeNode* T)&#123;        if(!T)return 0;        int m=rec(T-&gt;left);        int n=rec(T-&gt;right);        if(abs(m-n)&gt;=2) flag=false;        int max=m&gt;n?m:n;        return max+1;    &#125;&#125;;\n从上到下打印二叉树\n\nhttps://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\n\n迷惑性题目, 未免太过简单\n123456789101112131415161718class Solution &#123;public:    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; qu;        vector&lt;int&gt; ve;        if(!root) return ve;        qu.push(root);        while(!qu.empty())&#123;            TreeNode* T=qu.front();            qu.pop();            ve.push_back(T-&gt;val);            if(T-&gt;left) qu.push(T-&gt;left);            if(T-&gt;right)   qu.push(T-&gt;right);        &#125;        return ve;    &#125;&#125;;\n注意下 root 为空直接返回就是了\n*前序和中序序列构造二叉树\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\n\n\n直接写的不太好, 还是直接看别人的\n1234567891011121314151617181920class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int pos = 0;        return buildTree(preorder, pos, inorder, 0, inorder.size()-1);    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int&amp; pos, vector&lt;int&gt;&amp; inorder, int left, int right) &#123;        if (pos &gt;= preorder.size()) return 0;        int i = left;        for (; i &lt;= right; ++i) &#123;            if (inorder[i] == preorder[pos])                break;        &#125;        TreeNode* node = new TreeNode(preorder[pos]);        if (left &lt;= i-1) node-&gt;left = buildTree(preorder, ++pos, inorder, left, i-1);  // 左子树        if (i+1 &lt;= right) node-&gt;right = buildTree(preorder, ++pos, inorder, i + 1, right); // 右子树        return node;    &#125;&#125;;\n使用 map\n12345678910111213141516171819class Solution &#123;public:    unordered_map&lt;int, int&gt; pos;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int n = preorder.size();        for(int i = 0; i &lt; n; i++)            pos[inorder[i]] = i;        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;    TreeNode* dfs(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; inor, int pl, int pr, int il, int ir)    &#123;        if(pl &gt; pr) return NULL;        int k = pos[pre[pl]] - il;        TreeNode* root = new TreeNode(pre[pl]);        root -&gt; left = dfs(pre, inor, pl + 1, pl + k, il, il + k - 1);        root -&gt; right = dfs(pre, inor, pl + k + 1, pr, il + k + 1, ir);        return root;    &#125;&#125;;\n二叉树的右视图\n\nhttps://leetcode-cn.com/problems/binary-tree-right-side-view/\n\n我的思路: 使用区分层数的层序遍历, 只打印每一层的最后一个结点\n12345678910111213141516171819202122class Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; qu;        if(!root) return &#123;&#125;;        vector&lt;int&gt; ve;        TreeNode* T=NULL;        qu.push(root);        while(!qu.empty())&#123;            int size=qu.size();            for(int i=0;i!=size;i++)&#123;                T=qu.front();                qu.pop();                if(i==size-1)                    ve.push_back(T-&gt;val);                if(T-&gt;left) qu.push(T-&gt;left);                if(T-&gt;right) qu.push(T-&gt;right);            &#125;        &#125;        return ve;    &#125;&#125;;\n缺点: 将左子树的不必要的部分存储进了队列, 浪费内存\n\n复杂度分析: 每个结点都入队出队了一次, 所以时间复杂度是 \n思路二:   使用深度优先搜索, 先 根节点-&gt;右子树-&gt;左子树, 与先序遍历顺序相反\n只加入每一层第一次被访问的结点, 使用 ve.size() 来判断层数\n12345678910111213141516class Solution &#123;public:    vector&lt;int&gt; ve;    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        dfs(root,0);        return ve;    &#125;     void dfs(TreeNode* T,int depth)&#123;         if(!T) return ;         if(depth==ve.size())             ve.push_back(T-&gt;val);         ++depth;         dfs(T-&gt;right,depth);         dfs(T-&gt;left,depth);     &#125;&#125;;\n不过速度好像更慢了\n\n*把二叉搜索树转换为累加树\n\nhttps://leetcode-cn.com/problems/convert-bst-to-greater-tree/\n\n二叉搜索树的特点:\n\n左子树所有结点小于根结点\n右子树所有节点大于根结点\n\n根据这个特点, 我们可以得出: 对于一个结点, 他的值变为 = 原来的结点值 + 他右子树的所有结点的值 + 他所有祖先节点与组先结点的右子树的所有结点的值\n对于这道题: 我们中序递归遍历: 右子树-&gt;根结点-&gt;左子树, 每个结点值变为 左子树结点和+本身\n算了写不出来, 脑子不够用, 看看别人的正确代码\n12345678910111213class Solution &#123;public:    int num=0;    TreeNode* convertBST(TreeNode* root) &#123;        if(root==NULL)            return root;        convertBST(root-&gt;right);        root-&gt;val+=num;        num=root-&gt;val;//记录这一次的和        convertBST(root-&gt;left);        return root;    &#125;&#125;;\n我的思维误区 第一: 误以为需要递归函数返回右子树的和, 其实使用一个全局变量就可以了 第二: 每个结点只需要遍历一次就够了\n*二叉树的直径\n\nhttps://leetcode-cn.com/problems/diameter-of-binary-tree/\n\n一道标注简单的题做起来不简单\n*左子叶之和\n\nhttps://leetcode-cn.com/problems/sum-of-left-leaves/\n\n西巴, 不会, 虽然说看起来挺简单的\n首先, 不可以使用普通的前序遍历, 因为它无法分辨遍历到的结点是不是右结点\n12345678910class Solution &#123;public:    int sumOfLeftLeaves(TreeNode* root) &#123;        if(root==NULL)  return 0;        int temp=0;        if(root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;left==NULL&amp;&amp;root-&gt;left-&gt;right==NULL)             temp=root-&gt;left-&gt;val;        return temp+sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);    &#125;&#125;;\n叶子相似的树\n\nhttps://leetcode-cn.com/problems/leaf-similar-trees/\n\n**我的思路: ** 应该是最简单的思路了, 前序遍历两棵树, 判断结点是不是叶节点, 使用 vector 存储, 最后比较两个 vector 是否相同\n1234567891011121314151617181920212223242526272829class Solution &#123;public:    vector&lt;int&gt; v1,v2;    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;        rec(root1,1);        rec(root2,2);        bool flag=true;        if(v1.size()!=v2.size())        &#123;            flag=false;        &#125;else&#123;            for(int i=0;i!=v1.size();i++)&#123;                if(v1[i]!=v2[i])                    flag=false;            &#125;        &#125;        return flag;    &#125;    void rec(TreeNode* T,int tag)&#123;        if(T==NULL) return;        if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL&amp;&amp;tag==1)&#123;            v1.push_back(T-&gt;val);        &#125;else if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL&amp;&amp;tag==2)&#123;            v2.push_back(T-&gt;val);        &#125;        rec(T-&gt;left,tag);        rec(T-&gt;right,tag);    &#125;&#125;;\n优化方法, 使用 string 来存储遍历到的叶节点值, 最后使用 .equal() 就可以了, 不过记得在结点值中间增加分隔符\n二叉树的堂兄弟节点\n\nhttps://leetcode-cn.com/problems/cousins-in-binary-tree/\n\n堂兄弟的条件: 不同父结点, 相同的深度\n看了看别人的解法, 没有啥惊艳的解法\n**我的思路: ** 使用层序遍历, 遍历到一个结点就将它 不做了\n验证二叉搜索树\n\nhttps://leetcode-cn.com/problems/validate-binary-search-tree/\n\n判断一颗二叉树是不是二叉搜索树.\n二叉搜索树的特点:\n\n左子树所有结点值小于根结点\n右子树所有结点值大于根结点\n中序遍历得到的序列递增\n\n我的错误思路: 中序递归遍历, 对于一个结点, 判断他的左结点是否比他小,右节点的值是否比他大\n错误原因: 在这种情况下, 按照我的思路无法判断\n\n大佬的思路: 中序遍历为升序\n经过改进:\n12345678910111213141516171819202122class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        long prev= LONG_MIN;        stack&lt;TreeNode*&gt; st;        TreeNode* T=root;        while(T||!st.empty())&#123;            if(T)&#123;                st.push(T);                T=T-&gt;left;            &#125;else&#123;                T = st.top();                st.pop();                if(T-&gt;val&lt;=prev)                    return false;                prev=T-&gt;val;                T=T-&gt;right;            &#125;        &#125;        return true;    &#125;&#125;;\n填充每个节点的下一个右侧节点指针\n\nhttps://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\n\n我的起初思路: 想使用层序遍历, 但是层序遍历需要使用额外的队列空间, 大小由最后一层的结点树数量决定.\n观察给出的样例:\n\n左子树结点 next 指向他的兄弟结点(父结的右儿子)\n右子树结点 next 指向父结点的 next 的左儿子, 特别的, 如果父结点的 next 是 NULL 的话, 直接指向 NULL\n\n**我的实现方法: ** 中序递归遍历, 先对于每一个结点:\n\n该结点不是叶节点, 把他的左儿子 next 指向他的右儿子, 把他的右儿子 next 指向他的 next\n该节点是叶节点就什么什么都不做\n\n123456789101112131415class Solution &#123;public:    Node* connect(Node* root) &#123;        helper(root);        return root;    &#125;    void helper(Node* T)    &#123;        if(T==NULL||(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL)) return ;        T-&gt;left-&gt;next=T-&gt;right;        T-&gt;right-&gt;next= T-&gt;next==NULL? NULL:T-&gt;next-&gt;left;        helper(T-&gt;left);        helper(T-&gt;right);    &#125;&#125;;\n卧槽, 一次过, 有点激动\n\n优化方法, 这里可以不用 helper 函数, 一个函数内return root\n*二叉搜索树迭代器\n\nhttps://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/\n\n**我的思路: ** 因为是二叉搜索树, 所以中序遍历序列是递增序列. 因为每一次使用 next ,数就减少一个, 很容易联想到栈或队列. 因此我们使用队列来保存中序遍历序列\n123456789101112131415161718192021222324class BSTIterator &#123;public:    queue&lt;int&gt; st;    BSTIterator(TreeNode* root) &#123;        helper(root);    &#125;    void helper(TreeNode* T)&#123;        if(T==NULL) return ;        helper(T-&gt;left);        st.push(T-&gt;val);        helper(T-&gt;right);    &#125;    /** @return the next smallest number */    int next() &#123;        int x=st.front();        st.pop();        return x;    &#125;    /** @return whether we have a next smallest number */    bool hasNext() &#123;        return !st.empty();    &#125;&#125;;\n效果很差\n\n更好的方法:\n模拟递归的过程\n123456789101112131415161718192021222324252627282930class BSTIterator &#123;public:    stack&lt;TreeNode*&gt; stk;    BSTIterator(TreeNode* root) &#123;        while(root)        &#123;            stk.push(root);            root=root-&gt;left;        &#125;    &#125;    /** @return the next smallest number */    int next() &#123;        TreeNode *p =stk.top();        int res= p-&gt;val;        stk.pop();        p =p-&gt;right;        while(p)        &#123;            stk.push(p);            p=p-&gt;left;        &#125;        return res;    &#125;    /** @return whether we have a next smallest number */    bool hasNext() &#123;        return !stk.empty();    &#125;&#125;;\n*树的子结构\n\nhttps://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n\n我的思路: 先序遍历 A 树, 判断该结点的值是否与 B 的根结点相同\n\n相同: 记下这个结点的位置, 两棵树同时向下比较, , 当 B 树被遍历完了, 就 return true, 否者回到原来被记下的位置, 继续先序遍历\n不同, A 向下遍历\n\n算了写不下去了, 错误代码如下\n12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public:    bool flag=false;    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;        helper(A,B);        return flag;    &#125;    void helper(TreeNode* A,TreeNode* B)&#123;        if(A==NULL)  return ;        if(A-&gt;val==B-&gt;val)&#123;            bool flag=true;            TreeNode* pa=A;            TreeNode* pb=B;            stack&lt;TreeNode*&gt; sa,sb;            while((pa||!sa.empty())&amp;&amp;(pb||!sb.empty()))&#123;                if(pa&amp;&amp;pb)&#123;                    sa.push(pa);                    sb.push(pb);                    if(pa-&gt;val!=pb-&gt;val)                        flag=false;                    pa=pa-&gt;left;                    pb=pb-&gt;left;                &#125;else&#123;                    pa=sa.top(); sa.pop();                    pb=sb.top(); sb.pop();                    pa=pa-&gt;right;                    pb=pb-&gt;right;                &#125;            &#125;            if(pb!=NULL) flag=false;            if(flag==true) this-&gt;flag=true;        &#125;        helper(A-&gt;left,B);        helper(A-&gt;right,B);    &#125;&#125;;\n看看别人的代码\n1234567891011class Solution &#123;public:    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;        return (A != NULL &amp;&amp; B != NULL) &amp;&amp; (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));    &#125;    bool recur(TreeNode* A, TreeNode* B) &#123;        if(B == NULL) return true;        if(A == NULL || A-&gt;val != B-&gt;val) return false;        return recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);    &#125;&#125;;\n卧槽, 简直了, 优美简短\n别人的思路:\n二叉树的最小深度\n\nhttps://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\n\n123456789101112class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if(root==NULL)            return 0;            int m=minDepth(root-&gt;left);            int n=minDepth(root-&gt;right);            //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1            //2.如果都不为空，返回较小深度+1            return root-&gt;left==NULL||root-&gt;right==NULL? (m+n+1):(m&gt;n?n:m)+1;    &#125;&#125;;\n斐波那契数列\n\nhttps://leetcode-cn.com/problems/fibonacci-number/description/\n\n虽然我知道直接递归不太好, 但是我实在是真看不出这道题和树有什么联系\n12345678class Solution &#123;public:    int fib(int N) &#123;        if(N==0)return 0;        if(N==1) return 1;        return fib(N-1)+fib(N-2);    &#125;&#125;;\n最大二叉树\n\nhttps://leetcode-cn.com/problems/maximum-binary-tree/description/\n\n一看就是递归, 我又不会…\n写了一段半残的代码, 思路比较普通, 也比较好理解, 就是边界控制始终不到位\n还是去看大佬的代码去了\n123456789101112131415161718192021222324252627//垃圾代码class Solution &#123;public:    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;        int max=findMax(nums,0,nums.size());        return helper(nums,0,max,nums.size());    &#125;    int findMax(vector&lt;int&gt; &amp;nums,int left,int right)   &#123;        int max=INT_MIN,res=1;        for(int i=left;i&lt;right;i++)&#123;            if(nums[i]&gt;=max)&#123;                max=nums[i];                res=i;            &#125;        &#125;        return res;    &#125;    TreeNode* helper(vector&lt;int&gt; &amp;nums,int left,int max,int right)&#123;        if(left&gt;right) return NULL;        TreeNode* root=new TreeNode(nums[max]);        int left_max=findMax(nums,left,max-1);        int right_max=findMax(nums,max+1,right);        root-&gt;left=helper(nums,left,left_max,max-1);        root-&gt;right=helper(nums,max+1,right_max,right);        return root;    &#125;&#125;;\n别人的好代码\n12345678910111213141516class Solution &#123;public:    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;        return construct(nums.begin(), nums.end());    &#125;private:    TreeNode * construct(vector&lt;int&gt;::iterator l, vector&lt;int&gt;::iterator r) &#123;        if (l == r) return NULL;        auto it = max_element(l, r);        TreeNode *tn = new TreeNode(*it);        tn-&gt;left  = construct(l, it);        tn-&gt;right = construct(it + 1, r);        return tn;    &#125;&#125;;\n**总结一下: ** 使用 vector 迭代器, 比较好\n\n递归结束的条件是左迭代器与右迭代器重合\n使用 STL max_element() , 让代码看起来比较简洁, 还需要积累库算法的使用经验\n注意左右分递归时的细节. 左边递归的右边界是 it. 右边递归的左边界是 it+1 ,右边界是 r\n\n合并二叉树\n\nhttps://leetcode-cn.com/problems/merge-two-binary-trees/description/\n\n好的, 我又看出来了, 这是一道递归的题目, 可是卵用\n冷静分析, 有要接一颗树的情形, 因此递归得返回正在处理的二叉树, 方便对接\n如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。\n1234567891011class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;        if(!t1) return t2;        if(!t2 ) return t1;        t1-&gt;val+=t2-&gt;val;        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);        return t1;    &#125;&#125;;\n思路是挺清晰, 就是内存消耗有点大\n\n*对称二叉树\n\nhttps://leetcode-cn.com/problems/symmetric-tree/description/\n\n反正就是遍历的问题, 算了不会\n理一下思路: 如何判断一颗树是否是对称二叉搜索树?\n如果根节点是NULL,  true\n如果根结点不是NULL, 判断 左子树的左儿子和右子树的右儿子 &amp;&amp; 左子树的右儿子和右子树的左儿子\n左子树的左儿子和右子树的右儿子(左子树的右儿子和右子树的左儿子)\n\n都为空 return true\n有一个是 NULL , 有一个不是 NULL\n都不为空, 判断他们的值是否相同, 并且继续向下递归判断\n\n这样递归关系就清晰可见了\n代码如下\n123456789101112class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if(root==NULL ) return true;        return  helper(root-&gt;left,root-&gt;right);    &#125;    bool helper(TreeNode* l,TreeNode* r)&#123;        if(l==NULL&amp;&amp;r==NULL)return true;        if(l==NULL||r==NULL) return false;        return r-&gt;val==l-&gt;val   &amp;&amp; helper(l-&gt;left,r-&gt;right)&amp;&amp;helper(l-&gt;right,r-&gt;left);    &#125;&#125;;\n代码优化\n12345678910public boolean isSymmetric(TreeNode root) &#123;    return isMirror(root, root);&#125;public boolean isMirror(TreeNode t1, TreeNode t2) &#123;    if (t1 == null &amp;&amp; t2 == null) return true;    if (t1 == null || t2 == null) return false;    return (t1.val == t2.val)        &amp;&amp; isMirror(t1.right, t2.left)        &amp;&amp; isMirror(t1.left, t2.right);&#125;\n*路径总和  Ⅲ\n\nhttps://leetcode-cn.com/problems/path-sum-iii/description/\n\n难度不小, 有点东西\n思路一: 使用 vector 存储遍历到的路径的值的和, 最后数容器中有几个 sum\n算了不会, 别折腾自己, 看答案了\n1234567891011121314151617181920class Solution &#123;public:    int pathSum(TreeNode* root, int sum) &#123;        if (nullptr == root)            return 0;        return dfs(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);    &#125;private:    int dfs(TreeNode* root, int sum)    &#123;        if (nullptr == root)            return 0;        sum -= root-&gt;val;        return (0 == sum ? 1 : 0) + dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);        /*这条路径和是否是sum, 继续递归左边和右边*/    &#125;&#125;;\n解释: pathSum 前序遍历递归每一个结点. dfs 对于每一   个结点递归遍历他的左右子树.\n对于一个结点我们怎么判断他有几条向下的路径和为 sum 呢? 前序遍历, 向下递归\n二叉搜索树中的搜索\n\nhttps://leetcode-cn.com/problems/search-in-a-binary-search-tree/\n\n我的最初递归方法,不知道还没有更好的方法\n12345678910class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        if(root==NULL) return NULL;        if(root-&gt;val==val)return root;        TreeNode* l=searchBST(root-&gt;left,val);        TreeNode* r=searchBST(root-&gt;right,val);        return l==NULL?r:l;    &#125;&#125;;\n适当优化\n123456789class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        if(root==NULL||root-&gt;val==val) return root;        TreeNode* l=searchBST(root-&gt;left,val);        TreeNode* r=searchBST(root-&gt;right,val);        return l==NULL?r:l;    &#125;&#125;;\n当然我们也可以使用层序遍历或者非递归遍历来实现.\n观察了一会儿, 恍然大悟, 这是一颗二叉搜索树, 我们可以利用它的性质来优化代码. 但是提交结果显示效率还是不高\n123456789101112class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        if(root==NULL||root-&gt;val==val) return root;        TreeNode* res=NULL;        if(root-&gt;val&gt;val)            res=searchBST(root-&gt;left,val);        else            res=searchBST(root-&gt;right,val);        return res;    &#125;&#125;;\n\n二叉搜索树中的插入操作\n\nhttps://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\n\nAwesome! 一次过\n123456789101112class Solution &#123;public:    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;        if(root==NULL )            return new TreeNode(val);        if(root-&gt;val&gt;val)            root-&gt;left=insertIntoBST(root-&gt;left,val);        else            root-&gt;right=insertIntoBST(root-&gt;right,val);        return root;    &#125;&#125;;\n*二叉树展开为链表\n\nhttps://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\n\n题干的关键是原地展开, 不能新建一颗二叉树.\n递龟问题, 我们根结点的左子树被插入到根结点与右子树中间\n别人的思路对于一个递归函数, 我们不用管函数内部是怎样实现的, 我只看函数的作用以及输入输出.\n对于flatten 来说\n\n函数作用: 是将一个二叉树展开为链表\n输入: 树的根结点\n输出: 无\n\n我的思维误区: 其实叶节点也可以当作是一颗左子树和右子树都是 NULL 的树\n12345678910111213141516/*我们每次把原来的右子树接到现在右子树的末尾都使用了一个 `while` 循环来找到现在右子树最右边的结点*/class Solution &#123;public:    void flatten(TreeNode* root) &#123;        if(root==nullptr) return ;        flatten(root-&gt;left);        flatten(root-&gt;right);        TreeNode*temp=root-&gt;right;        root-&gt;right = root-&gt;left;        root-&gt;left=nullptr;        while(root-&gt;right!=nullptr)root=root-&gt;right;        root-&gt;right=temp;    &#125;&#125;;\n另外一种思路: 向右边的后序遍历, 逆向思维, 难懂\n123456789101112class Solution &#123;public:    TreeNode* last = nullptr;    void flatten(TreeNode* root) &#123;        if (root == nullptr) return;        flatten(root-&gt;right);        flatten(root-&gt;left);        root-&gt;right = last;        root-&gt;left = nullptr;        last = root;    &#125;&#125;;\n*二叉树的所有路径\n\nhttps://leetcode-cn.com/problems/binary-tree-paths/\n\n很久没做题了, 手感生疏了, 简单题也头痛了. 虽然说之前也不怎么会 🤣\n来看看这道题. 不会\n对于一个结点, 分情况\n\n他的左儿子或右儿子有一个不为空, 到他的 path += “val-&gt;”\n他是叶节点, path+= “val”, 将到他的 path push 到容器\n\n递龟结束的条件是碰到 NULL 了\n1234567891011121314151617181920class Solution &#123;public:string path;vector&lt;string&gt; res;    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        if(root==NULL)return &#123;&#125;;        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)&#123;//叶节点            path+=to_string(root-&gt;val);            res.push_back(path);            return res;        &#125;else&#123;            path+=to_string(root-&gt;val)+&quot;-&gt;&quot;;            string temp=path;//使用一个temp来保存到即将进入左边递龟的结点的路径            binaryTreePaths(root-&gt;left);            path=temp;//将路径恢复为进入左边递龟之前的路径            binaryTreePaths(root-&gt;right);        &#125;        return res;    &#125;&#125;;\n找树左下角的值\n\nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n又是层序遍历, 仔细想一下很简单\n1234567891011121314151617181920class Solution &#123;public:    int findBottomLeftValue(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; qu;        int res;        qu.push(root);        while(!qu.empty())&#123;            int size=qu.size();            for(int i=0;i!=size;i++)&#123;                auto T=qu.front();                qu.pop();                    if(i==0)                res=T-&gt;val;                if(T-&gt;left)qu.push(T-&gt;left);                if(T-&gt;right)qu.push(T-&gt;right);            &#125;        &#125;        return res;    &#125;&#125;;推荐文章排序算法Leetbook 初级算法二叉树系列-二叉树子结构","plink":"https://mvbbb.github.io/zhme42/"},{"title":"Leetbook 初级算法","date":"2020-08-04T16:02:36.000Z","date_formatted":{"ll":"Aug 4, 2020","L":"08/04/2020","MM-DD":"08-04"},"updated":"2021-02-03T04:21:01.237Z","content":"https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/\n算法很重要,算法很重要,算法很重要\n\n数组\n边界条件控制最关键\n删除排序数组中的重复项\n\n删除排序数组中的重复项\n\n双指针:\np 用于指向当前元素\nq 用于指向下一个与当前元素相异的值.\n1234567891011121314class Solution &#123;    public int removeDuplicates(int[] nums) &#123;        if(nums==null||nums.length==0)return 0;        int p=0,q=1;        while(q&lt;nums.length)&#123;            if(nums[p]!=nums[q])&#123;//探测位的值与当前值不同, 将当前值的下一位改为探测位的值. 当前指针前移                nums[p+1]=nums[q];                p++;            &#125;            q++;        &#125;        return p+1;    &#125;&#125;\n我们只需要移动相异的元素到当前值的后面, 不需要考虑与当前元素相同的值. 相同的值会被后来扫描到的相异的值所覆盖.\np 移动的次数+1 就是相异元素的个数.\n买卖股票的最佳时机 Ⅱ\n一看这题目就不简单\n暴力\n旋转数组\n解法一: 朴素解法\n每次把每个元素向右移动一位, 执行 k 次. 提前保存最后一位元素, 因为会被覆盖, 将其覆盖第一位元素.\n123456789101112class Solution &#123;    public void rotate(int[] nums, int k) &#123;        k=k%nums.length;        for(int i=0;i!=k;i++)&#123;            int temp=nums[nums.length-1];            for(int j=nums.length-2;j&gt;=0;j--)&#123;                nums[j+1]=nums[j];            &#125;            nums[0]=temp;        &#125;    &#125;&#125;\n时间复杂度 $O(n*k)$\n空间复杂度 $O(1)$\n解法二: 使用环状替换\n解法三: 使用反转\n\n这个方法基于这个事实：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。\n在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。\n\n123456789101112131415161718192021class Solution &#123;    public void rotate(int[] nums, int k) &#123;        k=k%nums.length;       //前 n-k 逆序        reverse(nums, 0, nums.length-k-1);       //后 k 逆序       reverse(nums,nums.length-k,nums.length-1);       //全部逆序       reverse(nums, 0, nums.length-1);    &#125;    void reverse(int[] nums,int begin,int end) &#123;        while(begin&lt;end)&#123;            int temp=nums[begin];            nums[begin]=nums[end];            nums[end]=temp;            begin++;            end--;        &#125;    &#125;&#125;\n存在重复元素\n我的思路: 使用 HashSet\n1234567891011121314151617class Solution &#123;    public boolean containsDuplicate(int[] nums) &#123;        HashSet&lt;Integer&gt; st=new HashSet&lt;&gt;();        for(var i:nums)&#123;            if(st.contains(i))                return true;            else                st.add(i);        &#125;        return false;    &#125;    public static void main(String[]a)&#123;        int[] arr=new int[]&#123;1,2,3,4&#125;;        Solution s=new Solution();        System.out.println(s.containsDuplicate(arr));    &#125;&#125;\n时间复杂度和空间复杂度均为 $O(n)$\n还有一种思路: 先对数组排序, 之后判断两两元素是否相同. 时间复杂度取决于排序算法\n只出现一次的数字\n题目要求时间复杂度为线性, 并且不使用额外的空间. 排除使用 Hash 表和排序算法. 肯定有捷径\n使用异或运算: \n123456789class Solution &#123;    public int singleNumber(int[] nums) &#123;        int single = 0;        for (int num : nums) &#123;            single ^= num;        &#125;        return single;    &#125;&#125;\n两个数组的交集 Ⅱ\n先对数组进行排序, 之后使用两个指针. 把这两个指针当作同等地位\n123456789101112131415161718192021222324class Solution &#123;    public int[] intersect(int[] nums1, int[] nums2) &#123;        Arrays.sort(nums1);        Arrays.sort(nums2);        int[] intersection=new int [Math.min(nums1.length,nums2.length)];        int index=0; //交集集合指针        int index1=0,index2=0;//两个数组的指针        while(index1&lt;nums1.length&amp;&amp;index2&lt;nums2.length)&#123;            if(nums1[index1]&lt;nums2[index2])                index1++;            else if(nums1[index1]==nums2[index2])                &#123;                    intersection[index++]=nums1[index1];                    index1++;index2++;                &#125;            else                index2++;        &#125;        return Arrays.copyOfRange(intersection, 0, index)          ;    &#125;    public static void main(String[]s)&#123;        System.out.println(Arrays.toString(new Solution().intersect(new int[]&#123;1,2&#125;, new int[]&#123;1,1&#125;)));    &#125;&#125;\n加一\n第一想到的是使用递归, 不过之后改成了遍历\n123456789101112131415161718192021222324252627class Solution &#123;    public int[] plusOne(int[] digits) &#123;        boolean carry=true;        if(digits==null||digits.length==0)            return new int[]&#123;&#125;;        for(int i=digits.length-1;i&gt;=0;i--)&#123;            if(carry==true)&#123;                int temp=digits[i]+1;                if(temp&lt;10)                    carry=false;                digits[i]=temp%10;                if(i==0&amp;&amp;carry==true)&#123;                    int [] res=new int[digits.length+1];                    res[0]=1;                    System.arraycopy(digits, 0, res, 1, digits.length);                    return res;                &#125;            &#125;        &#125;        return digits;    &#125;    public static void main(String[]s)&#123;        System.out.println(Arrays.toString(new Solution().plusOne(new int[]&#123;            4,3,2,1        &#125;)));    &#125;&#125;\n题目并不是很难, 只要是理清其中的逻辑关系\n\n我的代码还是太臃肿了. 可以说是逻辑混乱的写法. 更加优秀的思路\n\n判断是否需要进位不需要一个标志位 carry , 直接判断被加一后的位置的元素是否为 0 , 如果为 0 , 证明需要进位\n假如不是为 0 , 说明不需要进位, **可以直接 return digits **了\n一些特殊情况就是当出现 9999、999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位\n\n12345678910111213class Solution &#123;    public int[] plusOne(int[] digits) &#123;        for (int i = digits.length - 1; i &gt;= 0; i--) &#123;            digits[i]++;            digits[i] = digits[i] % 10;            if (digits[i] != 0) return digits;        &#125;        // 这里是最tm离谱的. 例如 99 进位变成 00, 数组默认初始化恰好为 00        digits = new int[digits.length + 1];        digits[0] = 1;        return digits;    &#125;&#125;\n移动零\n12345678910111213141516171819class Solution &#123;    public void moveZeroes(int[] nums) &#123;        int zeroCnt=0;        for(int i=0;i!=nums.length;i++)&#123;            if(nums[i]!=0)                nums[i-zeroCnt]=nums[i];            else                zeroCnt++;        &#125;        for(int i=0;i!=zeroCnt;i++)&#123;            nums[nums.length-1-i]=0;        &#125;    &#125;    public static void main(String[]a)&#123;        int [] nums=new int[]&#123;0,1&#125;;        Solution s=new Solution();        s.moveZeroes(nums);    &#125;&#125;\n两数之和\n123456789101112class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        HashMap&lt;Integer,Integer&gt; hMap=new HashMap&lt;&gt;();        for(int i=0;i!=nums.length;i++)&#123;            if(hMap.containsKey(target-nums[i]))                return new int[]&#123;hMap.get(target-nums[i]),i&#125;;            else                hMap.put(nums[i], i);        &#125;        return nums;    &#125;&#125;\n有效的数独\n其实想要做出这道题应该还是不能, 就是效率不怎么高: 只要我的方法足够蠢，这题就难不住我（泪目\n对于 3*3 宫格的问题, 我们可以将不同区块映射到二维数组的不同行, 区块内的映射到该行的不同列, 同行的一列出现了重复现象就 return false. 问题归结到怎样将不同区块映射到不同行, 经过观察 box_index = (row / 3) * 3 + columns / 3\n1234567891011121314151617181920212223public boolean isValidSudoku(char[][] board)&#123;     int [][] row=new int[9][9];     int[][]col=new int[9][9];     int[][] boxs=new int [9][9];     for(int i=0;i!=9;i++)&#123;         for(int j=0;j!=9;j++)&#123;             if(board[i][j]!=&#x27;.&#x27;)&#123;                 int num=board[i][j]-&#x27;1&#x27;;                 int box_index = (i / 3) * 3 + j / 3;                 if(row[i][num]==0&amp;&amp;col[num][j]==0&amp;&amp;boxs[box_index][num]==0)                     &#123;                         row[i][num]=1;                         col[num][j]=1;                         boxs[box_index][num]=1;                     &#125;                 else                     return false;             &#125;         &#125;     &#125;     return true; &#125;\n旋转图像\n延主对角线反转一次, 之后延横向中心线反转一次\n12345678910111213141516171819202122class Solution &#123;    public void rotate(int[][] matrix) &#123;        int l=matrix.length;        //延主对角线反转一次        for(int i=0;i!=l;i++)&#123;            for(int j=0;j&lt;i;j++)&#123;                int temp=matrix[i][j];                matrix[i][j]=matrix[j][i];                matrix[j][i]=temp;            &#125;        &#125;        //延横向中心线反转一次        for(int i=0;i&lt;l;i++)&#123;            for(int j=0;j&lt;l/2;j++)&#123;            int tmp = matrix[i][j];            matrix[i][j] = matrix[i][l - j - 1];            matrix[i][l - j - 1] = tmp;            &#125;        &#125;    &#125;&#125;\n字符串\n反转字符串\n过于简单了\n1234567891011class Solution &#123;    public void reverseString(char[] s) &#123;        int begin=0,end=s.length-1;        while(begin&lt;end)&#123;            char temp=s[begin];            s[begin]=s[end];            s[end]=temp;            begin++;end--;        &#125;    &#125;&#125;\n整数反转\n虽然说看起来比较简单, 但是题目中要求了整数溢出返回 0 , 这就比较伤脑筋了.\n别人简洁的代码:\n12345678public int reverse(int x) &#123;        long n = 0;        while(x != 0) &#123;            n = n*10 + x%10;            x = x/10;        &#125;        return (int)n==n? (int)n:0;    &#125;\n字符串中第一个唯一字符\n我的第一种解法: 思路是使用 HashMap 记录字符和他出现的频次, 之后遍历字符串中的字符, 看 Map 里面频次为 1 则 return\n123456789101112131415class Solution &#123;     public int firstUniqChar(String s) &#123;        HashMap&lt;Character,Integer&gt;mp=new HashMap&lt;&gt;();        for (int i = 0; i &lt; s.length(); i++) &#123;            char c = s.charAt(i);            mp.put(c, mp.getOrDefault(c, 0) + 1);            //如果map中含有指定的key，就返回该key对应的value，否则使用该方法的第二个参数作为默认值返回        &#125;        for(int i=0;i!=s.length();i++)&#123;            if(mp.get(s.charAt(i))==1)                return i;        &#125;        return -1;     &#125;&#125;\n\n效率不够高\n时间复杂度 $O(n)$: 只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。\n空间复杂度 $O(n)$\n有效的字母异位词\n过于简单\n123456789101112class Solution &#123;    public boolean isAnagram(String s, String t) &#123;        char[] sarray=s.toCharArray();        char[] tarray=t.toCharArray();        Arrays.sort(sarray);        Arrays.sort(tarray);        return Arrays.equals(sarray, tarray);    &#125;    public static void main(String[]s)&#123;        System.out.println(new Solution().isAnagram(&quot;rat&quot;, &quot;cart&quot;));    &#125;&#125;\n还有更简单的解法\n1234567891011121314public class Solution &#123;    public boolean isAnagram(String s, String t) &#123;        if(s.length()!=t.length())return false;        int []counter=new int[26];        for(int i=0;i&lt;s.length();i++)&#123;            counter[s.charAt(i)-&#x27;a&#x27;]++;            counter[t.charAt(i)-&#x27;a&#x27;]--;        &#125;        for(var i:counter)&#123;            if(i!=0)return false;        &#125;        return true;    &#125;&#125;\n验证回文串\n使用常规思路还是很容易做出来的\n12345678910111213141516171819class Solution &#123;      public boolean isPalindrome(String s) &#123;        s&#x3D;s.toLowerCase();        char[] s1&#x3D;new char[s.length()];        int index&#x3D;0;        for(int i&#x3D;0;i!&#x3D;s.length();i++)&#123;            char c&#x3D;s.charAt(i);            if((c&gt;&#x3D;&#39;a&#39;&amp;&amp;c&lt;&#x3D;&#39;z&#39;)||(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;)||(c&gt;&#x3D;&#39;A&#39;&amp;&amp;c&lt;&#x3D;&#39;Z&#39;))            s1[index++]&#x3D;c;        &#125;        int begin&#x3D;0,end&#x3D;index-1;        while(begin&lt;end)&#123;            if(s1[begin]!&#x3D;s1[end])               return false;               begin++;end--;        &#125;        return true;      &#125;&#125;\n时间复杂度和空间复杂度为 \n更好的解决方法是直接使用双指针\n字符串转换整数 (atoi)\n解法一 朴素解法\n这道题完全简直了, 被溢出折磨的不行了. 提交五次终于过了\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;    public int myAtoi(String str) &#123;        int  res=0;        int i=0;        while(i&lt;str.length()&amp;&amp;str.charAt(i)==&#x27; &#x27;)            i++;        if(i==str.length())            return 0;        if(str.charAt(i)==&#x27;-&#x27;)&#123;            i++;            while(i&lt;str.length()&amp;&amp;str.charAt(i)&lt;=&#x27;9&#x27;&amp;&amp;str.charAt(i)&gt;=&#x27;0&#x27;)&#123;                int x=str.charAt(i)-&#x27;0&#x27;;                if(res&gt;(Integer.MAX_VALUE-x)/10)                    return Integer.MIN_VALUE;                res=res*10+x;                i++;            &#125;            res=-res;        &#125;        else if(str.charAt(i)==&#x27;+&#x27;)&#123;            i++;            while(i&lt;str.length()&amp;&amp;str.charAt(i)&lt;=&#x27;9&#x27;&amp;&amp;str.charAt(i)&gt;=&#x27;0&#x27;)&#123;                int x=str.charAt(i)-&#x27;0&#x27;;                if(res&gt;(Integer.MAX_VALUE-x)/10)                    return Integer.MAX_VALUE;                res=res*10+x;                i++;            &#125;        &#125;        else if((str.charAt(i)&gt;=&#x27;0&#x27;&amp;&amp;str.charAt(i)&lt;=&#x27;9&#x27;))&#123;            while(i&lt;str.length()&amp;&amp;str.charAt(i)&lt;=&#x27;9&#x27;&amp;&amp;str.charAt(i)&gt;=&#x27;0&#x27;)&#123;                int x=str.charAt(i)-&#x27;0&#x27;;                if(res&gt;(Integer.MAX_VALUE-x)/10)                    return Integer.MAX_VALUE;                res=res*10+x;                i++;            &#125;        &#125;        else if((str.charAt(i)&lt;&#x27;0&#x27;&amp;&amp;str.charAt(i)&gt;&#x27;9&#x27;))            return 0;        return res;    &#125;    public static void main(String []s)&#123;        System.out.println(new Solution().myAtoi(&quot;-91283472332&quot;));    &#125;&#125;\n代码有很多精简空间, 不过算了吧\n解法二 自动机\nhttps://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/\n实现 strStr()\n双指针解法\nKMP 算法\n后补, 这个有点难\n最长公共前缀\n方法一 常规思路\n效率偏低\n\n123456789101112131415161718192021222324class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs.length==1)            return strs[0];        if(strs.length==0)            return &quot;&quot;;        String pattern=strs[0];        ArrayList&lt;Integer&gt; alt=new ArrayList&lt;&gt;();        for(int i=1;i!=strs.length;i++)&#123;            int index=0;            while(index&lt;pattern.length()&amp;&amp;index&lt;strs[i].length()&amp;&amp;pattern.charAt(index)==strs[i].charAt(index))                index++;            alt.add(index);        &#125;        alt.sort(Integer::compareTo);        int min_index=alt.get(0);        return strs[0].substring(0,min_index);    &#125;    public static void main(String []a)&#123;        String[] arr=new String[]&#123;&#125;;        String s=new Solution().longestCommonPrefix(arr);        System.out.println(s);    &#125;&#125;\n时间复杂度   n 是字符串数量, m 是字符串平均长度\n方法二 先排序 比较头尾\n这个思路还是比较妙的\n123456789101112131415161718class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        Arrays.sort(strs);        if(strs.length==0)            return &quot;&quot;;        if(strs.length==1)            return strs[0];        int index=0;        while(index&lt;strs[0].length()&amp;&amp;index&lt;strs[strs.length - 1].length()&amp;&amp;strs[0].charAt(index)==strs[strs.length - 1].charAt(index))            index++;        return strs[0].substring(0,index);    &#125;    public static void main(String []a)&#123;        String[] arr=new String[]&#123;&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;&#125;;        String s=new Solution().longestCommonPrefix(arr);        System.out.println(s);    &#125;&#125;\n时间复杂度  实际上就是 sort 的时间复杂度\n\n方法三 水平扫描法\n比较第一个字符串与第二个字符串, 得到他们的公共前缀, 将该公共前缀与第三个字符串作比较, repeat. 最后得到全部字符串的公共前缀.\n1234567891011121314151617181920212223class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs.length==0)            return &quot;&quot;;        String prefix=strs[0];        for(int i=1;i!=strs.length;i++)&#123;            prefix=findPublic(prefix,strs[i]);        &#125;        return prefix;    &#125;    public String findPublic(String s1,String s2)&#123;        int length=Math.min(s1.length(),s2.length());        int index=0;        while(index&lt;length&amp;&amp;s1.charAt(index)==s2.charAt(index))            index++;        return s1.substring(0,index);    &#125;    public static void main(String []a)&#123;        String[] arr=new String[]&#123;&quot;flower&quot;&#125;;        String s=new Solution().longestCommonPrefix(arr);        System.out.println(s);    &#125;&#125;\n时间复杂度  n 是字符串数量, m 是字符串平均长度\n方法四 二分分治法\n这种问题可以转换为分治思路.\n\n123456789101112131415161718192021222324252627282930class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs.length==0)            return &quot;&quot;;        else            return hepler(strs,0,strs.length-1);    &#125;    public String hepler(String[] strs,int begin,int end)&#123;        if(begin &gt;= end)            return strs[begin];        int mid=(begin+end)/2;        String lcpLeft=hepler(strs,begin,mid);        String lcpRight=hepler(strs,mid+1,end);        return findPublic(lcpLeft, lcpRight);    &#125;    public String findPublic(String s1,String s2)&#123;        int length=Math.min(s1.length(),s2.length());        int index=0;        while(index&lt;length&amp;&amp;s1.charAt(index)==s2.charAt(index))            index++;        return s1.substring(0,index);    &#125;    public static void main(String []a)&#123;        String[] arr=new String[]&#123;&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;&#125;;        String s=new Solution().longestCommonPrefix(arr);        System.out.println(s);    &#125;&#125;\n时间复杂度  .   空间复杂度  m 是字符串的平均长度, n 是字符串的数量, 空间复杂度主要取决于递归调用的层数, 层数最大为 ，每层需要 m 的空间存储返回结果。\n方法五 二分查找\n选择最短字符串, 公共前缀一定包含于最短字符串\n\n1234567891011121314151617181920212223242526272829303132333435class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if (strs == null || strs.length == 0) &#123;            return &quot;&quot;;        &#125;        int minLength = Integer.MAX_VALUE;        for (String str : strs) &#123;            minLength = Math.min(minLength, str.length());        &#125;        int low = 0, high = minLength;        while (low &lt; high) &#123;            int mid = (high - low + 1) / 2 + low;            if (isCommonPrefix(strs, mid)) &#123;                low = mid;            &#125; else &#123;                high = mid - 1;            &#125;        &#125;        return strs[0].substring(0, low);    &#125;    public boolean isCommonPrefix(String[] strs, int length) &#123;        String str0 = strs[0].substring(0, length);        int count = strs.length;        for (int i = 1; i &lt; count; i++) &#123;            String str = strs[i];            for (int j = 0; j &lt; length; j++) &#123;                if (str0.charAt(j) != str.charAt(j)) &#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n时间复杂度  , 其中  m  是字符串数组中的字符串的最小长度，n  是字符串的数量。二分查找的迭代执行次数是  O(logm)，每次迭代最多需要比较  mn  个字符.\n空间复杂度 \n链表\n删除链表中的节点\n非常规数据结构解法, 将所有数 copy 过来, 而不是对指针指向操作. 相当奇葩!\n123456789101112class Solution &#123;     public void deleteNode(ListNode node) &#123;        ListNode p=node;        ListNode pre=null;        while(p.next!=null)&#123;            p.val=p.next.val;            pre=p;            p=p.next;        &#125;        pre.next=null;     &#125;&#125;\n看了官方的解答, 没想到还有更简单的解法. 有点妙\n1234public void deleteNode(ListNode node) &#123;    node.val = node.next.val;    node.next = node.next.next;&#125;\n删除链表的倒数第 N 个节点\n方法一 使用额外的空间来存储节点\n1234567891011121314151617class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ArrayList&lt;ListNode&gt; alt=new ArrayList&lt;&gt;();        ListNode p=head;        while(p!=null)&#123;            alt.add(p);            p=p.next;        &#125;        if(alt.size()!=n)&#123;            var temp=alt.get(alt.size()-n-1);            temp.next=temp.next.next;            return head;        &#125;else            return head.next;    &#125;&#125;\n效率不是太高 时间复杂度   空间复杂度\n\n方法二 两次遍历\n第一次遍历找到链表长度, 下一次遍历找到应该被删除的节点的前一个位置\n1234567891011121314151617181920212223242526class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        //找到链表长度        int length=0;        ListNode p=head;        while(p!=null)&#123;            p=p.next;            length++;        &#125;        //找到需要删除的节点的上一个位置        //被删除的节点是头节点        if(length==n)            return head.next;        else&#123;            int delete_pre_index=length-n-1;            p=head;            for(int i=0;i!=delete_pre_index;i++)&#123;                p=p.next;            &#125;            p.next=p.next.next;            return head;        &#125;    &#125;&#125;\n时间复杂度   空间复杂度 \n方法三 使用快慢指针一次遍历\n原理: 指针 1 和 指针 2 保持 n+1 个节点的间距, 指针 1 到达链表末尾(null)时, 指针 2 所指向的节点是待删除节点的上一个节点.\n为了防止出现待删除的节点是头节点的特殊情况, 我们需要增加一个哑节点\n12345678910111213141516171819202122class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy=new ListNode(0);        dummy.next=head;        ListNode first=dummy;        ListNode end=dummy;        //使两个指针保持 n 个节点的间距        for(int i=0;i!=n;i++)&#123;            first=first.next;        &#125;        //将指针1指向末尾(null), 现在指针2就指向待删除的节点的上一个节点        while(first!=null)&#123;            first=first.next;            end=end.next;        &#125;        end.next=end.next.next;        return dummy.next;    &#125;&#125;\n\n方法四 递归\n1234567891011class Solution &#123;public:    int cur=0;    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;       if(!head) return NULL;       head-&gt;next = removeNthFromEnd(head-&gt;next,n);       cur++;       if(n==cur) return head-&gt;next;       return head;    &#125;&#125;;\n反转链表\n迭代\n画图就比较好解决了\n123456789101112131415class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if(head==null)            return null;        ListNode dummy=new ListNode(0);        dummy.next=head;        while(head.next!=null)&#123;            ListNode p=head.next;            head.next=head.next.next;            p.next=dummy.next;            dummy.next=p;        &#125;        return dummy.next;    &#125;&#125;\n更加简洁的代码: 双指针迭代\n1234567891011public ListNode reverseList(ListNode head) &#123;    ListNode prev = null;    ListNode curr = head;    while (curr != null) &#123;        ListNode nextTemp = curr.next;        curr.next = prev;        prev = curr;        curr = nextTemp;    &#125;    return prev;&#125;\n时间复杂度   空间复杂度 \n递归\n时间复杂度和空间复杂度都是 \n123456789class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null) return head;        ListNode p = reverseList(head.next);        head.next.next = head;        head.next = null;        return p;    &#125;&#125;\np 指针一直指向链表末尾, 最后作为新链表的头被返回\n合并两个有序链表\n使用指针\n1234567891011121314151617181920class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        ListNode head=new ListNode(0);        ListNode p1=l1,p2=l2,p=head;        while(p1!=null &amp;&amp; p2!=null)&#123;            if(p1.val&lt;=p2.val)&#123;                p.next=p1 ;p1=p1.next;            &#125; else&#123;                p.next=p2; p2=p2.next;            &#125;            p=p.next;        &#125;        if(p1==null)            p.next=p2;        if(p2==null)            p.next=p1;        return head.next;    &#125;&#125;\n递归\n挺妙的\n\n其实递归就是程序内部维护了一个栈。这个题就是每次都把最小值压入栈，最后出栈的时候，将所有数连在一起就可以了。说白了，就是用一个栈维护了顺序。最后的连接，当然是小的连小的，所以 l1 小，就连到 l1,l2 小就连到 l2，最后先返回的，就是最小的头结点。\n\n123456789101112131415class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1==null)            return l2;        if(l2==null)            return l1;        if(l1.val&lt;=l2.val)&#123;            l1.next = mergeTwoLists(l1.next,l2);            return l1;        &#125;else&#123;            l2.next = mergeTwoLists(l1,l2.next);            return l2;        &#125;    &#125;&#125;\n回文链表\n实在是想不到空间复杂度是   的写法, 看题解了\n快慢指针找中间位置可实在是太骚了…\n1234567891011121314151617181920212223242526class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        //如果链表为空或者链表只有一个元素，那么一定返回true        if (head == null || head.next == null) return true;        ListNode p = head, q = head, pre = null;        //循环结束后p指向(int)(n/2)号节点，n为链表长度，索引从0开始        while (q != null &amp;&amp; q.next != null) &#123;            q = q.next.next;//q每次向后移动两个位置            ListNode temp = p.next;//临时记录下p的后继节点            p.next = pre;//p的next指针反向            pre = p;//移动pre            p = temp;//移动p        &#125;        if (q != null) //链表长度为奇数，此时pre指向(int)(n/2)-1号元素，p指向(int)(n/2)号元素            p = p.next;//p向后移动一位        //判断是否回文        while (p != null &amp;&amp; pre != null) &#123;            if (p.val != pre.val)                return false;            p = p.next;            pre = pre.next;        &#125;        return true;    &#125;&#125;\n树\n二叉树的最大深度\n常规题目\n12345678910class Solution &#123;       public int maxDepth(TreeNode root) &#123;        if(root==null)return 0;        int left=maxDepth(root.left);        int right=maxDepth(root.right);        return (left&gt;right?left:right)+1;       &#125;&#125;\n验证二叉搜索树\n常规题目\n二叉搜索树的特点: 中序遍历序列为递增\n1234567891011121314151617181920class Solution &#123;     public boolean isValidBST(TreeNode root) &#123;        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();        Boolean is=true;        TreeNode p=root;        long pre=Long.MIN_VALUE;        while(p!=null||!st.empty())&#123;            if(p!=null)&#123;                st.push(p);                p=p.left;            &#125;else&#123;                p=st.pop();                if(p.val&lt;=pre)is=false;                pre=p.val;                p=p.right;            &#125;        &#125;        return is;     &#125;&#125;\n中序遍历取得每一个值, 比较他与上一个值的大小, 因为搜索树的中序遍历是递增的, 所以每一次取得的值都要比上一次的值要大.\n二叉树的层序遍历\n还是比较简单的\n1234567891011121314151617181920class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; qu=new LinkedList&lt;&gt;();        TreeNode p=root;        List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt; ();        qu.add(p);        while(p!=null&amp;&amp;!qu.isEmpty())&#123;            List&lt;Integer&gt; list=new ArrayList&lt;&gt; ();            int size=qu.size();            for(int i=0;i!=size;i++)&#123;                p=qu.peek();qu.poll();                list.add(p.val);                if(p.left!=null) qu.add(p.left);                if(p.right!=null) qu.add(p.right);            &#125;            res.add(list);        &#125;        return  res;    &#125;&#125;\n将有序数组转换为二叉搜索树\n典型的二分法问题, 递归建立一颗树\n还是挺简单的\n1234567891011121314class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return helper(nums, 0, nums.length-1);    &#125;    public TreeNode helper(int nums[],int begin, int end)&#123;        if(begin&gt;end)            return null;        int mid=(begin+end)/2;        TreeNode root=new TreeNode(nums[mid]);        root.left=helper(nums,begin,mid-1);        root.right=helper(nums,mid+1,end);        return root;    &#125;&#125;\n排序和搜索\n合并两个有序的数组\n不会有人想使用 Arrays.sort() 吧, 不会吧 🤣\n双指针问题\n可以使用额外的空间来临时保存 nums1 的数据, 空间换时间\n1234567891011121314151617181920212223public class Solution &#123;    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;        int []arr=new int[m+n];        int index=0;        int p=0,q=0;        while(p&lt;m&amp;&amp;q&lt;n)&#123;            if(nums1[p]&lt;nums2[q])&#123;                arr[index++]=nums1[p];                p++;            &#125;else&#123;                arr[index++]=nums2[q];                q++;            &#125;        &#125;        while(p!=m)&#123;            arr[index++]=nums1[p++];        &#125;        while(q!=n)&#123;            arr[index++]=nums2[q++];        &#125;        System.arraycopy(arr, 0, nums1, 0, m+n);    &#125;&#125;\n\nhttps://leetcode-cn.com/problems/merge-sorted-array/solution/88-by-ikaruga/\n动态规划\n见 简单动态规划\n其他\n有效的括号\n使用栈\n12345678910111213141516171819202122232425262728293031class Solution &#123;    public boolean isValid(String s) &#123;        char[] stack=new char[10000];        stack[0]=&#x27;#&#x27;;        int top=0;        for(int i=0;i!=s.length();i++)&#123;            char c=s.charAt(i);            char top_c=stack[top];            if(isImg(top_c,c))&#123;                top--;            &#125;            else&#123;                stack[++top]=c;            &#125;        &#125;        return top==0;    &#125;    public Boolean isImg(char top_c,char c2)&#123;        if(top_c==&#x27;[&#x27;)            return c2==&#x27;]&#x27;;        if(top_c==&#x27;(&#x27;)            return c2==&#x27;)&#x27;;        if(top_c==&#x27;&#123;&#x27;)            return c2==&#x27;&#125;&#x27;;        return false;    &#125;    public static void main(String[]s)&#123;        String str=new String(&quot;[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]&quot;);        System.out.println(new Solution().isValid(str));    &#125;&#125;\n我觉得我自己实现的栈的运行效率不会太低, 不过还是挺慢的\n\n时间复杂度和空间复杂度都是 \n优化思路:\n\n判断字符串长度是否为偶数\n遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false\n栈不为空, 同时栈栈顶和该字符不是匹配的, 而且该字符是右边部分 return false\n\n1234567891011121314151617181920212223242526272829303132333435class Solution &#123;    public boolean isValid(String s) &#123;        if(s.length()%2!=0)            return false;        char[] stack=new char[10000];        stack[0]=&#x27;#&#x27;;        int top=0;        for(int i=0;i!=s.length();i++)&#123;            char c=s.charAt(i);            char top_c=stack[top];            if(isImg(top_c,c))&#123;                top--;            &#125;else if(!isImg(top_c,c)&amp;&amp;c!=&#x27;(&#x27;&amp;&amp;c!=&#x27;&#123;&#x27;&amp;&amp;c!=&#x27;[&#x27;)                return false;            else if(c==&#x27;[&#x27;||c==&#x27;(&#x27;||c==&#x27;&#123;&#x27;)                stack[++top]=c;            else if(top==0&amp;&amp;c!=&#x27;(&#x27;&amp;&amp;c!=&#x27;&#123;&#x27;&amp;&amp;c!=&#x27;[&#x27;)                return false;        &#125;        return top==0;    &#125;    public Boolean isImg(char top_c,char c2)&#123;        if(top_c==&#x27;[&#x27;)            return c2==&#x27;]&#x27;;        if(top_c==&#x27;(&#x27;)            return c2==&#x27;)&#x27;;        if(top_c==&#x27;&#123;&#x27;)            return c2==&#x27;&#125;&#x27;;        return false;    &#125;    public static void main(String[]s)&#123;        String str=new String(&quot;[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]&quot;);        System.out.println(new Solution().isValid(str));    &#125;&#125;\n不过优化了相当于没有优化\n\n另外一种更好的优化思路:\n遍历字符串中的字符\n\n如果是左括号就入栈他**对应的右括号 **\n如果在遍历过程中栈就为空了就 return false\n如果是右括号, 与栈顶相同就 pop 栈顶, 不相同就 return false\n\n123456789101112131415161718public boolean isValid(String s) &#123;       if(s.isEmpty())           return true;       Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;();       for(char c:s.toCharArray())&#123;           if(c==&#x27;(&#x27;)               stack.push(&#x27;)&#x27;);           else if(c==&#x27;&#123;&#x27;)               stack.push(&#x27;&#125;&#x27;);           else if(c==&#x27;[&#x27;)               stack.push(&#x27;]&#x27;);           else if(stack.empty()||c!=stack.pop())               return false;       &#125;       if(stack.empty())           return true;       return false;   &#125;\n\n推荐文章洛谷【搜索】暴力专项训练八皇后问题位运算kuangbin 题单动态规划系列-子数组最大和","plink":"https://mvbbb.github.io/gggq6t/"},{"title":"About","date":"2020-08-13T14:31:36.000Z","date_formatted":{"ll":"Aug 13, 2020","L":"08/13/2020","MM-DD":"08-13"},"updated":"2021-02-03T04:20:05.898Z","content":"About Me\n普通在校大学生\n爱好: 网抑云, 拍🌈🌥\n\n坐标: 西南\n学习方向: Java后端\nAbout this site\n现在的内容产出大多是笔记向的, 因为技术还不到家, 对技术还没太多思考, 等之后学得多了, 文章质量应该会慢慢提高.\n有发现笔记存在错误或者描述不清的地方欢迎 mail_to_me, 或者文章下方评论.\n欢迎订阅的我站点哈哈哈!\n","plink":"https://mvbbb.github.io/about/"},{"title":"邻居","date":"2021-02-03T04:20:05.898Z","date_formatted":{"ll":"Feb 3, 2021","L":"02/03/2021","MM-DD":"02-03"},"updated":"2021-02-03T04:20:05.898Z","content":"\n    \n        \n        \n            Jev0n\n            Coder,CTFer,专业写BUG\n        \n    \n\n\n.friends{display:flex;flex-wrap:wrap;}.friends .brick{-webkit-transition:all .3s ease;transition:all .3s ease;}.friends .brick{display:flex;margin:10px 10px 0 0;text-decoration:none;font-weight:300;padding:10px;background-color:#fff0;border:solid 1px #659eb929;color:#659eb9;text-align:center;border-radius:4px;overflow:hidden}.friends .brick:hover{background-color:#659eb9;color:#fff;border:solid 1px #659eb9;box-shadow:0 6px 16px 0 rgba(80, 178, 243, 0.35);}.blog-avatar:hover{animation:whirl 0.5s;}\n@keyframes whirl{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}.friends .brick:active{-webkit-transform:scale(0.95);-moz-transform:scale(0.95);-ms-transform:scale(0.95);-o-transform:scale(0.95);transform:scale(0.95);}.friends .brick .blog-avatar{background-color:#fff0;color:#fff;border:solid 1px #dbdbdb;border-radius:50%;width:50px;height:50px;}.friends .brick .container{margin-left:10px;}.friends .brick .container .name{font-size:14px;}.friends .brick .container .motto{font-size:12px;margin-top:5px;-webkit-box-orient:vertical;-webkit-line-clamp:1;}\n@media(max-width:450px){.friends .brick{width:100%;}.friends .brick .container{margin-left:0;width:100%;}.motto{width: 100% !important;}}.motto.long{width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}.mdui-panel-item[open] .mdui-panel-item-arrow{transform:rotate(180deg);}.mdui-panel-item-body {height:auto!important;}\n\n","plink":"https://mvbbb.github.io/links/"}]