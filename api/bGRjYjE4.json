{"title":"内存管理","date":"2020-10-21T05:51:37.000Z","date_formatted":{"ll":"Oct 21, 2020","L":"10/21/2020","MM-DD":"10-21"},"link":"ldcb18","comments":true,"tags":["OS"],"categories":["操作系统"],"updated":"2021-02-03T04:20:59.433Z","content":"<h1 id=\"内存管理概念\">内存管理概念<a title=\"#内存管理概念\" href=\"#内存管理概念\"></a></h1>\n<p>覆盖, 交换, 连续分配算法<br>\n工作集: 某段时间间隔内, 实际访问的页面的集合<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1605006818693-43861290-7c1c-40be-8cfc-70573a5d6a47.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=552&amp;originWidth=997&amp;size=200038&amp;status=done&amp;style=none&amp;width=498.5\" alt=\"image.png\"></p>\n<h2 id=\"针对一个页表\">针对一个页表<a title=\"#针对一个页表\" href=\"#针对一个页表\"></a></h2>\n<p>逻辑地址: 适用于一个进程内部, 由页表号和偏移量组成<br>\n物理地址: 具体的物理地址.<br>\n地址结构: 页表号+页内偏移量<br>\n页面/页/页框: 内存中的一小片<br>\n页面大小: 内存中一小片的大小<br>\n页表: 用于链接进程地址和实际物理地址<br>\n页表项: 结合逻辑地址, 找到对应的页表项, 页表项中记录了内存中实际的物理地址<br>\n页表项大小: 页面大小/页表项大小=页表项个数</p>\n<p>页号: 页表项的编号, 从 0 开始<br>\n页内偏移量: 在一个页面内的偏移量, 最大值是页面大小<br>\n页表寄存器:   记录页表的起始长度和页表的大小<br>\n快表: 相联存储器, 记录访问过的页表号和内存号, 加快下次访问速度</p>\n<h2 id=\"针对多级页表\">针对多级页表<a title=\"#针对多级页表\" href=\"#针对多级页表\"></a></h2>\n<p>一级页表: 记录二级页表在内存中的内存块号<br>\n二级页表: 记录下一级页表在内存中的内存块号, 如果本身是最后一级页表, 就是记录的所需内存块号<br>\n一级/二级页表: 特指两级页表中, 称链接进程逻辑地址的那个页表为一级页表. 采用了多级页表之后, 逻辑地址结构也需要对应的进行修改, 原来只需要找到在一个页表中的某个页表号, 原来使用一个坐标就能定位, 现在者需要多个. 以二级页表为例, 逻辑地址结构修改为: 一级页号+二级页号+页内偏移</p>\n<p>采用多级页表机制, 各级页表大小不能超过一个页面</p>\n<h2 id=\"分段\">分段<a title=\"#分段\" href=\"#分段\"></a></h2>\n<p>逻辑地址: 段号(前 16 位)+段内地址(后 16 位)<br>\n段号的位数决定了每个进程最多可以分几个端<br>\n段内地址位数决定了每个端的最大长度是多少<br>\n段表: 段号, 段长, 基址<br>\n段名: 在低级语言中, 进程被分为多个段, 可以为他们取单独的名称. 隐含的, 不占存储空间<br>\n段表项: 各个段表项的长度是相同的<br>\n段表长度: 段表项的个数<br>\n基址: 物理地址的开始地址<br>\n段长: 该段号对应的实际长度, 与页不同, 它的大小不固定, 在段内地址的合法性校验中会用到.</p>\n<h2 id=\"段页式管理\">段页式管理<a title=\"#段页式管理\" href=\"#段页式管理\"></a></h2>\n<p>逻辑地址: 段号(前 16 位)+页号(中间 4 位)+页内偏移量(后 12 位)<br>\n段号的位数决定了每个进程最多可以分几个段<br>\n页号的位数决定了每个段最多有多少页<br>\n页内偏移量决定了页面的大小, 内存块的大小是多少<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1603260036963-a5740b21-f9c3-492f-91e3-4512da67d07c.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=803&amp;size=69165&amp;status=done&amp;style=none&amp;width=401.5\" alt=\"image.png\"></p>\n<h1 id=\"虚拟存储概念\">虚拟存储概念<a title=\"#虚拟存储概念\" href=\"#虚拟存储概念\"></a></h1>\n<p>虚拟内存的最大容量是由计算机的地址结构确定的<br>\n虚拟内存的实际容量 = min(内存+外存, CPU 的寻址范围)<br>\n请求调页: 将内存中缺失的页面调入内存<br>\n页面置换: 将暂时用不到的页面调出内存<br>\n请求分页存储的页表: 内存块号+状态位(是否已经调入内存)+访问字段(该页面被访问过几次/记录上一次访问这个页面的时间, 用于判断是否需要调出内存)+修改位(自从调入是否被修改过)+外存地址<br>\n改进型时钟置换算法: 优先考虑没有访问过的页面, 如果都被访问过, 就优先访问没有被修改过的, 如果都被修改过. 就选择最近访问过, 但是没有修改的, 最其次选择访问过而且被修改过的.<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262350467-0f7f4918-b0e4-45de-be7e-df087092515e.png#align=left&amp;display=inline&amp;height=361&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=721&amp;originWidth=777&amp;size=148235&amp;status=done&amp;style=none&amp;width=388.5\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1603262485196-75528ec8-0369-49df-ad5c-0fe443d72698.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=594&amp;originWidth=487&amp;size=92586&amp;status=done&amp;style=none&amp;width=243.5\" alt=\"image.png\"></p>\n<h1 id=\"相关问题\">相关问题<a title=\"#相关问题\" href=\"#相关问题\"></a></h1>\n<p><strong>为什么分页存储的地址空间是一维的，而分段存储的地址是二维的?</strong><br>\n短号和页号的来历是不同的，段号是程序员自己定义的，每个段都是有特定含义的，因此不同段的大小不同，代表的意义也不相同，因此要想找到某个数据或指令，<strong>需要指定段号和位移两个变量</strong>。而页号是系统自动生成的，本身地址是线性连续的，<strong>当要访问特定地址时，只需要提供地址即可</strong>。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此是一维的。<br>\n<strong>一维或者二维是相对于程序员来讲的</strong></p>\n<blockquote>\n<p>转载自 <a href=\"https://blog.csdn.net/xiaotai1234/article/details/107427547\" target=\"_blank\" rel=\"external nofollow noopener\">https://blog.csdn.net/xiaotai1234/article/details/107427547</a></p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/1552854/1604924358520-2e69ca06-b690-4c7c-8cd4-2ba3720c348a.png#align=left&amp;display=inline&amp;height=61&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=746&amp;size=41821&amp;status=done&amp;style=none&amp;width=373\" alt=\"image.png\"><br>\n页目录号 = (LA&gt;&gt;22)&amp;1111111111, 页表索引 = (LA&gt;&gt;12)&amp;1111111111</p>\n<p>页式存储中页表记录的是内存块号, 段式存储中记录的是内存始址<br>\n页面的大小 = 2^(逻辑地址的长度)</p>\n<div><h1 id=\"推荐文章\">推荐文章<a title=\"#推荐文章\" href=\"%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\"></a></h1><ul><li><a href=\"https://mvbbb.github.io/ognzg7/\">经典进程同步问题</a></li></ul></div>","prev":{"title":"Linux服务器安装 MySql 8.0并配置远程连接","link":"sb74kg"},"next":{"title":"经典进程同步问题","link":"ognzg7"},"plink":"https://mvbbb.github.io/ldcb18/","toc":[{"id":"内存管理概念","title":"内存管理概念","index":"1","children":[{"id":"针对一个页表","title":"针对一个页表","index":"1.1"},{"id":"针对多级页表","title":"针对多级页表","index":"1.2"},{"id":"分段","title":"分段","index":"1.3"},{"id":"段页式管理","title":"段页式管理","index":"1.4"}]},{"id":"虚拟存储概念","title":"虚拟存储概念","index":"2"},{"id":"相关问题","title":"相关问题","index":"3"},{"id":"推荐文章","title":"推荐文章","index":"4"}],"copyright":{"author":"Mvbbb","link":"<a href=\"https://mvbbb.github.io/ldcb18/\" title=\"内存管理\">https://mvbbb.github.io/ldcb18/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}