<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<title>力扣-二叉树 - Yu</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://mvbbb.github.io/zhme42/">
<link rel="icon" type="image/x-icon" href="/images/web.png">

<meta name="description" content="遍历树叶 题目描述  https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624   思路  题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历 使用 queue 实现层序遍历 利用数组来保存结点信息 [静态链表]  123456789101112131415161718">
<meta property="og:type" content="website">
<meta property="og:title" content="力扣-二叉树">
<meta property="og:url" content="https://mvbbb.github.io/zhme42/index.html">
<meta property="og:site_name" content="Yu">
<meta property="og:description" content="遍历树叶 题目描述  https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624   思路  题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历 使用 queue 实现层序遍历 利用数组来保存结点信息 [静态链表]  123456789101112131415161718">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mvbbb.github.io/zhme42/images/avatar.jpg">
<meta property="article:published_time" content="2020-08-04T16:02:51.000Z">
<meta property="article:modified_time" content="2021-02-03T04:21:01.093Z">
<meta property="article:author" content="Mvbbb">
<meta property="article:tag" content="递归">
<meta property="article:tag" content="树">
<meta property="article:tag" content="算法与数据结构">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="回溯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mvbbb.github.io/zhme42/images/avatar.jpg">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"url":"https://mvbbb.github.io","image":"https://mvbbb.github.io/images/avatar.jpg","description":"Who i am,who u are","author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"数据结构与算法","url":"https://mvbbb.github.io/zhme42/","headline":"力扣-二叉树","image":"https://mvbbb.github.io/images/avatar.jpg","datePublished":"2020-08-04T16:02:51.000Z","dateModified":"2021-02-03T04:21:01.093Z","keywords":"递归,树,算法与数据结构,二叉树,回溯","description":"Who i am,who u are","publisher":{"@type":"Organization","name":"Yu","logo":{"@type":"ImageObject","url":"https://mvbbb.github.io/images/avatar.jpg"}},"author":{"@type":"Person","name":"Mvbbb","description":"Who i am,who u are","image":"https://mvbbb.github.io/images/avatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mvbbb.github.io/zhme42/"}}]</script><link rel="alternate" type="application/atom+xml" title="Yu" href="/rss2.xml">
<script async="" src="//www.googletagmanager.com/gtag/js?id=UA-160027215-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','UA-160027215-1');</script>
<meta name="theme-color" content=""><script type="application/json" is="state">{&q;api/emhtZTQy.json&q;:{&q;title&q;:&q;力扣-二叉树&q;,&q;date&q;:&q;2020-08-04T16:02:51.000Z&q;,&q;date_formatted&q;:{&q;ll&q;:&q;Aug 4, 2020&q;,&q;L&q;:&q;08/04/2020&q;,&q;MM-DD&q;:&q;08-04&q;},&q;link&q;:&q;zhme42&q;,&q;comments&q;:true,&q;tags&q;:[&q;二叉树&q;,&q;回溯&q;,&q;树&q;,&q;算法与数据结构&q;,&q;递归&q;],&q;categories&q;:[&q;数据结构与算法&q;,&q;算法&q;],&q;updated&q;:&q;2021-02-03T04:21:01.093Z&q;,&q;content&q;:&q;&l;h1 id=\&q;遍历树叶\&q;&g;遍历树叶&l;a title=\&q;#遍历树叶\&q; href=\&q;#遍历树叶\&q;&g;&l;/a&g;&l;/h1&g;\n&l;h2 id=\&q;题目描述\&q;&g;题目描述&l;a title=\&q;#题目描述\&q; href=\&q;#题目描述\&q;&g;&l;/a&g;&l;/h2&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200511224727.png#align=left&a;amp;display=inline&a;amp;height=867&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=867&a;amp;originWidth=1283&a;amp;status=done&a;amp;style=none&a;amp;width=1283\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h2 id=\&q;思路\&q;&g;思路&l;a title=\&q;#思路\&q; href=\&q;#思路\&q;&g;&l;/a&g;&l;/h2&g;\n&l;ol&g;\n&l;li&g;题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历&l;/li&g;\n&l;li&g;使用 &l;code&g;queue&l;/code&g; 实现层序遍历&l;/li&g;\n&l;li&g;利用数组来保存结点信息 [静态链表]&l;/li&g;\n&l;/ol&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;32&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;33&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;34&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;35&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;36&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;37&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;38&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;39&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;40&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;41&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;42&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;43&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;44&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;45&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;46&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;47&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;48&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;49&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;50&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;51&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;52&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;53&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;54&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;55&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;56&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;57&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;58&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;59&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;60&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;61&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;62&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;63&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;#&l;span class=\&q;meta-keyword\&q;&g;include&l;/span&g;&l;span class=\&q;meta-string\&q;&g;&a;lt;iostream&a;gt;&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;using&l;/span&g; &l;span class=\&q;keyword\&q;&g;namespace&l;/span&g; &l;span class=\&q;built_in\&q;&g;std&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;#&l;span class=\&q;meta-keyword\&q;&g;include&l;/span&g;&l;span class=\&q;meta-string\&q;&g;&a;lt;queue&a;gt;&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;struct&l;/span&g; &l;span class=\&q;title\&q;&g;node&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g;  left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;//层序遍历&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;LevelTra&l;/span&g;&l;span class=\&q;params\&q;&g;(node tree[], &l;span class=\&q;keyword\&q;&g;int&l;/span&g; root_index)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; myqueue;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag = &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    myqueue.push(root_index);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (!myqueue.empty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; T = myqueue.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        myqueue.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (tree[T].left == &l;span class=\&q;number\&q;&g;-1&l;/span&g; &a;amp;&a;amp; tree[T].right == &l;span class=\&q;number\&q;&g;-1&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (flag)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; T;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g; &a;lt;&a;lt; T;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            flag = &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (tree[T].left!=&l;span class=\&q;number\&q;&g;-1&l;/span&g;) myqueue.push( tree[T].left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (tree[T].right!=&l;span class=\&q;number\&q;&g;-1&l;/span&g;) myqueue.push(tree[T].right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cin&l;/span&g; &a;gt;&a;gt; n;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    node* tree=&l;span class=\&q;keyword\&q;&g;new&l;/span&g; node[n];&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;char&l;/span&g; left, right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;//写入树&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; root[&l;span class=\&q;number\&q;&g;100&l;/span&g;]&a;#123;&l;span class=\&q;number\&q;&g;0&l;/span&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = &l;span class=\&q;number\&q;&g;0&l;/span&g;; i != n; i++)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;cin&l;/span&g; &a;gt;&a;gt; left &a;gt;&a;gt; right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (left == &l;span class=\&q;string\&q;&g;&a;#x27;-&a;#x27;&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            tree[i].left = &l;span class=\&q;number\&q;&g;-1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;else&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            tree[i].left = left - &l;span class=\&q;string\&q;&g;&a;#x27;0&a;#x27;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root[left-&l;span class=\&q;string\&q;&g;&a;#x27;0&a;#x27;&l;/span&g;] = &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (right == &l;span class=\&q;string\&q;&g;&a;#x27;-&a;#x27;&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            tree[i].right = &l;span class=\&q;number\&q;&g;-1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;else&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            tree[i].right = right - &l;span class=\&q;string\&q;&g;&a;#x27;0&a;#x27;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root[right-&l;span class=\&q;string\&q;&g;&a;#x27;0&a;#x27;&l;/span&g;] = &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; root_index;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = &l;span class=\&q;number\&q;&g;0&l;/span&g;; i != n; i++)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root[i] == &l;span class=\&q;number\&q;&g;0&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root_index = i;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    LevelTra(tree, root_index);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;先序遍历顺序建立二叉树链表\&q;&g;先序遍历顺序建立二叉树链表&l;a title=\&q;#先序遍历顺序建立二叉树链表\&q; href=\&q;#先序遍历顺序建立二叉树链表\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121100.png#align=left&a;amp;display=inline&a;amp;height=488&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=488&a;amp;originWidth=1164&a;amp;status=done&a;amp;style=none&a;amp;width=1164\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;代码实现:&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;32&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;33&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;34&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;35&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;36&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;37&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;38&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;39&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;40&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;41&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;42&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;43&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;44&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;45&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;46&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;47&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;48&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;49&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;50&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;#&l;span class=\&q;meta-keyword\&q;&g;include&l;/span&g;&l;span class=\&q;meta-string\&q;&g;&a;lt;iostream&a;gt;&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;#&l;span class=\&q;meta-keyword\&q;&g;include&l;/span&g;&l;span class=\&q;meta-string\&q;&g;&a;lt;stack&a;gt;&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;using&l;/span&g; &l;span class=\&q;keyword\&q;&g;namespace&l;/span&g; &l;span class=\&q;built_in\&q;&g;std&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;struct&l;/span&g; &l;span class=\&q;title\&q;&g;node&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    node*  left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    node* right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;char&l;/span&g; data;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;createBiTree&l;/span&g;&l;span class=\&q;params\&q;&g;(node*&a;amp; T)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;char&l;/span&g; ch;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cin&l;/span&g; &a;gt;&a;gt; ch;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (ch == &l;span class=\&q;string\&q;&g;&a;#x27;#&a;#x27;&l;/span&g;) T = &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; node;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;data = ch;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        createBiTree(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        createBiTree(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;inOders&l;/span&g;&l;span class=\&q;params\&q;&g;(node* tree)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;string\&q;&g;&a;quot;中序遍历&a;quot;&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;built_in\&q;&g;endl&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    node* T = tree;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;node*&a;gt; mystack;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (T || !mystack.empty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            mystack.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            T = T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            T = mystack.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            mystack.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; T-&a;gt;data &a;lt;&a;lt; &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            T = T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;built_in\&q;&g;endl&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    node* tree = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; node;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    createBiTree(tree);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    inOders(tree);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;return&l;/span&g;    &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;测试案例:&l;/strong&g; &l;code&g;ABC##DE#G##F###&l;/code&g;&l;/p&g;\n&l;p&g;&l;strong&g;建立结果:&l;/strong&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121021.png#align=left&a;amp;display=inline&a;amp;height=374&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=374&a;amp;originWidth=374&a;amp;status=done&a;amp;style=none&a;amp;width=374\&q; alt=\&q;\&q;&g;&l;/p&g;\n&l;h1 id=\&q;复制二叉树\&q;&g;复制二叉树&l;a title=\&q;#复制二叉树\&q; href=\&q;#复制二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121055.png#align=left&a;amp;display=inline&a;amp;height=450&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=450&a;amp;originWidth=1153&a;amp;status=done&a;amp;style=none&a;amp;width=1153\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;代码实现:&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;Copy&l;/span&g;&l;span class=\&q;params\&q;&g;(node* T, node*&a;amp; newT)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        newT = &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        newT = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; node;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        newT-&a;gt;data = T-&a;gt;data;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Copy(T-&a;gt;left, newT-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Copy(T-&a;gt;right, newT-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;测试案例:&l;/strong&g; &l;code&g;ABC##DE#G##F###&l;/code&g;&l;/p&g;\n&l;p&g;&l;strong&g;打印结果:&l;/strong&g; &l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513122702.png#align=left&a;amp;display=inline&a;amp;height=146&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=146&a;amp;originWidth=699&a;amp;status=done&a;amp;style=none&a;amp;width=699\&q; alt=\&q;\&q;&g;&l;/p&g;\n&l;h1 id=\&q;计算二叉树的深度\&q;&g;计算二叉树的深度&l;a title=\&q;#计算二叉树的深度\&q; href=\&q;#计算二叉树的深度\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513160326.png#align=left&a;amp;display=inline&a;amp;height=335&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=335&a;amp;originWidth=1167&a;amp;status=done&a;amp;style=none&a;amp;width=1167\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;递龟实现&l;/strong&g;:&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;Depth&l;/span&g;&l;span class=\&q;params\&q;&g;(node* T)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; m = Depth(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n = Depth(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (m &a;gt; n)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; m + &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; n + &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;统计二叉树中结点的个数\&q;&g;统计二叉树中结点的个数&l;a title=\&q;#统计二叉树中结点的个数\&q; href=\&q;#统计二叉树中结点的个数\&q;&g;&l;/a&g;&l;/h1&g;\n&l;h1 id=\&q;二叉树的可视化\&q;&g;二叉树的可视化&l;a title=\&q;#二叉树的可视化\&q; href=\&q;#二叉树的可视化\&q;&g;&l;/a&g;&l;/h1&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515192331.png#align=left&a;amp;display=inline&a;amp;height=197&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=197&a;amp;originWidth=253&a;amp;status=done&a;amp;style=none&a;amp;width=253\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;output_impl&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* n, &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; left, &l;span class=\&q;built_in\&q;&g;string&l;/span&g; &l;span class=\&q;keyword\&q;&g;const&l;/span&g;&a;amp; indent)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (n-&a;gt;right)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        output_impl(n-&a;gt;right, &l;span class=\&q;literal\&q;&g;false&l;/span&g;, indent + (left ? &l;span class=\&q;string\&q;&g;&a;quot;|     &a;quot;&l;/span&g; : &l;span class=\&q;string\&q;&g;&a;quot;      &a;quot;&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; indent;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; (left ? &l;span class=\&q;string\&q;&g;&a;#x27;\\\\&a;#x27;&l;/span&g; : &l;span class=\&q;string\&q;&g;&a;#x27;/&a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;string\&q;&g;&a;quot;-----&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; n-&a;gt;data &a;lt;&a;lt; &l;span class=\&q;built_in\&q;&g;endl&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (n-&a;gt;left)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        output_impl(n-&a;gt;left, &l;span class=\&q;literal\&q;&g;true&l;/span&g;, indent + (left ? &l;span class=\&q;string\&q;&g;&a;quot;      &a;quot;&l;/span&g; : &l;span class=\&q;string\&q;&g;&a;quot;|     &a;quot;&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;output&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;string\&q;&g;&a;quot;左边在下面,右边在上面&a;quot;&l;/span&g; &a;lt;&a;lt; &l;span class=\&q;built_in\&q;&g;endl&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root-&a;gt;right)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        output_impl(root-&a;gt;right, &l;span class=\&q;literal\&q;&g;false&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;cout&l;/span&g; &a;lt;&a;lt; root-&a;gt;data &a;lt;&a;lt; &l;span class=\&q;built_in\&q;&g;endl&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root-&a;gt;left)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        output_impl(root-&a;gt;left, &l;span class=\&q;literal\&q;&g;true&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;二叉树的后序遍历\&q;&g;二叉树的后序遍历&l;a title=\&q;#二叉树的后序遍历\&q; href=\&q;#二叉树的后序遍历\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-tree-postorder-traversal/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;递归方法很简单&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v1;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;postorderTraversal&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v1;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            rec(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            rec(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            v1.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;对于这样一颗树, 我们有三种情况会访问 A 结点, 1 第一次结果他访问他的左子树, 2 他的左子树访问完了开始访问他的右子树, 3 他的左右子树都访问完了,开始访问他本身.&l;br&g;\n使用栈迭代, 先把最左边的结点入栈.&l;br&g;\n第三种情况需要我们判断他的右子树是否已经访问,或者上他的右子树为空,满足条件之一我们就访问 A 结点.&l;br&g;\n使用一个指针来标记上一次完成访问的结点. 如果 A 的右子树不为空, 那么在 A 之前访问的结点一定是 A 的右子树. 如果 A 的右子树为空, 那么我们可以直接访问 A 结点.&l;br&g;\n如果上面的条件不满足, 证明 A 的右子树还没有访问我们进入他的右子树继续迭代&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;postorderTraversal&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; s;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T = root, *p = &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (T || !s.empty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                s.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = s.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                s.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T-&a;gt;right != p &a;amp;&a;amp; T-&a;gt;right != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    s.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    T = T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;else&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    v.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    p = T;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    T = &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515223810.png#align=left&a;amp;display=inline&a;amp;height=163&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=163&a;amp;originWidth=818&a;amp;status=done&a;amp;style=none&a;amp;width=818\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;二叉树的最大深度\&q;&g;二叉树的最大深度&l;a title=\&q;#二叉树的最大深度\&q; href=\&q;#二叉树的最大深度\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;递归解法简单&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;maxDepth&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (!root) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; m = maxDepth(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n = maxDepth(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; depth = (m &a;gt; n ? m : n)+&l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; depth;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;复杂度分析:&l;br&g;\n时间复杂度 &l;img src=\&q;https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&a;amp;code=O%28n%29&a;amp;height=20&a;amp;width=36\&q; alt=\&q;\&q;&g;&l;/p&g;\n&l;h1 id=\&q;翻转二叉树\&q;&g;翻转二叉树&l;a title=\&q;#翻转二叉树\&q; href=\&q;#翻转二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/invert-binary-tree/submissions/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/invert-binary-tree/submissions/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;递归简单&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;invertTree&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode*&a;amp; T)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (!T) &l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* temp = T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;left = T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;right = temp;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;二叉树的层序遍历\&q;&g;二叉树的层序遍历&l;a title=\&q;#二叉树的层序遍历\&q; href=\&q;#二叉树的层序遍历\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;和普通的层序遍历不太一样的是, 普通的层序遍历无法得知他的层数信息, 但是这个要返回一个二维数组&l;/p&g;\n&l;p&g;从队列中取出一个结点, 把他的儿子结点 &l;code&g;push&l;/code&g; 进去. 每次遍历一层我们都会把这一层的结点的儿子都 &l;code&g;push&l;/code&g; 进来, &l;code&g;push&l;/code&g; 进来的总数是儿子节点的总数.&l;/p&g;\n&l;p&g;我们要一次性从队列里面取出这一层的全部结点. &l;code&g;queue.size()&l;/code&g; 作为我们取出的个数&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;gt; levelOrder(TreeNode* root) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;TreeNode*&a;gt; qu;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;gt; vve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root!=&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) qu.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (!qu.empty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; temp;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; size = qu.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = &l;span class=\&q;number\&q;&g;0&l;/span&g;; i != size; i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                TreeNode* T = qu.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                temp.push_back(&l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                qu.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T-&a;gt;left)qu.push(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T-&a;gt;right)qu.push(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            vve.push_back(temp);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; vve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;这道题花了我很长时间, 不能直接用 &l;code&g;qu.size()&l;/code&g; 作为循环条件, 因为 &l;code&g;size&l;/code&g; 会变&l;/p&g;\n&l;h1 id=\&q;二叉搜索树的范围和\&q;&g;二叉搜索树的范围和&l;a title=\&q;#二叉搜索树的范围和\&q; href=\&q;#二叉搜索树的范围和\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/range-sum-of-bst/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/range-sum-of-bst/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;其实是二叉树中序遍历得到的序列, 在 L 和 R 之间的数求和&l;/p&g;\n&l;p&g;&l;strong&g;最简单的思路&l;/strong&g;&l;/p&g;\n&l;ol&g;\n&l;li&g;使用迭代栈中序遍历&l;/li&g;\n&l;li&g;使用 &l;code&g;falg&l;/code&g; 判断该数是否在 L 和 R 之间&l;/li&g;\n&l;/ol&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;rangeSumBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; L, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; R)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; s;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T = root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (T || !s.empty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                s.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;else&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = s.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                s.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T-&a;gt;val == L) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    flag = &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (flag)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    sum += T-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (T-&a;gt;val == R &a;amp;&a;amp; flag)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    flag = &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; sum;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;n-叉树的后序遍历\&q;&g;N 叉树的后序遍历&l;a title=\&q;#n-叉树的后序遍历\&q; href=\&q;#n-叉树的后序遍历\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;递归方法很简单&l;/strong&g;&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200516222301.png#align=left&a;amp;display=inline&a;amp;height=231&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=231&a;amp;originWidth=823&a;amp;status=done&a;amp;style=none&a;amp;width=823\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;postorder&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (!root)&l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = &l;span class=\&q;number\&q;&g;0&l;/span&g;; i != root-&a;gt;children.size(); i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            rec(root-&a;gt;children[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        v.push_back(root-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;迭代思路&l;/strong&g;&l;/p&g;\n&l;p&g;后序遍历，首先最简单的做法是 记住前序 翻转就实现 (直接利用 1.前序遍历 2.翻转)&l;/p&g;\n&l;p&g;访问栈顶, val 放入到 ve 中, 将栈顶 pop 出来, 将其子树全部按照顺序地放入到栈中. 循环该过程&l;/p&g;\n&l;p&g;循环结束的条件是栈空, 在访问完最后一个结点时栈肯定是空的, 其余情况栈肯定不为空&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;postorder&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!root) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;Node*&a;gt; s;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        s.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(!s.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            Node* T=s.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            s.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                v.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=T-&a;gt;children.size();i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                     s.push(T-&a;gt;children[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        reverse(v.begin(),v.end());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517084030.png#align=left&a;amp;display=inline&a;amp;height=312&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=312&a;amp;originWidth=794&a;amp;status=done&a;amp;style=none&a;amp;width=794\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;n-叉树的前序遍历\&q;&g;N 叉树的前序遍历&l;a title=\&q;#n-叉树的前序遍历\&q; href=\&q;#n-叉树的前序遍历\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;递归法很简单&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;preorder&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* T)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!T) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        v.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=T-&a;gt;children.size();i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            rec(T-&a;gt;children[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;迭代法就相当于上一道题不用 &l;code&g;reverse(v.begin(),v.end());&l;/code&g;&l;/p&g;\n&l;h1 id=\&q;将有序数组转换为二叉搜索树\&q;&g;将有序数组转换为二叉搜索树&l;a title=\&q;#将有序数组转换为二叉搜索树\&q; href=\&q;#将有序数组转换为二叉搜索树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;只有一个中序/后序/前序遍历序列无法唯一确定一颗平衡二叉搜索树&l;/p&g;\n&l;p&g;给定了有序数组, 中序遍历时根结点一定处于有序数组的中间部分, 可以递归的每次选数组中间部分作为根结点&l;/p&g;\n&l;p&g;&l;strong&g;方法一：中序遍历：始终选择中间位置左边元素作为根节点&l;/strong&g;&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517164034.png#align=left&a;amp;display=inline&a;amp;height=233&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=233&a;amp;originWidth=844&a;amp;status=done&a;amp;style=none&a;amp;width=844\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; nums;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; left, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; right)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;    &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (left &a;gt; right) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; mid = (left + right)/&l;span class=\&q;number\&q;&g;2&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(nums[mid]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;left = helper(left, mid - &l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;right = helper(mid+&l;span class=\&q;number\&q;&g;1&l;/span&g;,right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; T;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;sortedArrayToBST&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; nums)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;this&l;/span&g;-&a;gt;nums = nums;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; helper(&l;span class=\&q;number\&q;&g;0&l;/span&g;, nums.size() - &l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;方法二：中序遍历：始终选择中间位置右边元素作为根节点&l;/strong&g;&l;/p&g;\n&l;p&g;&l;strong&g;方法三：中序遍历：选择任意一个中间位置元素作为根节点&l;/strong&g;&l;/p&g;\n&l;h1 id=\&q;*特定深度节点链表\&q;&g;*特定深度节点链表&l;a title=\&q;#*特定深度节点链表\&q; href=\&q;#*特定深度节点链表\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/list-of-depth-lcci/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/list-of-depth-lcci/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;很明显, 采取层次遍历, 每一层变成一条链表&l;/p&g;\n&l;p&g;队列实现层次遍历, 链表的创建采取后插法, 函数返回一个数组, 数组元素是链表头指针&l;/p&g;\n&l;h1 id=\&q;二叉树的中序遍历\&q;&g;二叉树的中序遍历&l;a title=\&q;#二叉树的中序遍历\&q; href=\&q;#二叉树的中序遍历\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;inorderTraversal&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; st;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T=root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(T||!st.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                st.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=st.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                st.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                ve.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;祖父节点值为偶数的节点和\&q;&g;祖父节点值为偶数的节点和&l;a title=\&q;#祖父节点值为偶数的节点和\&q; href=\&q;#祖父节点值为偶数的节点和\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;使用三元组来存储结点关系 &l;code&g;(grandparent, parent, node)&l;/code&g; , 之后判断 &l;code&g;node.left&l;/code&g;, &l;code&g;node.right&l;/code&g;&l;/p&g;\n&l;p&g;官方思路还是比较普通的, 没我想的那么复杂&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; ans = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* grandparent, TreeNode* parent, TreeNode* node)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (!node)&l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (grandparent-&a;gt;val % &l;span class=\&q;number\&q;&g;2&l;/span&g; == &l;span class=\&q;number\&q;&g;0&l;/span&g;)ans += node-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//遍历下一层&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(parent, node, node-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(parent, node, node-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;sumEvenGrandparent&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root-&a;gt;left != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            dfs(root, root-&a;gt;left, root-&a;gt;left-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            dfs(root, root-&a;gt;left, root-&a;gt;left-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root-&a;gt;right) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            dfs(root, root-&a;gt;right, root-&a;gt;right-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            dfs(root, root-&a;gt;right, root-&a;gt;right-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ans;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;在上一种方法中, 由于根节点没有父结点, 他的根节点的子结点没有祖父结点, 因此我们是从 &l;code&g;root-&a;gt;left-&a;gt;right&l;/code&g; 开始的, 因此我们必须使用&l;code&g;if (root-&a;gt;left != NULL)&l;/code&g;来判断他有没有子结点. 我们可以简化这个过程, 根结点是没有父结点和祖父结点的, 但是我们可以假设他的父结点的值是 1 , 效果是一样的&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;private&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; ans = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; gp_val, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; p_val, TreeNode* node)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (!node) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (gp_val % &l;span class=\&q;number\&q;&g;2&l;/span&g; == &l;span class=\&q;number\&q;&g;0&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            ans += node-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(p_val, node-&a;gt;val, node-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(p_val, node-&a;gt;val, node-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;sumEvenGrandparent&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(&l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;number\&q;&g;1&l;/span&g;, root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ans;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518083648.png#align=left&a;amp;display=inline&a;amp;height=318&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=318&a;amp;originWidth=722&a;amp;status=done&a;amp;style=none&a;amp;width=722\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;根据前序和后序遍历构造二叉树\&q;&g;根据前序和后序遍历构造二叉树&l;a title=\&q;#根据前序和后序遍历构造二叉树\&q; href=\&q;#根据前序和后序遍历构造二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;ul class=\&q;φcz\&q;&g;\n&l;li&g;&l;input type=\&q;checkbox\&q; disabled=\&q;\&q;&g;&l;i&g;&l;/i&g;&l;a href=\&q;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/&l;/a&g;&l;/li&g;\n&l;/ul&g;\n&l;/blockquote&g;\n&l;p&g;只记得上课讲过, 知道是什么原理, 代码就是写不出来, 递归传哪些参数之类的拎不清&l;/p&g;\n&l;p&g;祭上一段优美的代码&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;int&l;/span&g; pre_index=&l;span class=\&q;number\&q;&g;0&l;/span&g;, post_index=&l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;  &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;constructFromPrePost&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; pre, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; post)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;      TreeNode* root = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(pre[pre_index++]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;      &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root-&a;gt;val != post[post_index])&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;          root-&a;gt;left = constructFromPrePost(pre, post);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;      &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;val != post[post_index])&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;          root-&a;gt;right = constructFromPrePost(pre, post);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;      post_index++;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;      &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;  &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518092242.png#align=left&a;amp;display=inline&a;amp;height=320&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=320&a;amp;originWidth=633&a;amp;status=done&a;amp;style=none&a;amp;width=633\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;二叉搜索树中的众数\&q;&g;二叉搜索树中的众数&l;a title=\&q;#二叉搜索树中的众数\&q; href=\&q;#二叉搜索树中的众数\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;怎么说呢, 感觉这道题怪怪的&l;/p&g;\n&l;p&g;&l;strong&g;思路:&l;/strong&g; 使用 &l;code&g;map&l;/code&g; 来保存数和它出现的频率, 最后再将出现频率最高的数放到 &l;code&g;vector&l;/code&g;, 里面&l;/p&g;\n&l;p&g;&l;code&g;map&l;/code&g; 中 &l;code&g;value&l;/code&g; 是出现频率, &l;code&g;key&l;/code&g; 是某个数.&l;/p&g;\n&l;p&g;回顾一下 &l;code&g;map&l;/code&g; 的特性: &l;strong&g;使用 &l;code&g;[]&l;/code&g; 访问不存在的 &l;code&g;key&l;/code&g;, &l;code&g;map&l;/code&g; 会把它自动添加进去, 并返回他的 &l;code&g;value&l;/code&g;&l;/strong&g;&l;/p&g;\n&l;p&g;就懒得自己写了, 太恼人了&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;map&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; &a;gt; mmp;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        mmp[root-&a;gt;val]++;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;findMode&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; maxn = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;keyword\&q;&g;auto&l;/span&g; it = mmp.begin(); it != mmp.end(); it++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (it-&a;gt;second == maxn) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                v.push_back(it-&a;gt;first);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;else&l;/span&g; &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (it-&a;gt;second &a;gt; maxn) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                maxn = it-&a;gt;second;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                v.clear();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                v.push_back(it-&a;gt;first);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; v;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*恢复二叉搜索树\&q;&g;*恢复二叉搜索树&l;a title=\&q;#*恢复二叉搜索树\&q; href=\&q;#*恢复二叉搜索树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/recover-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/recover-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;h1 id=\&q;路径总和\&q;&g;路径总和&l;a title=\&q;#路径总和\&q; href=\&q;#路径总和\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/path-sum/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/path-sum/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;哎呀, 不就是递归吗, 多简单啊, 轻轻松松的啦&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200519004054.png#align=left&a;amp;display=inline&a;amp;height=321&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=321&a;amp;originWidth=610&a;amp;status=done&a;amp;style=none&a;amp;width=610\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum=&l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;hasPathSum&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//遍历每一条路径,求和&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;this&l;/span&g;-&a;gt;sum=sum;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root,&l;span class=\&q;number\&q;&g;0&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; flag;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; pre_sum)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!T)&l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        pre_sum+=T-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(pre_sum==sum&a;amp;&a;amp;T-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;T-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)flag=&l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;left,pre_sum);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;right,pre_sum);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;不过相较于别人的代码还是过于臃肿&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;hasPathSum&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!root)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;val==sum&a;amp;&a;amp;!root-&a;gt;left&a;amp;&a;amp;!root-&a;gt;right)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; hasPathSum(root-&a;gt;left,sum-root-&a;gt;val)||hasPathSum(root-&a;gt;right,sum-root-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*二叉树的最近公共祖先\&q;&g;*二叉树的最近公共祖先&l;a title=\&q;#*二叉树的最近公共祖先\&q; href=\&q;#*二叉树的最近公共祖先\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;嗅到了递归的气息,   回溯算法&l;/p&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment&l;/a&g; &a;gt; &l;a href=\&q;https://www.youtube.com/watch?v=xzKrRf-SLqM\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://www.youtube.com/watch?v=xzKrRf-SLqM&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;犯糊涂了, 之前以为必须是两个结点的直接祖先, 题没看清楚, 不过肯定逃不了递归思路&l;/p&g;\n&l;p&g;公共祖先 situation:&l;/p&g;\n&l;ol&g;\n&l;li&g;p q 在 roo 的左右两边&l;/li&g;\n&l;li&g;1=root, p 在左边或者右边&l;/li&g;\n&l;li&g;p=root, q 在左边或者右边&l;/li&g;\n&l;/ol&g;\n&l;p&g;时间复杂度&l;br&g;\n&l;img src=\&q;https://g.yuque.com/gr/latex?O(n)#card=math&a;amp;code=O%28n%29\&q; alt=\&q;\&q;&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;lowestCommonAncestor&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, TreeNode* p, TreeNode* q)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||root==q||root==p) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* left = lowestCommonAncestor(root-&a;gt;left, p, q);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* right = lowestCommonAncestor(root-&a;gt;right, p, q);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (left != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g; &a;amp;&a;amp; right != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; left == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g; ? right : left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;blockquote&g;\n&l;p&g;因为是递归，使用函数后可认为左右子树已经算出结果&l;/p&g;\n&l;/blockquote&g;\n&l;h1 id=\&q;*出现次数最多的子树元素和\&q;&g;*出现次数最多的子树元素和&l;a title=\&q;#*出现次数最多的子树元素和\&q; href=\&q;#*出现次数最多的子树元素和\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/most-frequent-subtree-sum/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/most-frequent-subtree-sum/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;h1 id=\&q;二叉搜索树的第-k-大节点\&q;&g;二叉搜索树的第 k 大节点&l;a title=\&q;#二叉搜索树的第-k-大节点\&q; href=\&q;#二叉搜索树的第-k-大节点\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/&l;/a&g;)&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;还是比较简单的&l;/p&g;\n&l;p&g;二叉搜索树的特点: &l;strong&g;中序遍历序列递增&l;/strong&g;&l;/p&g;\n&l;p&g;思路: 访问结点, 放入&l;code&g;vector&l;/code&g; ,最后返回 &l;code&g;vector&l;/code&g; 里面倒数第 &l;code&g;k&l;/code&g; 个数&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;kthLargest&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; k)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve[ve.size()-k];&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!T) &l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ve.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;从上到下打印二叉树-ii\&q;&g;从上到下打印二叉树 II&l;a title=\&q;#从上到下打印二叉树-ii\&q; href=\&q;#从上到下打印二叉树-ii\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/&l;/a&g;)&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;噗, 又是层序遍历&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;gt; levelOrder(TreeNode* root) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;TreeNode*&a;gt; qu;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;gt; vve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        qu.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(!qu.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; size=qu.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; temp;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=size;i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                TreeNode* T=qu.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                qu.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                temp.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left)qu.push(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;right)qu.push(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            vve.push_back(temp);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; vve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;平衡二叉树\&q;&g;平衡二叉树&l;a title=\&q;#平衡二叉树\&q; href=\&q;#平衡二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;isBalanced&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; flag;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!T)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; m=rec(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n=rec(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(&l;span class=\&q;built_in\&q;&g;abs&l;/span&g;(m-n)&a;gt;=&l;span class=\&q;number\&q;&g;2&l;/span&g;) flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; max=m&a;gt;n?m:n;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; max+&l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;从上到下打印二叉树\&q;&g;从上到下打印二叉树&l;a title=\&q;#从上到下打印二叉树\&q; href=\&q;#从上到下打印二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;迷惑性题目, 未免太过简单&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;levelOrder&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;TreeNode*&a;gt; qu;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!root) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        qu.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(!qu.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            TreeNode* T=qu.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            qu.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            ve.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left) qu.push(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;right)   qu.push(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;注意下 &l;code&g;root&l;/code&g; 为空直接返回就是了&l;/p&g;\n&l;h1 id=\&q;*前序和中序序列构造二叉树\&q;&g;*前序和中序序列构造二叉树&l;a title=\&q;#*前序和中序序列构造二叉树\&q; href=\&q;#*前序和中序序列构造二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518090828.png#align=left&a;amp;display=inline&a;amp;height=423&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=423&a;amp;originWidth=1224&a;amp;status=done&a;amp;style=none&a;amp;width=1224\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;直接写的不太好, 还是直接看别人的&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;buildTree&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; preorder, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; inorder)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; pos = &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; buildTree(preorder, pos, inorder, &l;span class=\&q;number\&q;&g;0&l;/span&g;, inorder.size()&l;span class=\&q;number\&q;&g;-1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;buildTree&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; preorder, &l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;amp; pos, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; inorder, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; left, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; right)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (pos &a;gt;= preorder.size()) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (; i &a;lt;= right; ++i) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (inorder[i] == preorder[pos])&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;break&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* node = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(preorder[pos]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (left &a;lt;= i&l;span class=\&q;number\&q;&g;-1&l;/span&g;) node-&a;gt;left = buildTree(preorder, ++pos, inorder, left, i&l;span class=\&q;number\&q;&g;-1&l;/span&g;);  &l;span class=\&q;comment\&q;&g;// 左子树&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (i+&l;span class=\&q;number\&q;&g;1&l;/span&g; &a;lt;= right) node-&a;gt;right = buildTree(preorder, ++pos, inorder, i + &l;span class=\&q;number\&q;&g;1&l;/span&g;, right); &l;span class=\&q;comment\&q;&g;// 右子树&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; node;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;使用 &l;code&g;map&l;/code&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;unordered_map&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;, &l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; pos;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;buildTree&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; preorder, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; inorder)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n = preorder.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i = &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; n; i++)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            pos[inorder[i]] = i;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; dfs(preorder, inorder, &l;span class=\&q;number\&q;&g;0&l;/span&g;, n - &l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;number\&q;&g;0&l;/span&g;, n - &l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; pre, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; inor, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; pl, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; pr, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; il, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; ir)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;    &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(pl &a;gt; pr) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; k = pos[pre[pl]] - il;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* root = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(pre[pl]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root -&a;gt; left = dfs(pre, inor, pl + &l;span class=\&q;number\&q;&g;1&l;/span&g;, pl + k, il, il + k - &l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root -&a;gt; right = dfs(pre, inor, pl + k + &l;span class=\&q;number\&q;&g;1&l;/span&g;, pr, il + k + &l;span class=\&q;number\&q;&g;1&l;/span&g;, ir);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;二叉树的右视图\&q;&g;二叉树的右视图&l;a title=\&q;#二叉树的右视图\&q; href=\&q;#二叉树的右视图\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-tree-right-side-view/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-tree-right-side-view/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;我的思路:&l;/strong&g; 使用区分层数的层序遍历, 只打印每一层的最后一个结点&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;rightSideView&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;TreeNode*&a;gt; qu;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!root) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &a;#123;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T=&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        qu.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(!qu.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; size=qu.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=size;i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=qu.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                qu.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(i==size&l;span class=\&q;number\&q;&g;-1&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    ve.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left) qu.push(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;right) qu.push(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;缺点:&l;/strong&g; 将左子树的不必要的部分存储进了队列, 浪费内存&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520154638.png#align=left&a;amp;display=inline&a;amp;height=323&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=323&a;amp;originWidth=629&a;amp;status=done&a;amp;style=none&a;amp;width=629\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;复杂度分析:&l;/strong&g; 每个结点都入队出队了一次, 所以时间复杂度是 &l;img src=\&q;https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&a;amp;code=O%28n%29&a;amp;height=20&a;amp;width=36\&q; alt=\&q;\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;思路二:&l;/strong&g;   使用深度优先搜索, 先 &l;strong&g;根节点-&a;gt;右子树-&a;gt;左子树&l;/strong&g;, 与先序遍历顺序相反&l;br&g;\n只加入每一层第一次被访问的结点, 使用 &l;code&g;ve.size()&l;/code&g; 来判断层数&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;rightSideView&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        dfs(root,&l;span class=\&q;number\&q;&g;0&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ve;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;     &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; depth)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;         &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!T) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;         &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(depth==ve.size())&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;             ve.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;         ++depth;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;         dfs(T-&a;gt;right,depth);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;         dfs(T-&a;gt;left,depth);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;     &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;不过速度好像更慢了&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520161245.png#align=left&a;amp;display=inline&a;amp;height=311&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=311&a;amp;originWidth=636&a;amp;status=done&a;amp;style=none&a;amp;width=636\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;*把二叉搜索树转换为累加树\&q;&g;*把二叉搜索树转换为累加树&l;a title=\&q;#*把二叉搜索树转换为累加树\&q; href=\&q;#*把二叉搜索树转换为累加树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/convert-bst-to-greater-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;二叉搜索树的特点:&l;/p&g;\n&l;ol&g;\n&l;li&g;左子树所有结点小于根结点&l;/li&g;\n&l;li&g;右子树所有节点大于根结点&l;/li&g;\n&l;/ol&g;\n&l;p&g;&l;strong&g;根据这个特点, 我们可以得出:&l;/strong&g; 对于一个结点, 他的值变为 = 原来的结点值 + 他右子树的所有结点的值 + 他所有祖先节点与组先结点的右子树的所有结点的值&l;/p&g;\n&l;p&g;&l;strong&g;对于这道题:&l;/strong&g; 我们中序递归遍历: 右子树-&a;gt;根结点-&a;gt;左子树, 每个结点值变为 左子树结点和+本身&l;/p&g;\n&l;p&g;算了写不出来, 脑子不够用, 看看别人的正确代码&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;int&l;/span&g; num=&l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;convertBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        convertBST(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;val+=num;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        num=root-&a;gt;val;&l;span class=\&q;comment\&q;&g;//记录这一次的和&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        convertBST(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;strong&g;我的思维误区&l;/strong&g; 第一: 误以为需要递归函数返回右子树的和, 其实使用一个全局变量就可以了 第二: 每个结点只需要遍历一次就够了&l;/p&g;\n&l;h1 id=\&q;*二叉树的直径\&q;&g;*二叉树的直径&l;a title=\&q;#*二叉树的直径\&q; href=\&q;#*二叉树的直径\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/diameter-of-binary-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/diameter-of-binary-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;一道标注简单的题做起来不简单&l;/p&g;\n&l;h1 id=\&q;*左子叶之和\&q;&g;*左子叶之和&l;a title=\&q;#*左子叶之和\&q; href=\&q;#*左子叶之和\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/sum-of-left-leaves/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/sum-of-left-leaves/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;西巴, 不会, 虽然说看起来挺简单的&l;/p&g;\n&l;p&g;首先, 不可以使用普通的前序遍历, 因为它无法分辨遍历到的结点是不是右结点&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;sumOfLeftLeaves&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)  &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; temp=&l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;left!=&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;root-&a;gt;left-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;root-&a;gt;left-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;             temp=root-&a;gt;left-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; temp+sumOfLeftLeaves(root-&a;gt;left)+sumOfLeftLeaves(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;叶子相似的树\&q;&g;叶子相似的树&l;a title=\&q;#叶子相似的树\&q; href=\&q;#叶子相似的树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/leaf-similar-trees/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/leaf-similar-trees/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;**我的思路: ** 应该是最简单的思路了, 前序遍历两棵树, 判断结点是不是叶节点, 使用 vector 存储, 最后比较两个 vector 是否相同&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; v1,v2;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;leafSimilar&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root1, TreeNode* root2)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root1,&l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(root2,&l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(v1.size()!=v2.size())&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=v1.size();i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(v1[i]!=v2[i])&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; flag;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;rec&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; tag)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;T-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;tag==&l;span class=\&q;number\&q;&g;1&l;/span&g;)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            v1.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g; &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;T-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;tag==&l;span class=\&q;number\&q;&g;2&l;/span&g;)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            v2.push_back(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;left,tag);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        rec(T-&a;gt;right,tag);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;优化方法, 使用 &l;code&g;string&l;/code&g; 来存储遍历到的叶节点值, 最后使用 &l;code&g;.equal()&l;/code&g; 就可以了, 不过记得在结点值中间增加分隔符&l;/p&g;\n&l;h1 id=\&q;二叉树的堂兄弟节点\&q;&g;二叉树的堂兄弟节点&l;a title=\&q;#二叉树的堂兄弟节点\&q; href=\&q;#二叉树的堂兄弟节点\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/cousins-in-binary-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/cousins-in-binary-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;堂兄弟的条件:&l;/strong&g; 不同父结点, 相同的深度&l;/p&g;\n&l;p&g;看了看别人的解法, 没有啥惊艳的解法&l;/p&g;\n&l;p&g;**我的思路: ** &l;s&g;使用层序遍历, 遍历到一个结点就将它&l;/s&g; &l;strong&g;不做了&l;/strong&g;&l;/p&g;\n&l;h1 id=\&q;验证二叉搜索树\&q;&g;验证二叉搜索树&l;a title=\&q;#验证二叉搜索树\&q; href=\&q;#验证二叉搜索树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/validate-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/validate-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;判断一颗二叉树是不是二叉搜索树.&l;/p&g;\n&l;p&g;二叉搜索树的特点:&l;/p&g;\n&l;ol&g;\n&l;li&g;左子树所有结点值小于根结点&l;/li&g;\n&l;li&g;右子树所有结点值大于根结点&l;/li&g;\n&l;li&g;中序遍历得到的序列递增&l;/li&g;\n&l;/ol&g;\n&l;p&g;&l;strong&g;我的错误思路:&l;/strong&g; 中序递归遍历, 对于一个结点, 判断他的左结点是否比他小,右节点的值是否比他大&l;/p&g;\n&l;p&g;&l;strong&g;错误原因:&l;/strong&g; 在这种情况下, 按照我的思路无法判断&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521120921.png#align=left&a;amp;display=inline&a;amp;height=282&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=282&a;amp;originWidth=379&a;amp;status=done&a;amp;style=none&a;amp;width=379\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;大佬的思路:&l;/strong&g; 中序遍历为升序&l;/p&g;\n&l;p&g;&l;strong&g;经过改进:&l;/strong&g;&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;isValidBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;long&l;/span&g; prev= LONG_MIN;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; st;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* T=root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(T||!st.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                st.push(T);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=T-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T = st.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                st.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;val&a;lt;=prev)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                prev=T-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                T=T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;填充每个节点的下一个右侧节点指针\&q;&g;填充每个节点的下一个右侧节点指针&l;a title=\&q;#填充每个节点的下一个右侧节点指针\&q; href=\&q;#填充每个节点的下一个右侧节点指针\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;我的起初思路:&l;/strong&g; 想使用层序遍历, 但是层序遍历需要使用额外的队列空间, 大小由最后一层的结点树数量决定.&l;/p&g;\n&l;p&g;&l;strong&g;观察给出的样例:&l;/strong&g;&l;/p&g;\n&l;ol&g;\n&l;li&g;左子树结点 next 指向他的兄弟结点(父结的右儿子)&l;/li&g;\n&l;li&g;右子树结点 next 指向父结点的 next 的左儿子, 特别的, 如果父结点的 next 是 NULL 的话, 直接指向 NULL&l;/li&g;\n&l;/ol&g;\n&l;p&g;**我的实现方法: ** 中序递归遍历, 先对于每一个结点:&l;/p&g;\n&l;ol&g;\n&l;li&g;该结点不是叶节点, 把他的左儿子 next 指向他的右儿子, 把他的右儿子 next 指向他的 next&l;/li&g;\n&l;li&g;该节点是叶节点就什么什么都不做&l;/li&g;\n&l;/ol&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;Node* &l;span class=\&q;title\&q;&g;connect&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(Node* T)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;    &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||(T-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;T-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;left-&a;gt;next=T-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        T-&a;gt;right-&a;gt;next= T-&a;gt;next==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;? &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;:T-&a;gt;next-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;卧槽, 一次过, 有点激动&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521141703.png#align=left&a;amp;display=inline&a;amp;height=256&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=256&a;amp;originWidth=630&a;amp;status=done&a;amp;style=none&a;amp;width=630\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;优化方法, 这里可以不用 &l;code&g;helper&l;/code&g; 函数, 一个函数内&l;code&g;return root&l;/code&g;&l;/p&g;\n&l;h1 id=\&q;*二叉搜索树迭代器\&q;&g;*二叉搜索树迭代器&l;a title=\&q;#*二叉搜索树迭代器\&q; href=\&q;#*二叉搜索树迭代器\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;**我的思路: ** 因为是二叉搜索树, 所以中序遍历序列是递增序列. 因为每一次使用 next ,数就减少一个, 很容易联想到栈或队列. 因此我们使用队列来保存中序遍历序列&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;BSTIterator&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; st;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    BSTIterator(TreeNode* root) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* T)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        st.push(T-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;/** @return the next smallest number */&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;next&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; x=st.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        st.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; x;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;/** @return whether we have a next smallest number */&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;hasNext&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; !st.empty();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;效果很差&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521144009.png#align=left&a;amp;display=inline&a;amp;height=312&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=312&a;amp;originWidth=640&a;amp;status=done&a;amp;style=none&a;amp;width=640\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;p&g;&l;strong&g;更好的方法:&l;/strong&g;&l;/p&g;\n&l;p&g;模拟递归的过程&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;BSTIterator&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; stk;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    BSTIterator(TreeNode* root) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(root)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            stk.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root=root-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;/** @return the next smallest number */&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;next&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode *p =stk.top();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; res= p-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stk.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        p =p-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(p)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            stk.push(p);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            p=p-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;/** @return whether we have a next smallest number */&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;hasNext&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; !stk.empty();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*树的子结构\&q;&g;*树的子结构&l;a title=\&q;#*树的子结构\&q; href=\&q;#*树的子结构\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;&l;strong&g;我的思路:&l;/strong&g; 先序遍历 A 树, 判断该结点的值是否与 B 的根结点相同&l;/p&g;\n&l;ol&g;\n&l;li&g;相同: 记下这个结点的位置, 两棵树同时向下比较, , 当 B 树被遍历完了, 就 return true, 否者回到原来被记下的位置, 继续先序遍历&l;/li&g;\n&l;li&g;不同, A 向下遍历&l;/li&g;\n&l;/ol&g;\n&l;p&g;算了写不下去了, 错误代码如下&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;32&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;33&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;34&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;35&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;36&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;37&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;isSubStructure&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* A, TreeNode* B)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(A,B);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; flag;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* A,TreeNode* B)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(A==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)  &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(A-&a;gt;val==B-&a;gt;val)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;bool&l;/span&g; flag=&l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            TreeNode* pa=A;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            TreeNode* pb=B;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;built_in\&q;&g;stack&l;/span&g;&a;lt;TreeNode*&a;gt; sa,sb;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;while&l;/span&g;((pa||!sa.empty())&a;amp;&a;amp;(pb||!sb.empty()))&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(pa&a;amp;&a;amp;pb)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    sa.push(pa);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    sb.push(pb);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(pa-&a;gt;val!=pb-&a;gt;val)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                        flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pa=pa-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pb=pb-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pa=sa.top(); sa.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pb=sb.top(); sb.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pa=pa-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    pb=pb-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(pb!=&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) flag=&l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(flag==&l;span class=\&q;literal\&q;&g;true&l;/span&g;) &l;span class=\&q;keyword\&q;&g;this&l;/span&g;-&a;gt;flag=&l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(A-&a;gt;left,B);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        helper(A-&a;gt;right,B);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;看看别人的代码&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;isSubStructure&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* A, TreeNode* B)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; (A != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g; &a;amp;&a;amp; B != &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &a;amp;&a;amp; (recur(A, B) || isSubStructure(A-&a;gt;left, B) || isSubStructure(A-&a;gt;right, B));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;recur&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* A, TreeNode* B)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(B == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(A == &l;span class=\&q;literal\&q;&g;NULL&l;/span&g; || A-&a;gt;val != B-&a;gt;val) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; recur(A-&a;gt;left, B-&a;gt;left) &a;amp;&a;amp; recur(A-&a;gt;right, B-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;卧槽, 简直了, 优美简短&l;/p&g;\n&l;p&g;&l;strong&g;别人的思路:&l;/strong&g;&l;/p&g;\n&l;h1 id=\&q;二叉树的最小深度\&q;&g;二叉树的最小深度&l;a title=\&q;#二叉树的最小深度\&q; href=\&q;#二叉树的最小深度\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;minDepth&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; m=minDepth(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; n=minDepth(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;comment\&q;&g;//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;comment\&q;&g;//2.如果都不为空，返回较小深度+1&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||root-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;? (m+n+&l;span class=\&q;number\&q;&g;1&l;/span&g;):(m&a;gt;n?n:m)+&l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;斐波那契数列\&q;&g;斐波那契数列&l;a title=\&q;#斐波那契数列\&q; href=\&q;#斐波那契数列\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/fibonacci-number/description/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/fibonacci-number/description/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;虽然我知道直接递归不太好, 但是我实在是真看不出这道题和树有什么联系&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;fib&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; N)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(N==&l;span class=\&q;number\&q;&g;0&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(N==&l;span class=\&q;number\&q;&g;1&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; fib(N&l;span class=\&q;number\&q;&g;-1&l;/span&g;)+fib(N&l;span class=\&q;number\&q;&g;-2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;最大二叉树\&q;&g;最大二叉树&l;a title=\&q;#最大二叉树\&q; href=\&q;#最大二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/maximum-binary-tree/description/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/maximum-binary-tree/description/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;一看就是递归, 我又不会…&l;/p&g;\n&l;p&g;写了一段半残的代码, 思路比较普通, 也比较好理解, 就是边界控制始终不到位&l;/p&g;\n&l;p&g;还是去看大佬的代码去了&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;//垃圾代码&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;constructMaximumBinaryTree&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; nums)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; max=findMax(nums,&l;span class=\&q;number\&q;&g;0&l;/span&g;,nums.size());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; helper(nums,&l;span class=\&q;number\&q;&g;0&l;/span&g;,max,nums.size());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;findMax&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &a;amp;nums,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; left,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; right)&l;/span&g;   &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; max=INT_MIN,res=&l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=left;i&a;lt;right;i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(nums[i]&a;gt;=max)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                max=nums[i];&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                res=i;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt; &a;amp;nums,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; left,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; max,&l;span class=\&q;keyword\&q;&g;int&l;/span&g; right)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(left&a;gt;right) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* root=&l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(nums[max]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; left_max=findMax(nums,left,max&l;span class=\&q;number\&q;&g;-1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; right_max=findMax(nums,max+&l;span class=\&q;number\&q;&g;1&l;/span&g;,right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;left=helper(nums,left,left_max,max&l;span class=\&q;number\&q;&g;-1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;right=helper(nums,max+&l;span class=\&q;number\&q;&g;1&l;/span&g;,right_max,right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;别人的好代码&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;constructMaximumBinaryTree&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;&a;amp; nums)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; construct(nums.begin(), nums.end());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;private&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode * &l;span class=\&q;title\&q;&g;construct&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;::iterator l, &l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;keyword\&q;&g;int&l;/span&g;&a;gt;::iterator r)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (l == r) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;auto&l;/span&g; it = max_element(l, r);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode *tn = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(*it);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        tn-&a;gt;left  = construct(l, it);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        tn-&a;gt;right = construct(it + &l;span class=\&q;number\&q;&g;1&l;/span&g;, r);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; tn;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;**总结一下: ** 使用 &l;code&g;vector&l;/code&g; 迭代器, 比较好&l;/p&g;\n&l;ol&g;\n&l;li&g;递归结束的条件是左迭代器与右迭代器重合&l;/li&g;\n&l;li&g;使用 &l;code&g;STL max_element()&l;/code&g; , 让代码看起来比较简洁, 还需要积累库算法的使用经验&l;/li&g;\n&l;li&g;注意左右分递归时的细节. 左边递归的右边界是 &l;code&g;it&l;/code&g;. 右边递归的左边界是 &l;code&g;it+1&l;/code&g; ,右边界是 r&l;/li&g;\n&l;/ol&g;\n&l;h1 id=\&q;合并二叉树\&q;&g;合并二叉树&l;a title=\&q;#合并二叉树\&q; href=\&q;#合并二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/merge-two-binary-trees/description/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/merge-two-binary-trees/description/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;好的, 我又看出来了, 这是一道递归的题目, 可是卵用&l;/p&g;\n&l;p&g;冷静分析, 有要接一颗树的情形, 因此递归得返回正在处理的二叉树, 方便对接&l;/p&g;\n&l;p&g;如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;mergeTrees&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* t1, TreeNode* t2)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!t1) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; t2;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(!t2 ) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; t1;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        t1-&a;gt;val+=t2-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        t1-&a;gt;left=mergeTrees(t1-&a;gt;left,t2-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        t1-&a;gt;right=mergeTrees(t1-&a;gt;right,t2-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; t1;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;思路是挺清晰, 就是内存消耗有点大&l;/p&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200526000011.png#align=left&a;amp;display=inline&a;amp;height=319&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=319&a;amp;originWidth=736&a;amp;status=done&a;amp;style=none&a;amp;width=736\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;*对称二叉树\&q;&g;*对称二叉树&l;a title=\&q;#*对称二叉树\&q; href=\&q;#*对称二叉树\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/symmetric-tree/description/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/symmetric-tree/description/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;反正就是遍历的问题, 算了不会&l;/p&g;\n&l;p&g;理一下思路: 如何判断一颗树是否是对称二叉搜索树?&l;/p&g;\n&l;p&g;如果根节点是&l;code&g;NULL&l;/code&g;,  &l;code&g;true&l;/code&g;&l;br&g;\n如果根结点不是&l;code&g;NULL&l;/code&g;, 判断 左子树的左儿子和右子树的右儿子 &a;amp;&a;amp; 左子树的右儿子和右子树的左儿子&l;/p&g;\n&l;p&g;左子树的左儿子和右子树的右儿子(左子树的右儿子和右子树的左儿子)&l;/p&g;\n&l;ol&g;\n&l;li&g;&l;strong&g;都为空&l;/strong&g; &l;code&g;return true&l;/code&g;&l;/li&g;\n&l;li&g;&l;strong&g;有一个是 &l;code&g;NULL&l;/code&g;&l;/strong&g; , 有一个不是 &l;code&g;NULL&l;/code&g;&l;/li&g;\n&l;li&g;&l;strong&g;都不为空&l;/strong&g;, 判断他们的值是否相同, 并且继续向下递归判断&l;/li&g;\n&l;/ol&g;\n&l;p&g;这样递归关系就清晰可见了&l;/p&g;\n&l;p&g;代码如下&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;isSymmetric&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g; ) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g;  helper(root-&a;gt;left,root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;bool&l;/span&g; &l;span class=\&q;title\&q;&g;helper&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* l,TreeNode* r)&l;/span&g;&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(l==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;r==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(l==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||r==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; r-&a;gt;val==l-&a;gt;val   &a;amp;&a;amp; helper(l-&a;gt;left,r-&a;gt;right)&a;amp;&a;amp;helper(l-&a;gt;right,r-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;代码优化&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;boolean&l;/span&g; &l;span class=\&q;title\&q;&g;isSymmetric&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;return&l;/span&g; isMirror(root, root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;boolean&l;/span&g; &l;span class=\&q;title\&q;&g;isMirror&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode t1, TreeNode t2)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (t1 == &l;span class=\&q;keyword\&q;&g;null&l;/span&g; &a;amp;&a;amp; t2 == &l;span class=\&q;keyword\&q;&g;null&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;keyword\&q;&g;true&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (t1 == &l;span class=\&q;keyword\&q;&g;null&l;/span&g; || t2 == &l;span class=\&q;keyword\&q;&g;null&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;keyword\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;return&l;/span&g; (t1.val == t2.val)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;amp;&a;amp; isMirror(t1.right, t2.left)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;amp;&a;amp; isMirror(t1.left, t2.right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*路径总和- ⅲ\&q;&g;*路径总和  Ⅲ&l;a title=\&q;#*路径总和- ⅲ\&q; href=\&q;#*路径总和- ⅲ\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/path-sum-iii/description/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/path-sum-iii/description/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;难度不小, 有点东西&l;/p&g;\n&l;p&g;&l;s&g;思路一: 使用 vector 存储遍历到的路径的值的和, 最后数容器中有几个 sum&l;/s&g;&l;/p&g;\n&l;p&g;算了不会, 别折腾自己, 看答案了&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;pathSum&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (&l;span class=\&q;literal\&q;&g;nullptr&l;/span&g; == root)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; dfs(root, sum) + pathSum(root-&a;gt;left, sum) + pathSum(root-&a;gt;right, sum);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;private&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;dfs&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; sum)&l;/span&g;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;function\&q;&g;    &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (&l;span class=\&q;literal\&q;&g;nullptr&l;/span&g; == root)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        sum -= root-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; (&l;span class=\&q;number\&q;&g;0&l;/span&g; == sum ? &l;span class=\&q;number\&q;&g;1&l;/span&g; : &l;span class=\&q;number\&q;&g;0&l;/span&g;) + dfs(root-&a;gt;left, sum) + dfs(root-&a;gt;right, sum);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;/*这条路径和是否是sum, 继续递归左边和右边*/&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;解释: &l;code&g;pathSum&l;/code&g; 前序遍历递归每一个结点. &l;code&g;dfs&l;/code&g; 对于每一   个结点递归遍历他的左右子树.&l;br&g;\n对于一个结点我们怎么判断他有几条向下的路径和为 sum 呢? 前序遍历, 向下递归&l;/p&g;\n&l;h1 id=\&q;二叉搜索树中的搜索\&q;&g;二叉搜索树中的搜索&l;a title=\&q;#二叉搜索树中的搜索\&q; href=\&q;#二叉搜索树中的搜索\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/search-in-a-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;我的最初递归方法,不知道还没有更好的方法&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;searchBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; val)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;val==val)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* l=searchBST(root-&a;gt;left,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* r=searchBST(root-&a;gt;right,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; l==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;?r:l;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;适当优化&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;searchBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; val)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||root-&a;gt;val==val) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* l=searchBST(root-&a;gt;left,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* r=searchBST(root-&a;gt;right,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; l==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;?r:l;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;当然我们也可以使用层序遍历或者非递归遍历来实现.&l;/p&g;\n&l;p&g;观察了一会儿, 恍然大悟, 这是一颗二叉搜索树, 我们可以利用它的性质来优化代码. 但是提交结果显示效率还是不高&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;searchBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; val)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;||root-&a;gt;val==val) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode* res=&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;val&a;gt;val)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            res=searchBST(root-&a;gt;left,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            res=searchBST(root-&a;gt;right,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200530114156.png#align=left&a;amp;display=inline&a;amp;height=301&a;amp;margin=%5Bobject%20Object%5D&a;amp;originHeight=301&a;amp;originWidth=675&a;amp;status=done&a;amp;style=none&a;amp;width=675\&q; alt=\&q;\&q; class=\&q;φcx\&q;&g;&l;/p&g;\n&l;h1 id=\&q;二叉搜索树中的插入操作\&q;&g;二叉搜索树中的插入操作&l;a title=\&q;#二叉搜索树中的插入操作\&q; href=\&q;#二叉搜索树中的插入操作\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;Awesome! 一次过&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;TreeNode* &l;span class=\&q;title\&q;&g;insertIntoBST&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root, &l;span class=\&q;keyword\&q;&g;int&l;/span&g; val)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g; )&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; TreeNode(val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;val&a;gt;val)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root-&a;gt;left=insertIntoBST(root-&a;gt;left,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;else&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            root-&a;gt;right=insertIntoBST(root-&a;gt;right,val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*二叉树展开为链表\&q;&g;*二叉树展开为链表&l;a title=\&q;#*二叉树展开为链表\&q; href=\&q;#*二叉树展开为链表\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;题干的关键是原地展开, 不能新建一颗二叉树.&l;/p&g;\n&l;p&g;递龟问题, 我们根结点的左子树被插入到根结点与右子树中间&l;/p&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-ming-zhi-/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;别人的思路&l;/a&g;对于一个递归函数, 我们不用管函数内部是怎样实现的, 我只看函数的作用以及输入输出.&l;/p&g;\n&l;p&g;对于&l;code&g;flatten&l;/code&g; 来说&l;/p&g;\n&l;ol&g;\n&l;li&g;函数作用: 是将一个二叉树展开为链表&l;/li&g;\n&l;li&g;输入: 树的根结点&l;/li&g;\n&l;li&g;输出: 无&l;/li&g;\n&l;/ol&g;\n&l;p&g;我的思维误区: 其实叶节点也可以当作是一颗左子树和右子树都是 &l;code&g;NULL&l;/code&g; 的树&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;/*&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;我们每次把原来的右子树接到现在右子树的末尾都使用了一个 `while` 循环来找到现在右子树最右边的结点&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;comment\&q;&g;*/&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;flatten&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g; ;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        flatten(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        flatten(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeNode*temp=root-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;right = root-&a;gt;left;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;left=&l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(root-&a;gt;right!=&l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;)root=root-&a;gt;right;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;right=temp;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;另外一种思路: 向右边的后序遍历, 逆向思维, 难懂&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    TreeNode* last = &l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title\&q;&g;flatten&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g; (root == &l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;) &l;span class=\&q;keyword\&q;&g;return&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        flatten(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        flatten(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;right = last;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        root-&a;gt;left = &l;span class=\&q;literal\&q;&g;nullptr&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        last = root;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;*二叉树的所有路径\&q;&g;*二叉树的所有路径&l;a title=\&q;#*二叉树的所有路径\&q; href=\&q;#*二叉树的所有路径\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/binary-tree-paths/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/binary-tree-paths/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;很久没做题了, 手感生疏了, 简单题也头痛了. 虽然说之前也不怎么会 🤣&l;/p&g;\n&l;p&g;来看看这道题. 不会&l;/p&g;\n&l;p&g;对于一个结点, 分情况&l;/p&g;\n&l;ol&g;\n&l;li&g;他的左儿子或右儿子有一个不为空, 到他的 path += “val-&a;gt;”&l;/li&g;\n&l;li&g;他是叶节点, path+= “val”, 将到他的 path push 到容器&l;/li&g;\n&l;/ol&g;\n&l;p&g;递龟结束的条件是碰到 NULL 了&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;built_in\&q;&g;string&l;/span&g; path;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;string&l;/span&g;&a;gt; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;built_in\&q;&g;vector&l;/span&g;&a;lt;&l;span class=\&q;built_in\&q;&g;string&l;/span&g;&a;gt; &l;span class=\&q;title\&q;&g;binaryTreePaths&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&l;span class=\&q;keyword\&q;&g;return&l;/span&g; &a;#123;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(root-&a;gt;left==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;&a;amp;&a;amp;root-&a;gt;right==&l;span class=\&q;literal\&q;&g;NULL&l;/span&g;)&a;#123;&l;span class=\&q;comment\&q;&g;//叶节点&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            path+=to_string(root-&a;gt;val);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            res.push_back(path);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;span class=\&q;keyword\&q;&g;else&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            path+=to_string(root-&a;gt;val)+&l;span class=\&q;string\&q;&g;&a;quot;-&a;gt;&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;built_in\&q;&g;string&l;/span&g; temp=path;&l;span class=\&q;comment\&q;&g;//使用一个temp来保存到即将进入左边递龟的结点的路径&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            binaryTreePaths(root-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            path=temp;&l;span class=\&q;comment\&q;&g;//将路径恢复为进入左边递龟之前的路径&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            binaryTreePaths(root-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h1 id=\&q;找树左下角的值\&q;&g;找树左下角的值&l;a title=\&q;#找树左下角的值\&q; href=\&q;#找树左下角的值\&q;&g;&l;/a&g;&l;/h1&g;\n&l;blockquote&g;\n&l;p&g;&l;a href=\&q;https://leetcode-cn.com/problems/find-bottom-left-tree-value/\&q; target=\&q;_blank\&q; rel=\&q;external nofollow noopener\&q;&g;https://leetcode-cn.com/problems/find-bottom-left-tree-value/&l;/a&g;&l;/p&g;\n&l;/blockquote&g;\n&l;p&g;又是层序遍历, 仔细想一下很简单&l;/p&g;\n&l;figure class=\&q;highlight c\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;class\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title\&q;&g;Solution&l;/span&g; &a;#123;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g;:&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;function\&q;&g;&l;span class=\&q;keyword\&q;&g;int&l;/span&g; &l;span class=\&q;title\&q;&g;findBottomLeftValue&l;/span&g;&l;span class=\&q;params\&q;&g;(TreeNode* root)&l;/span&g; &l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;queue&l;/span&g;&a;lt;TreeNode*&a;gt; qu;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;int&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        qu.push(root);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(!qu.empty())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;int&l;/span&g; size=qu.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(&l;span class=\&q;keyword\&q;&g;int&l;/span&g; i=&l;span class=\&q;number\&q;&g;0&l;/span&g;;i!=size;i++)&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;auto&l;/span&g; T=qu.front();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                qu.pop();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(i==&l;span class=\&q;number\&q;&g;0&l;/span&g;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                res=T-&a;gt;val;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;left)qu.push(T-&a;gt;left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(T-&a;gt;right)qu.push(T-&a;gt;right);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; res;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;&l;div&g;&l;h1 id=\&q;推荐文章\&q;&g;推荐文章&l;a title=\&q;#推荐文章\&q; href=\&q;%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0\&q;&g;&l;/a&g;&l;/h1&g;&l;ul&g;&l;li&g;&l;a href=\&q;https://mvbbb.github.io/iixrxk/\&q;&g;排序算法&l;/a&g;&l;/li&g;&l;li&g;&l;a href=\&q;https://mvbbb.github.io/gggq6t/\&q;&g;Leetbook 初级算法&l;/a&g;&l;/li&g;&l;li&g;&l;a href=\&q;http://www.b5mang.com/hasSubtree.html\&q;&g;二叉树系列-二叉树子结构&l;/a&g;&l;/li&g;&l;/ul&g;&l;/div&g;&q;,&q;prev&q;:{&q;title&q;:&q;排序算法&q;,&q;link&q;:&q;iixrxk&q;},&q;next&q;:{&q;title&q;:&q;Leetbook 初级算法&q;,&q;link&q;:&q;gggq6t&q;},&q;plink&q;:&q;https://mvbbb.github.io/zhme42/&q;,&q;toc&q;:[{&q;id&q;:&q;遍历树叶&q;,&q;title&q;:&q;遍历树叶&q;,&q;index&q;:&q;1&q;,&q;children&q;:[{&q;id&q;:&q;题目描述&q;,&q;title&q;:&q;题目描述&q;,&q;index&q;:&q;1.1&q;},{&q;id&q;:&q;思路&q;,&q;title&q;:&q;思路&q;,&q;index&q;:&q;1.2&q;}]},{&q;id&q;:&q;先序遍历顺序建立二叉树链表&q;,&q;title&q;:&q;先序遍历顺序建立二叉树链表&q;,&q;index&q;:&q;2&q;},{&q;id&q;:&q;复制二叉树&q;,&q;title&q;:&q;复制二叉树&q;,&q;index&q;:&q;3&q;},{&q;id&q;:&q;计算二叉树的深度&q;,&q;title&q;:&q;计算二叉树的深度&q;,&q;index&q;:&q;4&q;},{&q;id&q;:&q;统计二叉树中结点的个数&q;,&q;title&q;:&q;统计二叉树中结点的个数&q;,&q;index&q;:&q;5&q;},{&q;id&q;:&q;二叉树的可视化&q;,&q;title&q;:&q;二叉树的可视化&q;,&q;index&q;:&q;6&q;},{&q;id&q;:&q;二叉树的后序遍历&q;,&q;title&q;:&q;二叉树的后序遍历&q;,&q;index&q;:&q;7&q;},{&q;id&q;:&q;二叉树的最大深度&q;,&q;title&q;:&q;二叉树的最大深度&q;,&q;index&q;:&q;8&q;},{&q;id&q;:&q;翻转二叉树&q;,&q;title&q;:&q;翻转二叉树&q;,&q;index&q;:&q;9&q;},{&q;id&q;:&q;二叉树的层序遍历&q;,&q;title&q;:&q;二叉树的层序遍历&q;,&q;index&q;:&q;10&q;},{&q;id&q;:&q;二叉搜索树的范围和&q;,&q;title&q;:&q;二叉搜索树的范围和&q;,&q;index&q;:&q;11&q;},{&q;id&q;:&q;n-叉树的后序遍历&q;,&q;title&q;:&q;N 叉树的后序遍历&q;,&q;index&q;:&q;12&q;},{&q;id&q;:&q;n-叉树的前序遍历&q;,&q;title&q;:&q;N 叉树的前序遍历&q;,&q;index&q;:&q;13&q;},{&q;id&q;:&q;将有序数组转换为二叉搜索树&q;,&q;title&q;:&q;将有序数组转换为二叉搜索树&q;,&q;index&q;:&q;14&q;},{&q;id&q;:&q;*特定深度节点链表&q;,&q;title&q;:&q;*特定深度节点链表&q;,&q;index&q;:&q;15&q;},{&q;id&q;:&q;二叉树的中序遍历&q;,&q;title&q;:&q;二叉树的中序遍历&q;,&q;index&q;:&q;16&q;},{&q;id&q;:&q;祖父节点值为偶数的节点和&q;,&q;title&q;:&q;祖父节点值为偶数的节点和&q;,&q;index&q;:&q;17&q;},{&q;id&q;:&q;根据前序和后序遍历构造二叉树&q;,&q;title&q;:&q;根据前序和后序遍历构造二叉树&q;,&q;index&q;:&q;18&q;},{&q;id&q;:&q;二叉搜索树中的众数&q;,&q;title&q;:&q;二叉搜索树中的众数&q;,&q;index&q;:&q;19&q;},{&q;id&q;:&q;*恢复二叉搜索树&q;,&q;title&q;:&q;*恢复二叉搜索树&q;,&q;index&q;:&q;20&q;},{&q;id&q;:&q;路径总和&q;,&q;title&q;:&q;路径总和&q;,&q;index&q;:&q;21&q;},{&q;id&q;:&q;*二叉树的最近公共祖先&q;,&q;title&q;:&q;*二叉树的最近公共祖先&q;,&q;index&q;:&q;22&q;},{&q;id&q;:&q;*出现次数最多的子树元素和&q;,&q;title&q;:&q;*出现次数最多的子树元素和&q;,&q;index&q;:&q;23&q;},{&q;id&q;:&q;二叉搜索树的第-k-大节点&q;,&q;title&q;:&q;二叉搜索树的第 k 大节点&q;,&q;index&q;:&q;24&q;},{&q;id&q;:&q;从上到下打印二叉树-ii&q;,&q;title&q;:&q;从上到下打印二叉树 II&q;,&q;index&q;:&q;25&q;},{&q;id&q;:&q;平衡二叉树&q;,&q;title&q;:&q;平衡二叉树&q;,&q;index&q;:&q;26&q;},{&q;id&q;:&q;从上到下打印二叉树&q;,&q;title&q;:&q;从上到下打印二叉树&q;,&q;index&q;:&q;27&q;},{&q;id&q;:&q;*前序和中序序列构造二叉树&q;,&q;title&q;:&q;*前序和中序序列构造二叉树&q;,&q;index&q;:&q;28&q;},{&q;id&q;:&q;二叉树的右视图&q;,&q;title&q;:&q;二叉树的右视图&q;,&q;index&q;:&q;29&q;},{&q;id&q;:&q;*把二叉搜索树转换为累加树&q;,&q;title&q;:&q;*把二叉搜索树转换为累加树&q;,&q;index&q;:&q;30&q;},{&q;id&q;:&q;*二叉树的直径&q;,&q;title&q;:&q;*二叉树的直径&q;,&q;index&q;:&q;31&q;},{&q;id&q;:&q;*左子叶之和&q;,&q;title&q;:&q;*左子叶之和&q;,&q;index&q;:&q;32&q;},{&q;id&q;:&q;叶子相似的树&q;,&q;title&q;:&q;叶子相似的树&q;,&q;index&q;:&q;33&q;},{&q;id&q;:&q;二叉树的堂兄弟节点&q;,&q;title&q;:&q;二叉树的堂兄弟节点&q;,&q;index&q;:&q;34&q;},{&q;id&q;:&q;验证二叉搜索树&q;,&q;title&q;:&q;验证二叉搜索树&q;,&q;index&q;:&q;35&q;},{&q;id&q;:&q;填充每个节点的下一个右侧节点指针&q;,&q;title&q;:&q;填充每个节点的下一个右侧节点指针&q;,&q;index&q;:&q;36&q;},{&q;id&q;:&q;*二叉搜索树迭代器&q;,&q;title&q;:&q;*二叉搜索树迭代器&q;,&q;index&q;:&q;37&q;},{&q;id&q;:&q;*树的子结构&q;,&q;title&q;:&q;*树的子结构&q;,&q;index&q;:&q;38&q;},{&q;id&q;:&q;二叉树的最小深度&q;,&q;title&q;:&q;二叉树的最小深度&q;,&q;index&q;:&q;39&q;},{&q;id&q;:&q;斐波那契数列&q;,&q;title&q;:&q;斐波那契数列&q;,&q;index&q;:&q;40&q;},{&q;id&q;:&q;最大二叉树&q;,&q;title&q;:&q;最大二叉树&q;,&q;index&q;:&q;41&q;},{&q;id&q;:&q;合并二叉树&q;,&q;title&q;:&q;合并二叉树&q;,&q;index&q;:&q;42&q;},{&q;id&q;:&q;*对称二叉树&q;,&q;title&q;:&q;*对称二叉树&q;,&q;index&q;:&q;43&q;},{&q;id&q;:&q;*路径总和- ⅲ&q;,&q;title&q;:&q;*路径总和  Ⅲ&q;,&q;index&q;:&q;44&q;},{&q;id&q;:&q;二叉搜索树中的搜索&q;,&q;title&q;:&q;二叉搜索树中的搜索&q;,&q;index&q;:&q;45&q;},{&q;id&q;:&q;二叉搜索树中的插入操作&q;,&q;title&q;:&q;二叉搜索树中的插入操作&q;,&q;index&q;:&q;46&q;},{&q;id&q;:&q;*二叉树展开为链表&q;,&q;title&q;:&q;*二叉树展开为链表&q;,&q;index&q;:&q;47&q;},{&q;id&q;:&q;*二叉树的所有路径&q;,&q;title&q;:&q;*二叉树的所有路径&q;,&q;index&q;:&q;48&q;},{&q;id&q;:&q;找树左下角的值&q;,&q;title&q;:&q;找树左下角的值&q;,&q;index&q;:&q;49&q;},{&q;id&q;:&q;推荐文章&q;,&q;title&q;:&q;推荐文章&q;,&q;index&q;:&q;50&q;}],&q;copyright&q;:{&q;author&q;:&q;Mvbbb&q;,&q;link&q;:&q;&l;a href=\&q;https://mvbbb.github.io/zhme42/\&q; title=\&q;力扣-二叉树\&q;&g;https://mvbbb.github.io/zhme42/&l;/a&g;&q;,&q;license&q;:&q;Attribution-NonCommercial-NoDerivatives 4.0 International (&l;a href=\&q;https://creativecommons.org/licenses/by-nc-sa/4.0/\&q; rel=\&q;external nofollow noopener\&q; target=\&q;_blank\&q;&g;CC BY-NC-ND 4.0&l;/a&g;)&q;}}}</script></head><body lang="en"><div style="display:none"><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1279526637&amp;web_id=1279526637"></script></div>
<!-- hexo injector head_end start --><link href="//fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat" rel="stylesheet"><link href="/styles.43478ea7e28ed563c48b.css" rel="stylesheet">
<script src="/config.f667b9e14173c512056d.js"></script>

<link rel="stylesheet" href="/theme.6191587147d30da44d8f.css" is="theme">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0">
<!-- hexo injector body_begin start --><is-a class="φbm φk" ng-version="10.0.11"><is-l class="φeb φh"><div class="φel"><section class="φem"><header class="φec φf"><!----><is-c class="φed"><img draggable="false" class="φbw φw" src="images/avatar.jpg" alt="" title="" width="160" height="160"></is-c><!----><a href="" class="φef φa φu">Mvbbb</a><p class="φee">Who i am,who u are</p></header><div class="φeq φf"><a routerlink="/archives" class="φer φu" href="/archives"><span class="φd">45</span><span>Archives</span></a><a class="φer φu" href="/categories/Java"><span class="φd">14</span><span>Categories</span></a><!----><a routerlink="/tags" class="φer φu" href="/tags"><span class="φd">34</span><span>Tags</span></a><!----></div><!----><nav class="φen"><a class="φeo φbd φj φc φu φo" href="/">Home</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/about">About</a><!----><!----><!----><a class="φeo φbd φj φc φu φo" href="/search">Search</a><!----><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φeo φbd φj φc φu φo" href="https://www.yuque.com/u1296515/zb4bwb">Yuque</a><!----><!----><!----></nav><!----><!----></section><footer class="φeg φeh"><div class="φej"><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-email" href="mailto:3212618781@qq.com">email</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-feed" href="https://mvbbb.github.io/rss2.xml">feed</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-github" href="https://github.com/Mvbbb">github</a><a target="_blank" rel="external nofollow noopener" class="φek φbg φu icon-myspace" href="/links">myspace</a><!----></div><!----><p class="φbk φz">© 2019-2021 ❤ <a href="https://github.com/Mvbbb">Mvbbb</a></p><!----><!----><!----></footer></div></is-l><div class="φbo"><div class="φbn"><div class="φbs φbe"><main class="φbr φbf"><router-outlet></router-outlet><is-s class="φfx φf"><header class="φgh φgi" style="background-image:;background-color:;"><div class="φgq"><h1 class="φgt">力扣-二叉树</h1><!----><p class="φgj φr"><span class="φgk φgo">Aug 4, 2020</span><a class="φgk φgm φu" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a><!----><!----><!----></p><!----><!----></div></header><article itemscope="" itemtype="http://schema.org/Article" class="φga" data-title="力扣-二叉树"><div itemprop="articleBody" issnippet="" iszoomable="" class="φbk φh φz"><h1 id="遍历树叶">遍历树叶<a title="#遍历树叶" href="#遍历树叶"></a></h1>
<h2 id="题目描述">题目描述<a title="#题目描述" href="#题目描述"></a></h2>
<blockquote>
<p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624" target="_blank" rel="external nofollow noopener">https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373045018624</a></p>
</blockquote>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200511224727.png#align=left&amp;display=inline&amp;height=867&amp;margin=%5Bobject%20Object%5D&amp;originHeight=867&amp;originWidth=1283&amp;status=done&amp;style=none&amp;width=1283" alt="" class="φcx"></p>
<h2 id="思路">思路<a title="#思路" href="#思路"></a></h2>
<ol>
<li>题目要求从上到下, 从左往右, 普通的前中后序遍历是不可以的, 只可以层序遍历</li>
<li>使用 <code>queue</code> 实现层序遍历</li>
<li>利用数组来保存结点信息 [静态链表]</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTra</span><span class="params">(node tree[], <span class="keyword">int</span> root_index)</span> </span>{</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    myqueue.push(root_index);</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty()) {</span><br><span class="line">        <span class="keyword">int</span> T = myqueue.front();</span><br><span class="line">        myqueue.pop();</span><br><span class="line">        <span class="keyword">if</span> (tree[T].left == <span class="number">-1</span> &amp;&amp; tree[T].right == <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; T;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; T;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (tree[T].left!=<span class="number">-1</span>) myqueue.push( tree[T].left);</span><br><span class="line">        <span class="keyword">if</span> (tree[T].right!=<span class="number">-1</span>) myqueue.push(tree[T].right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    node* tree=<span class="keyword">new</span> node[n];</span><br><span class="line">    <span class="keyword">char</span> left, right;</span><br><span class="line">    <span class="comment">//写入树</span></span><br><span class="line">    <span class="keyword">int</span> root[<span class="number">100</span>]{<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="string">'-'</span>)</span><br><span class="line">            tree[i].left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            tree[i].left = left - <span class="string">'0'</span>;</span><br><span class="line">            root[left-<span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="string">'-'</span>)</span><br><span class="line">            tree[i].right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            tree[i].right = right - <span class="string">'0'</span>;</span><br><span class="line">            root[right-<span class="string">'0'</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> root_index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (root[i] == <span class="number">0</span>)</span><br><span class="line">            root_index = i;</span><br><span class="line">    }</span><br><span class="line">    LevelTra(tree, root_index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="先序遍历顺序建立二叉树链表">先序遍历顺序建立二叉树链表<a title="#先序遍历顺序建立二叉树链表" href="#先序遍历顺序建立二叉树链表"></a></h1>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121100.png#align=left&amp;display=inline&amp;height=488&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1164&amp;status=done&amp;style=none&amp;width=1164" alt="" class="φcx"></p>
<p><strong>代码实现:</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    node*  left;</span><br><span class="line">    node* right;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(node*&amp; T)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        T = <span class="keyword">new</span> node;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        createBiTree(T-&gt;left);</span><br><span class="line">        createBiTree(T-&gt;right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOders</span><span class="params">(node* tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    node* T = tree;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node*&gt; mystack;</span><br><span class="line">    <span class="keyword">while</span> (T || !mystack.empty()) {</span><br><span class="line">        <span class="keyword">if</span> (T) {</span><br><span class="line">            mystack.push(T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            T = mystack.top();</span><br><span class="line">            mystack.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            T = T-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    node* tree = <span class="keyword">new</span> node;</span><br><span class="line">    createBiTree(tree);</span><br><span class="line">    inOders(tree);</span><br><span class="line">    <span class="keyword">return</span>    <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>测试案例:</strong> <code>ABC##DE#G##F###</code></p>
<p><strong>建立结果:</strong><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121021.png#align=left&amp;display=inline&amp;height=374&amp;margin=%5Bobject%20Object%5D&amp;originHeight=374&amp;originWidth=374&amp;status=done&amp;style=none&amp;width=374" alt=""></p>
<h1 id="复制二叉树">复制二叉树<a title="#复制二叉树" href="#复制二叉树"></a></h1>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513121055.png#align=left&amp;display=inline&amp;height=450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=450&amp;originWidth=1153&amp;status=done&amp;style=none&amp;width=1153" alt="" class="φcx"></p>
<p><strong>代码实现:</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(node* T, node*&amp; newT)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        newT = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        newT = <span class="keyword">new</span> node;</span><br><span class="line">        newT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;left, newT-&gt;left);</span><br><span class="line">        Copy(T-&gt;right, newT-&gt;right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>测试案例:</strong> <code>ABC##DE#G##F###</code></p>
<p><strong>打印结果:</strong> <img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513122702.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=146&amp;originWidth=699&amp;status=done&amp;style=none&amp;width=699" alt=""></p>
<h1 id="计算二叉树的深度">计算二叉树的深度<a title="#计算二叉树的深度" href="#计算二叉树的深度"></a></h1>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200513160326.png#align=left&amp;display=inline&amp;height=335&amp;margin=%5Bobject%20Object%5D&amp;originHeight=335&amp;originWidth=1167&amp;status=done&amp;style=none&amp;width=1167" alt="" class="φcx"></p>
<p><strong>递龟实现</strong>:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(node* T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = Depth(T-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> n = Depth(T-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="统计二叉树中结点的个数">统计二叉树中结点的个数<a title="#统计二叉树中结点的个数" href="#统计二叉树中结点的个数"></a></h1>
<h1 id="二叉树的可视化">二叉树的可视化<a title="#二叉树的可视化" href="#二叉树的可视化"></a></h1>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515192331.png#align=left&amp;display=inline&amp;height=197&amp;margin=%5Bobject%20Object%5D&amp;originHeight=197&amp;originWidth=253&amp;status=done&amp;style=none&amp;width=253" alt="" class="φcx"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_impl</span><span class="params">(Node* n, <span class="keyword">bool</span> left, <span class="built_in">string</span> <span class="keyword">const</span>&amp; indent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;right)</span><br><span class="line">    {</span><br><span class="line">        output_impl(n-&gt;right, <span class="literal">false</span>, indent + (left ? <span class="string">"|     "</span> : <span class="string">"      "</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; indent;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (left ? <span class="string">'\\'</span> : <span class="string">'/'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-----"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;left)</span><br><span class="line">    {</span><br><span class="line">        output_impl(n-&gt;left, <span class="literal">true</span>, indent + (left ? <span class="string">"      "</span> : <span class="string">"|     "</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"左边在下面,右边在上面"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">    {</span><br><span class="line">        output_impl(root-&gt;right, <span class="literal">false</span>, <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">    {</span><br><span class="line">        output_impl(root-&gt;left, <span class="literal">true</span>, <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="二叉树的后序遍历">二叉树的后序遍历<a title="#二叉树的后序遍历" href="#二叉树的后序遍历"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
</blockquote>
<p>递归方法很简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(TreeNode* T)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (T) {</span><br><span class="line">            rec(T-&gt;left);</span><br><span class="line">            rec(T-&gt;right);</span><br><span class="line">            v1.push_back(T-&gt;val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>对于这样一颗树, 我们有三种情况会访问 A 结点, 1 第一次结果他访问他的左子树, 2 他的左子树访问完了开始访问他的右子树, 3 他的左右子树都访问完了,开始访问他本身.<br>
使用栈迭代, 先把最左边的结点入栈.<br>
第三种情况需要我们判断他的右子树是否已经访问,或者上他的右子树为空,满足条件之一我们就访问 A 结点.<br>
使用一个指针来标记上一次完成访问的结点. 如果 A 的右子树不为空, 那么在 A 之前访问的结点一定是 A 的右子树. 如果 A 的右子树为空, 那么我们可以直接访问 A 结点.<br>
如果上面的条件不满足, 证明 A 的右子树还没有访问我们进入他的右子树继续迭代</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* T = root, *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (T || !s.empty()) {</span><br><span class="line">            <span class="keyword">if</span> (T)</span><br><span class="line">            {</span><br><span class="line">                s.push(T);</span><br><span class="line">                T = T-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                T = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;right != p &amp;&amp; T-&gt;right != <span class="literal">NULL</span>) {</span><br><span class="line">                    s.push(T);</span><br><span class="line">                    T = T-&gt;right;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    v.push_back(T-&gt;val);</span><br><span class="line">                    p = T;</span><br><span class="line">                    T = <span class="literal">NULL</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200515223810.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;originHeight=163&amp;originWidth=818&amp;status=done&amp;style=none&amp;width=818" alt="" class="φcx"></p>
<h1 id="二叉树的最大深度">二叉树的最大深度<a title="#二叉树的最大深度" href="#二叉树的最大深度"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/</a></p>
</blockquote>
<p><strong>递归解法简单</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> n = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> depth = (m &gt; n ? m : n)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>复杂度分析:<br>
时间复杂度 <img src="https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&amp;code=O%28n%29&amp;height=20&amp;width=36" alt=""></p>
<h1 id="翻转二叉树">翻转二叉树<a title="#翻转二叉树" href="#翻转二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/submissions/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/invert-binary-tree/submissions/</a></p>
</blockquote>
<p><strong>递归简单</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(TreeNode*&amp; T)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!T) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* temp = T-&gt;left;</span><br><span class="line">        T-&gt;left = T-&gt;right;</span><br><span class="line">        T-&gt;right = temp;</span><br><span class="line">        rec(T-&gt;left);</span><br><span class="line">        rec(T-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="二叉树的层序遍历">二叉树的层序遍历<a title="#二叉树的层序遍历" href="#二叉树的层序遍历"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
</blockquote>
<p>和普通的层序遍历不太一样的是, 普通的层序遍历无法得知他的层数信息, 但是这个要返回一个二维数组</p>
<p>从队列中取出一个结点, 把他的儿子结点 <code>push</code> 进去. 每次遍历一层我们都会把这一层的结点的儿子都 <code>push</code> 进来, <code>push</code> 进来的总数是儿子节点的总数.</p>
<p>我们要一次性从队列里面取出这一层的全部结点. <code>queue.size()</code> 作为我们取出的个数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vve;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) qu.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!qu.empty()) {</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">int</span> size = qu.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != size; i++) {</span><br><span class="line">                TreeNode* T = qu.front();</span><br><span class="line">                temp.push_back(<span class="number">1</span>);</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;left)qu.push(T-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;right)qu.push(T-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            vve.push_back(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vve;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>这道题花了我很长时间, 不能直接用 <code>qu.size()</code> 作为循环条件, 因为 <code>size</code> 会变</p>
<h1 id="二叉搜索树的范围和">二叉搜索树的范围和<a title="#二叉搜索树的范围和" href="#二叉搜索树的范围和"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/range-sum-of-bst/</a></p>
</blockquote>
<p>其实是二叉树中序遍历得到的序列, 在 L 和 R 之间的数求和</p>
<p><strong>最简单的思路</strong></p>
<ol>
<li>使用迭代栈中序遍历</li>
<li>使用 <code>falg</code> 判断该数是否在 L 和 R 之间</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* T = root;</span><br><span class="line">        <span class="keyword">while</span> (T || !s.empty()) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (T)</span><br><span class="line">            {</span><br><span class="line">                s.push(T);</span><br><span class="line">                T = T-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                T = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;val == L) {</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    sum += T-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;val == R &amp;&amp; flag)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                T = T-&gt;right;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="n-叉树的后序遍历">N 叉树的后序遍历<a title="#n-叉树的后序遍历" href="#n-叉树的后序遍历"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p>
</blockquote>
<p><strong>递归方法很简单</strong></p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200516222301.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;originHeight=231&amp;originWidth=823&amp;status=done&amp;style=none&amp;width=823" alt="" class="φcx"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != root-&gt;children.size(); i++) {</span><br><span class="line">            rec(root-&gt;children[i]);</span><br><span class="line">        }</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>迭代思路</strong></p>
<p>后序遍历，首先最简单的做法是 记住前序 翻转就实现 (直接利用 1.前序遍历 2.翻转)</p>
<p>访问栈顶, val 放入到 ve 中, 将栈顶 pop 出来, 将其子树全部按照顺序地放入到栈中. 循环该过程</p>
<p>循环结束的条件是栈空, 在访问完最后一个结点时栈肯定是空的, 其余情况栈肯定不为空</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.empty()){</span><br><span class="line">            Node* T=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(T){</span><br><span class="line">                v.push_back(T-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=T-&gt;children.size();i++){</span><br><span class="line">                     s.push(T-&gt;children[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        reverse(v.begin(),v.end());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517084030.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=312&amp;originWidth=794&amp;status=done&amp;style=none&amp;width=794" alt="" class="φcx"></p>
<h1 id="n-叉树的前序遍历">N 叉树的前序遍历<a title="#n-叉树的前序遍历" href="#n-叉树的前序遍历"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p>
</blockquote>
<p><strong>递归法很简单</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(Node* T)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">        v.push_back(T-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=T-&gt;children.size();i++){</span><br><span class="line">            rec(T-&gt;children[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>迭代法就相当于上一道题不用 <code>reverse(v.begin(),v.end());</code></p>
<h1 id="将有序数组转换为二叉搜索树">将有序数组转换为二叉搜索树<a title="#将有序数组转换为二叉搜索树" href="#将有序数组转换为二叉搜索树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
</blockquote>
<p>只有一个中序/后序/前序遍历序列无法唯一确定一颗平衡二叉搜索树</p>
<p>给定了有序数组, 中序遍历时根结点一定处于有序数组的中间部分, 可以递归的每次选数组中间部分作为根结点</p>
<p><strong>方法一：中序遍历：始终选择中间位置左边元素作为根节点</strong></p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200517164034.png#align=left&amp;display=inline&amp;height=233&amp;margin=%5Bobject%20Object%5D&amp;originHeight=233&amp;originWidth=844&amp;status=done&amp;style=none&amp;width=844" alt="" class="φcx"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* T = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        T-&gt;left = helper(left, mid - <span class="number">1</span>);</span><br><span class="line">        T-&gt;right = helper(mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法二：中序遍历：始终选择中间位置右边元素作为根节点</strong></p>
<p><strong>方法三：中序遍历：选择任意一个中间位置元素作为根节点</strong></p>
<h1 id="*特定深度节点链表">*特定深度节点链表<a title="#*特定深度节点链表" href="#*特定深度节点链表"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/list-of-depth-lcci/</a></p>
</blockquote>
<p>很明显, 采取层次遍历, 每一层变成一条链表</p>
<p>队列实现层次遍历, 链表的创建采取后插法, 函数返回一个数组, 数组元素是链表头指针</p>
<h1 id="二叉树的中序遍历">二叉树的中序遍历<a title="#二叉树的中序遍历" href="#二叉树的中序遍历"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/</a></p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* T=root;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">        <span class="keyword">while</span>(T||!st.empty()){</span><br><span class="line">            <span class="keyword">if</span>(T){</span><br><span class="line">                st.push(T);</span><br><span class="line">                T=T-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                T=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                ve.push_back(T-&gt;val);</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="祖父节点值为偶数的节点和">祖父节点值为偶数的节点和<a title="#祖父节点值为偶数的节点和" href="#祖父节点值为偶数的节点和"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/</a></p>
</blockquote>
<p>使用三元组来存储结点关系 <code>(grandparent, parent, node)</code> , 之后判断 <code>node.left</code>, <code>node.right</code></p>
<p>官方思路还是比较普通的, 没我想的那么复杂</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* grandparent, TreeNode* parent, TreeNode* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!node)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grandparent-&gt;val % <span class="number">2</span> == <span class="number">0</span>)ans += node-&gt;val;</span><br><span class="line">        <span class="comment">//遍历下一层</span></span><br><span class="line">        dfs(parent, node, node-&gt;left);</span><br><span class="line">        dfs(parent, node, node-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumEvenGrandparent</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) {</span><br><span class="line">            dfs(root, root-&gt;left, root-&gt;left-&gt;left);</span><br><span class="line">            dfs(root, root-&gt;left, root-&gt;left-&gt;right);</span><br><span class="line">        }<span class="keyword">if</span> (root-&gt;right) {</span><br><span class="line">            dfs(root, root-&gt;right, root-&gt;right-&gt;left);</span><br><span class="line">            dfs(root, root-&gt;right, root-&gt;right-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在上一种方法中, 由于根节点没有父结点, 他的根节点的子结点没有祖父结点, 因此我们是从 <code>root-&gt;left-&gt;right</code> 开始的, 因此我们必须使用<code>if (root-&gt;left != NULL)</code>来判断他有没有子结点. 我们可以简化这个过程, 根结点是没有父结点和祖父结点的, 但是我们可以假设他的父结点的值是 1 , 效果是一样的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> gp_val, <span class="keyword">int</span> p_val, TreeNode* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!node) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (gp_val % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            ans += node-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        dfs(p_val, node-&gt;val, node-&gt;left);</span><br><span class="line">        dfs(p_val, node-&gt;val, node-&gt;right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumEvenGrandparent</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518083648.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;originHeight=318&amp;originWidth=722&amp;status=done&amp;style=none&amp;width=722" alt="" class="φcx"></p>
<h1 id="根据前序和后序遍历构造二叉树">根据前序和后序遍历构造二叉树<a title="#根据前序和后序遍历构造二叉树" href="#根据前序和后序遍历构造二叉树"></a></h1>
<blockquote>
<ul class="φcz">
<li><input type="checkbox" disabled=""><i></i><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></li>
</ul>
</blockquote>
<p>只记得上课讲过, 知道是什么原理, 代码就是写不出来, 递归传哪些参数之类的拎不清</p>
<p>祭上一段优美的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">   <span class="keyword">int</span> pre_index=<span class="number">0</span>, post_index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>{</span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> TreeNode(pre[pre_index++]);</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;val != post[post_index])</span><br><span class="line">          root-&gt;left = constructFromPrePost(pre, post);</span><br><span class="line">      <span class="keyword">if</span>(root-&gt;val != post[post_index])</span><br><span class="line">          root-&gt;right = constructFromPrePost(pre, post);</span><br><span class="line">      post_index++;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518092242.png#align=left&amp;display=inline&amp;height=320&amp;margin=%5Bobject%20Object%5D&amp;originHeight=320&amp;originWidth=633&amp;status=done&amp;style=none&amp;width=633" alt="" class="φcx"></p>
<h1 id="二叉搜索树中的众数">二叉搜索树中的众数<a title="#二叉搜索树中的众数" href="#二叉搜索树中的众数"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p>
</blockquote>
<p>怎么说呢, 感觉这道题怪怪的</p>
<p><strong>思路:</strong> 使用 <code>map</code> 来保存数和它出现的频率, 最后再将出现频率最高的数放到 <code>vector</code>, 里面</p>
<p><code>map</code> 中 <code>value</code> 是出现频率, <code>key</code> 是某个数.</p>
<p>回顾一下 <code>map</code> 的特性: <strong>使用 <code>[]</code> 访问不存在的 <code>key</code>, <code>map</code> 会把它自动添加进去, 并返回他的 <code>value</code></strong></p>
<p>就懒得自己写了, 太恼人了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &gt; mmp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        mmp[root-&gt;val]++;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mmp.begin(); it != mmp.end(); it++) {</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second == maxn) {</span><br><span class="line">                v.push_back(it-&gt;first);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &gt; maxn) {</span><br><span class="line">                maxn = it-&gt;second;</span><br><span class="line">                v.clear();</span><br><span class="line">                v.push_back(it-&gt;first);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*恢复二叉搜索树">*恢复二叉搜索树<a title="#*恢复二叉搜索树" href="#*恢复二叉搜索树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/recover-binary-search-tree/</a></p>
</blockquote>
<h1 id="路径总和">路径总和<a title="#路径总和" href="#路径总和"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/path-sum/</a></p>
</blockquote>
<p>哎呀, 不就是递归吗, 多简单啊, 轻轻松松的啦</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200519004054.png#align=left&amp;display=inline&amp;height=321&amp;margin=%5Bobject%20Object%5D&amp;originHeight=321&amp;originWidth=610&amp;status=done&amp;style=none&amp;width=610" alt="" class="φcx"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="comment">//遍历每一条路径,求和</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;sum=sum;</span><br><span class="line">        rec(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(TreeNode* T,<span class="keyword">int</span> pre_sum)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!T)<span class="keyword">return</span>;</span><br><span class="line">        pre_sum+=T-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(pre_sum==sum&amp;&amp;T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)flag=<span class="literal">true</span>;</span><br><span class="line">        rec(T-&gt;left,pre_sum);</span><br><span class="line">        rec(T-&gt;right,pre_sum);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>不过相较于别人的代码还是过于臃肿</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==sum&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*二叉树的最近公共祖先">*二叉树的最近公共祖先<a title="#*二叉树的最近公共祖先" href="#*二叉树的最近公共祖先"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
</blockquote>
<p>嗅到了递归的气息, &nbsp; 回溯算法</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/#comment</a> &gt; <a href="https://www.youtube.com/watch?v=xzKrRf-SLqM" target="_blank" rel="external nofollow noopener">https://www.youtube.com/watch?v=xzKrRf-SLqM</a></p>
</blockquote>
<p>犯糊涂了, 之前以为必须是两个结点的直接祖先, 题没看清楚, 不过肯定逃不了递归思路</p>
<p>公共祖先 situation:</p>
<ol>
<li>p q 在 roo 的左右两边</li>
<li>1=root, p 在左边或者右边</li>
<li>p=root, q 在左边或者右边</li>
</ol>
<p>时间复杂度<br>
<img src="https://g.yuque.com/gr/latex?O(n)#card=math&amp;code=O%28n%29" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>||root==q||root==p) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">NULL</span> ? right : left;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>因为是递归，使用函数后可认为左右子树已经算出结果</p>
</blockquote>
<h1 id="*出现次数最多的子树元素和">*出现次数最多的子树元素和<a title="#*出现次数最多的子树元素和" href="#*出现次数最多的子树元素和"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/most-frequent-subtree-sum/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/most-frequent-subtree-sum/</a></p>
</blockquote>
<h1 id="二叉搜索树的第-k-大节点">二叉搜索树的第 k 大节点<a title="#二叉搜索树的第-k-大节点" href="#二叉搜索树的第-k-大节点"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a>)</p>
</blockquote>
<p>还是比较简单的</p>
<p>二叉搜索树的特点: <strong>中序遍历序列递增</strong></p>
<p>思路: 访问结点, 放入<code>vector</code> ,最后返回 <code>vector</code> 里面倒数第 <code>k</code> 个数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> ve[ve.size()-k];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(TreeNode* T)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line">        rec(T-&gt;left);</span><br><span class="line">        ve.push_back(T-&gt;val);</span><br><span class="line">        rec(T-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="从上到下打印二叉树-ii">从上到下打印二叉树 II<a title="#从上到下打印二叉树-ii" href="#从上到下打印二叉树-ii"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a>)</p>
</blockquote>
<p>噗, 又是层序遍历</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vve;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty()){</span><br><span class="line">            <span class="keyword">int</span> size=qu.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=size;i++){</span><br><span class="line">                TreeNode* T=qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                temp.push_back(T-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;left)qu.push(T-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;right)qu.push(T-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            vve.push_back(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vve;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="平衡二叉树">平衡二叉树<a title="#平衡二叉树" href="#平衡二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        rec(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(TreeNode* T)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!T)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=rec(T-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> n=rec(T-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n)&gt;=<span class="number">2</span>) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> max=m&gt;n?m:n;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="从上到下打印二叉树">从上到下打印二叉树<a title="#从上到下打印二叉树" href="#从上到下打印二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p>
</blockquote>
<p>迷惑性题目, 未免太过简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ve;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty()){</span><br><span class="line">            TreeNode* T=qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ve.push_back(T-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;left) qu.push(T-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;right)   qu.push(T-&gt;right);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>注意下 <code>root</code> 为空直接返回就是了</p>
<h1 id="*前序和中序序列构造二叉树">*前序和中序序列构造二叉树<a title="#*前序和中序序列构造二叉树" href="#*前序和中序序列构造二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p>
</blockquote>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200518090828.png#align=left&amp;display=inline&amp;height=423&amp;margin=%5Bobject%20Object%5D&amp;originHeight=423&amp;originWidth=1224&amp;status=done&amp;style=none&amp;width=1224" alt="" class="φcx"></p>
<p>直接写的不太好, 还是直接看别人的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, pos, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span>&amp; pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= preorder.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[pos])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[pos]);</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= i<span class="number">-1</span>) node-&gt;left = buildTree(preorder, ++pos, inorder, left, i<span class="number">-1</span>);  <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span> &lt;= right) node-&gt;right = buildTree(preorder, ++pos, inorder, i + <span class="number">1</span>, right); <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>map</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            pos[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> dfs(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inor, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> k = pos[pre[pl]] - il;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[pl]);</span><br><span class="line">        root -&gt; left = dfs(pre, inor, pl + <span class="number">1</span>, pl + k, il, il + k - <span class="number">1</span>);</span><br><span class="line">        root -&gt; right = dfs(pre, inor, pl + k + <span class="number">1</span>, pr, il + k + <span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="二叉树的右视图">二叉树的右视图<a title="#二叉树的右视图" href="#二叉树的右视图"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>
</blockquote>
<p><strong>我的思路:</strong> 使用区分层数的层序遍历, 只打印每一层的最后一个结点</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> {};</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">        TreeNode* T=<span class="literal">NULL</span>;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty()){</span><br><span class="line">            <span class="keyword">int</span> size=qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=size;i++){</span><br><span class="line">                T=qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">if</span>(i==size<span class="number">-1</span>)</span><br><span class="line">                    ve.push_back(T-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;left) qu.push(T-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;right) qu.push(T-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>缺点:</strong> 将左子树的不必要的部分存储进了队列, 浪费内存</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520154638.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;originHeight=323&amp;originWidth=629&amp;status=done&amp;style=none&amp;width=629" alt="" class="φcx"></p>
<p><strong>复杂度分析:</strong> 每个结点都入队出队了一次, 所以时间复杂度是 <img src="https://cdn.nlark.com/yuque/__latex/7ba55e7c64a9405a0b39a1107e90ca94.svg#card=math&amp;code=O%28n%29&amp;height=20&amp;width=36" alt=""></p>
<p><strong>思路二:</strong> &nbsp; 使用深度优先搜索, 先 <strong>根节点-&gt;右子树-&gt;左子树</strong>, 与先序遍历顺序相反<br>
只加入每一层第一次被访问的结点, 使用 <code>ve.size()</code> 来判断层数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    }</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* T,<span class="keyword">int</span> depth)</span></span>{</span><br><span class="line">         <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">         <span class="keyword">if</span>(depth==ve.size())</span><br><span class="line">             ve.push_back(T-&gt;val);</span><br><span class="line">         ++depth;</span><br><span class="line">         dfs(T-&gt;right,depth);</span><br><span class="line">         dfs(T-&gt;left,depth);</span><br><span class="line">     }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>不过速度好像更慢了</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200520161245.png#align=left&amp;display=inline&amp;height=311&amp;margin=%5Bobject%20Object%5D&amp;originHeight=311&amp;originWidth=636&amp;status=done&amp;style=none&amp;width=636" alt="" class="φcx"></p>
<h1 id="*把二叉搜索树转换为累加树">*把二叉搜索树转换为累加树<a title="#*把二叉搜索树转换为累加树" href="#*把二叉搜索树转换为累加树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p>
</blockquote>
<p>二叉搜索树的特点:</p>
<ol>
<li>左子树所有结点小于根结点</li>
<li>右子树所有节点大于根结点</li>
</ol>
<p><strong>根据这个特点, 我们可以得出:</strong> 对于一个结点, 他的值变为 = 原来的结点值 + 他右子树的所有结点的值 + 他所有祖先节点与组先结点的右子树的所有结点的值</p>
<p><strong>对于这道题:</strong> 我们中序递归遍历: 右子树-&gt;根结点-&gt;左子树, 每个结点值变为 左子树结点和+本身</p>
<p>算了写不出来, 脑子不够用, 看看别人的正确代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        root-&gt;val+=num;</span><br><span class="line">        num=root-&gt;val;<span class="comment">//记录这一次的和</span></span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>我的思维误区</strong> 第一: 误以为需要递归函数返回右子树的和, 其实使用一个全局变量就可以了 第二: 每个结点只需要遍历一次就够了</p>
<h1 id="*二叉树的直径">*二叉树的直径<a title="#*二叉树的直径" href="#*二叉树的直径"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
</blockquote>
<p>一道标注简单的题做起来不简单</p>
<h1 id="*左子叶之和">*左子叶之和<a title="#*左子叶之和" href="#*左子叶之和"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p>
</blockquote>
<p>西巴, 不会, 虽然说看起来挺简单的</p>
<p>首先, 不可以使用普通的前序遍历, 因为它无法分辨遍历到的结点是不是右结点</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">             temp=root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> temp+sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="叶子相似的树">叶子相似的树<a title="#叶子相似的树" href="#叶子相似的树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/leaf-similar-trees/</a></p>
</blockquote>
<p>**我的思路: ** 应该是最简单的思路了, 前序遍历两棵树, 判断结点是不是叶节点, 使用 vector 存储, 最后比较两个 vector 是否相同</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,v2;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>{</span><br><span class="line">        rec(root1,<span class="number">1</span>);</span><br><span class="line">        rec(root2,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(v1.size()!=v2.size())</span><br><span class="line">        {</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=v1.size();i++){</span><br><span class="line">                <span class="keyword">if</span>(v1[i]!=v2[i])</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(TreeNode* T,<span class="keyword">int</span> tag)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>&amp;&amp;tag==<span class="number">1</span>){</span><br><span class="line">            v1.push_back(T-&gt;val);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>&amp;&amp;tag==<span class="number">2</span>){</span><br><span class="line">            v2.push_back(T-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        rec(T-&gt;left,tag);</span><br><span class="line">        rec(T-&gt;right,tag);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>优化方法, 使用 <code>string</code> 来存储遍历到的叶节点值, 最后使用 <code>.equal()</code> 就可以了, 不过记得在结点值中间增加分隔符</p>
<h1 id="二叉树的堂兄弟节点">二叉树的堂兄弟节点<a title="#二叉树的堂兄弟节点" href="#二叉树的堂兄弟节点"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/cousins-in-binary-tree/</a></p>
</blockquote>
<p><strong>堂兄弟的条件:</strong> 不同父结点, 相同的深度</p>
<p>看了看别人的解法, 没有啥惊艳的解法</p>
<p>**我的思路: ** <s>使用层序遍历, 遍历到一个结点就将它</s> <strong>不做了</strong></p>
<h1 id="验证二叉搜索树">验证二叉搜索树<a title="#验证二叉搜索树" href="#验证二叉搜索树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>
</blockquote>
<p>判断一颗二叉树是不是二叉搜索树.</p>
<p>二叉搜索树的特点:</p>
<ol>
<li>左子树所有结点值小于根结点</li>
<li>右子树所有结点值大于根结点</li>
<li>中序遍历得到的序列递增</li>
</ol>
<p><strong>我的错误思路:</strong> 中序递归遍历, 对于一个结点, 判断他的左结点是否比他小,右节点的值是否比他大</p>
<p><strong>错误原因:</strong> 在这种情况下, 按照我的思路无法判断</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521120921.png#align=left&amp;display=inline&amp;height=282&amp;margin=%5Bobject%20Object%5D&amp;originHeight=282&amp;originWidth=379&amp;status=done&amp;style=none&amp;width=379" alt="" class="φcx"></p>
<p><strong>大佬的思路:</strong> 中序遍历为升序</p>
<p><strong>经过改进:</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> prev= LONG_MIN;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* T=root;</span><br><span class="line">        <span class="keyword">while</span>(T||!st.empty()){</span><br><span class="line">            <span class="keyword">if</span>(T){</span><br><span class="line">                st.push(T);</span><br><span class="line">                T=T-&gt;left;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                T = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;val&lt;=prev)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                prev=T-&gt;val;</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针<a title="#填充每个节点的下一个右侧节点指针" href="#填充每个节点的下一个右侧节点指针"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p>
</blockquote>
<p><strong>我的起初思路:</strong> 想使用层序遍历, 但是层序遍历需要使用额外的队列空间, 大小由最后一层的结点树数量决定.</p>
<p><strong>观察给出的样例:</strong></p>
<ol>
<li>左子树结点 next 指向他的兄弟结点(父结的右儿子)</li>
<li>右子树结点 next 指向父结点的 next 的左儿子, 特别的, 如果父结点的 next 是 NULL 的话, 直接指向 NULL</li>
</ol>
<p>**我的实现方法: ** 中序递归遍历, 先对于每一个结点:</p>
<ol>
<li>该结点不是叶节点, 把他的左儿子 next 指向他的右儿子, 把他的右儿子 next 指向他的 next</li>
<li>该节点是叶节点就什么什么都不做</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node* T)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>||(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)) <span class="keyword">return</span> ;</span><br><span class="line">        T-&gt;left-&gt;next=T-&gt;right;</span><br><span class="line">        T-&gt;right-&gt;next= T-&gt;next==<span class="literal">NULL</span>? <span class="literal">NULL</span>:T-&gt;next-&gt;left;</span><br><span class="line">        helper(T-&gt;left);</span><br><span class="line">        helper(T-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>卧槽, 一次过, 有点激动</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521141703.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;originHeight=256&amp;originWidth=630&amp;status=done&amp;style=none&amp;width=630" alt="" class="φcx"></p>
<p>优化方法, 这里可以不用 <code>helper</code> 函数, 一个函数内<code>return root</code></p>
<h1 id="*二叉搜索树迭代器">*二叉搜索树迭代器<a title="#*二叉搜索树迭代器" href="#*二叉搜索树迭代器"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-search-tree-iterator/submissions/</a></p>
</blockquote>
<p>**我的思路: ** 因为是二叉搜索树, 所以中序遍历序列是递增序列. 因为每一次使用 next ,数就减少一个, 很容易联想到栈或队列. 因此我们使用队列来保存中序遍历序列</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    BSTIterator(TreeNode* root) {</span><br><span class="line">        helper(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* T)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        helper(T-&gt;left);</span><br><span class="line">        st.push(T-&gt;val);</span><br><span class="line">        helper(T-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> x=st.front();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> !st.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>效果很差</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200521144009.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=312&amp;originWidth=640&amp;status=done&amp;style=none&amp;width=640" alt="" class="φcx"></p>
<p><strong>更好的方法:</strong></p>
<p>模拟递归的过程</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    BSTIterator(TreeNode* root) {</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        {</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        TreeNode *p =stk.top();</span><br><span class="line">        <span class="keyword">int</span> res= p-&gt;val;</span><br><span class="line">        stk.pop();</span><br><span class="line">        p =p-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        {</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> !stk.empty();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*树的子结构">*树的子结构<a title="#*树的子结构" href="#*树的子结构"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>
</blockquote>
<p><strong>我的思路:</strong> 先序遍历 A 树, 判断该结点的值是否与 B 的根结点相同</p>
<ol>
<li>相同: 记下这个结点的位置, 两棵树同时向下比较, , 当 B 树被遍历完了, 就 return true, 否者回到原来被记下的位置, 继续先序遍历</li>
<li>不同, A 向下遍历</li>
</ol>
<p>算了写不下去了, 错误代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>{</span><br><span class="line">        helper(A,B);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* A,TreeNode* B)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">NULL</span>)  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val==B-&gt;val){</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            TreeNode* pa=A;</span><br><span class="line">            TreeNode* pb=B;</span><br><span class="line">            <span class="built_in">stack</span>&lt;TreeNode*&gt; sa,sb;</span><br><span class="line">            <span class="keyword">while</span>((pa||!sa.empty())&amp;&amp;(pb||!sb.empty())){</span><br><span class="line">                <span class="keyword">if</span>(pa&amp;&amp;pb){</span><br><span class="line">                    sa.push(pa);</span><br><span class="line">                    sb.push(pb);</span><br><span class="line">                    <span class="keyword">if</span>(pa-&gt;val!=pb-&gt;val)</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                    pa=pa-&gt;left;</span><br><span class="line">                    pb=pb-&gt;left;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    pa=sa.top(); sa.pop();</span><br><span class="line">                    pb=sb.top(); sb.pop();</span><br><span class="line">                    pa=pa-&gt;right;</span><br><span class="line">                    pb=pb-&gt;right;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pb!=<span class="literal">NULL</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">true</span>) <span class="keyword">this</span>-&gt;flag=<span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        helper(A-&gt;left,B);</span><br><span class="line">        helper(A-&gt;right,B);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>看看别人的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="literal">NULL</span> &amp;&amp; B != <span class="literal">NULL</span>) &amp;&amp; (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>卧槽, 简直了, 优美简短</p>
<p><strong>别人的思路:</strong></p>
<h1 id="二叉树的最小深度">二叉树的最小深度<a title="#二叉树的最小深度" href="#二叉树的最小深度"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m=minDepth(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> n=minDepth(root-&gt;right);</span><br><span class="line">            <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1</span></span><br><span class="line">            <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;left==<span class="literal">NULL</span>||root-&gt;right==<span class="literal">NULL</span>? (m+n+<span class="number">1</span>):(m&gt;n?n:m)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="斐波那契数列">斐波那契数列<a title="#斐波那契数列" href="#斐波那契数列"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/fibonacci-number/description/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/fibonacci-number/description/</a></p>
</blockquote>
<p>虽然我知道直接递归不太好, 但是我实在是真看不出这道题和树有什么联系</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(N<span class="number">-1</span>)+fib(N<span class="number">-2</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="最大二叉树">最大二叉树<a title="#最大二叉树" href="#最大二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/description/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/maximum-binary-tree/description/</a></p>
</blockquote>
<p>一看就是递归, 我又不会…</p>
<p>写了一段半残的代码, 思路比较普通, 也比较好理解, 就是边界控制始终不到位</p>
<p>还是去看大佬的代码去了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//垃圾代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> max=findMax(nums,<span class="number">0</span>,nums.size());</span><br><span class="line">        <span class="keyword">return</span> helper(nums,<span class="number">0</span>,max,nums.size());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>   </span>{</span><br><span class="line">        <span class="keyword">int</span> max=INT_MIN,res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=max){</span><br><span class="line">                max=nums[i];</span><br><span class="line">                res=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> max,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(nums[max]);</span><br><span class="line">        <span class="keyword">int</span> left_max=findMax(nums,left,max<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> right_max=findMax(nums,max+<span class="number">1</span>,right);</span><br><span class="line">        root-&gt;left=helper(nums,left,left_max,max<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(nums,max+<span class="number">1</span>,right_max,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>别人的好代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> construct(nums.begin(), nums.end());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode * <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator l, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator r)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = max_element(l, r);</span><br><span class="line">        TreeNode *tn = <span class="keyword">new</span> TreeNode(*it);</span><br><span class="line">        tn-&gt;left  = construct(l, it);</span><br><span class="line">        tn-&gt;right = construct(it + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> tn;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>**总结一下: ** 使用 <code>vector</code> 迭代器, 比较好</p>
<ol>
<li>递归结束的条件是左迭代器与右迭代器重合</li>
<li>使用 <code>STL max_element()</code> , 让代码看起来比较简洁, 还需要积累库算法的使用经验</li>
<li>注意左右分递归时的细节. 左边递归的右边界是 <code>it</code>. 右边递归的左边界是 <code>it+1</code> ,右边界是 r</li>
</ol>
<h1 id="合并二叉树">合并二叉树<a title="#合并二叉树" href="#合并二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/merge-two-binary-trees/description/</a></p>
</blockquote>
<p>好的, 我又看出来了, 这是一道递归的题目, 可是卵用</p>
<p>冷静分析, 有要接一颗树的情形, 因此递归得返回正在处理的二叉树, 方便对接</p>
<p>如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!t1) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2 ) <span class="keyword">return</span> t1;</span><br><span class="line">        t1-&gt;val+=t2-&gt;val;</span><br><span class="line">        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>思路是挺清晰, 就是内存消耗有点大</p>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200526000011.png#align=left&amp;display=inline&amp;height=319&amp;margin=%5Bobject%20Object%5D&amp;originHeight=319&amp;originWidth=736&amp;status=done&amp;style=none&amp;width=736" alt="" class="φcx"></p>
<h1 id="*对称二叉树">*对称二叉树<a title="#*对称二叉树" href="#*对称二叉树"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/description/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/symmetric-tree/description/</a></p>
</blockquote>
<p>反正就是遍历的问题, 算了不会</p>
<p>理一下思路: 如何判断一颗树是否是对称二叉搜索树?</p>
<p>如果根节点是<code>NULL</code>, &nbsp;<code>true</code><br>
如果根结点不是<code>NULL</code>, 判断 左子树的左儿子和右子树的右儿子 &amp;&amp; 左子树的右儿子和右子树的左儿子</p>
<p>左子树的左儿子和右子树的右儿子(左子树的右儿子和右子树的左儿子)</p>
<ol>
<li><strong>都为空</strong> <code>return true</code></li>
<li><strong>有一个是 <code>NULL</code></strong> , 有一个不是 <code>NULL</code></li>
<li><strong>都不为空</strong>, 判断他们的值是否相同, 并且继续向下递归判断</li>
</ol>
<p>这样递归关系就清晰可见了</p>
<p>代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>  helper(root-&gt;left,root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* l,TreeNode* r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span>&amp;&amp;r==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span>||r==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> r-&gt;val==l-&gt;val   &amp;&amp; helper(l-&gt;left,r-&gt;right)&amp;&amp;helper(l-&gt;right,r-&gt;left);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>代码优化</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (t1.val == t2.val)</span><br><span class="line">        &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">        &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*路径总和-&nbsp;ⅲ">*路径总和 &nbsp;Ⅲ<a title="#*路径总和-&nbsp;ⅲ" href="#*路径总和-&nbsp;ⅲ"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/description/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/path-sum-iii/description/</a></p>
</blockquote>
<p>难度不小, 有点东西</p>
<p><s>思路一: 使用 vector 存储遍历到的路径的值的和, 最后数容器中有几个 sum</s></p>
<p>算了不会, 别折腾自己, 看答案了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> == sum ? <span class="number">1</span> : <span class="number">0</span>) + dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);</span><br><span class="line">        <span class="comment">/*这条路径和是否是sum, 继续递归左边和右边*/</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>解释: <code>pathSum</code> 前序遍历递归每一个结点. <code>dfs</code> 对于每一 &nbsp; 个结点递归遍历他的左右子树.<br>
对于一个结点我们怎么判断他有几条向下的路径和为 sum 呢? 前序遍历, 向下递归</p>
<h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索<a title="#二叉搜索树中的搜索" href="#二叉搜索树中的搜索"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p>
</blockquote>
<p>我的最初递归方法,不知道还没有更好的方法</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==val)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l=searchBST(root-&gt;left,val);</span><br><span class="line">        TreeNode* r=searchBST(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> l==<span class="literal">NULL</span>?r:l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>适当优化</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||root-&gt;val==val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l=searchBST(root-&gt;left,val);</span><br><span class="line">        TreeNode* r=searchBST(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> l==<span class="literal">NULL</span>?r:l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>当然我们也可以使用层序遍历或者非递归遍历来实现.</p>
<p>观察了一会儿, 恍然大悟, 这是一颗二叉搜索树, 我们可以利用它的性质来优化代码. 但是提交结果显示效率还是不高</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||root-&gt;val==val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* res=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val)</span><br><span class="line">            res=searchBST(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res=searchBST(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://mvbbb-blog-1301484447.cos.ap-chengdu.myqcloud.com/typora/20200530114156.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;originHeight=301&amp;originWidth=675&amp;status=done&amp;style=none&amp;width=675" alt="" class="φcx"></p>
<h1 id="二叉搜索树中的插入操作">二叉搜索树中的插入操作<a title="#二叉搜索树中的插入操作" href="#二叉搜索树中的插入操作"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
</blockquote>
<p>Awesome! 一次过</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val)</span><br><span class="line">            root-&gt;left=insertIntoBST(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;right=insertIntoBST(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*二叉树展开为链表">*二叉树展开为链表<a title="#*二叉树展开为链表" href="#*二叉树展开为链表"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>
</blockquote>
<p>题干的关键是原地展开, 不能新建一颗二叉树.</p>
<p>递龟问题, 我们根结点的左子树被插入到根结点与右子树中间</p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-ming-zhi-/" target="_blank" rel="external nofollow noopener">别人的思路</a>对于一个递归函数, 我们不用管函数内部是怎样实现的, 我只看函数的作用以及输入输出.</p>
<p>对于<code>flatten</code> 来说</p>
<ol>
<li>函数作用: 是将一个二叉树展开为链表</li>
<li>输入: 树的根结点</li>
<li>输出: 无</li>
</ol>
<p>我的思维误区: 其实叶节点也可以当作是一颗左子树和右子树都是 <code>NULL</code> 的树</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们每次把原来的右子树接到现在右子树的末尾都使用了一个 `while` 循环来找到现在右子树最右边的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        TreeNode*temp=root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;right!=<span class="literal">nullptr</span>)root=root-&gt;right;</span><br><span class="line">        root-&gt;right=temp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>另外一种思路: 向右边的后序遍历, 逆向思维, 难懂</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* last = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        root-&gt;right = last;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        last = root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="*二叉树的所有路径">*二叉树的所有路径<a title="#*二叉树的所有路径" href="#*二叉树的所有路径"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>
</blockquote>
<p>很久没做题了, 手感生疏了, 简单题也头痛了. 虽然说之前也不怎么会 🤣</p>
<p>来看看这道题. 不会</p>
<p>对于一个结点, 分情况</p>
<ol>
<li>他的左儿子或右儿子有一个不为空, 到他的 path += “val-&gt;”</li>
<li>他是叶节点, path+= “val”, 将到他的 path push 到容器</li>
</ol>
<p>递龟结束的条件是碰到 NULL 了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> {};</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>){<span class="comment">//叶节点</span></span><br><span class="line">            path+=to_string(root-&gt;val);</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            path+=to_string(root-&gt;val)+<span class="string">"-&gt;"</span>;</span><br><span class="line">            <span class="built_in">string</span> temp=path;<span class="comment">//使用一个temp来保存到即将进入左边递龟的结点的路径</span></span><br><span class="line">            binaryTreePaths(root-&gt;left);</span><br><span class="line">            path=temp;<span class="comment">//将路径恢复为进入左边递龟之前的路径</span></span><br><span class="line">            binaryTreePaths(root-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h1 id="找树左下角的值">找树左下角的值<a title="#找树左下角的值" href="#找树左下角的值"></a></h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="external nofollow noopener">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>
</blockquote>
<p>又是层序遍历, 仔细想一下很简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty()){</span><br><span class="line">            <span class="keyword">int</span> size=qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=size;i++){</span><br><span class="line">                <span class="keyword">auto</span> T=qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                res=T-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;left)qu.push(T-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(T-&gt;right)qu.push(T-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div><h1 id="推荐文章">推荐文章<a title="#推荐文章" href="%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0"></a></h1><ul><li><a href="https://mvbbb.github.io/iixrxk/">排序算法</a></li><li><a href="https://mvbbb.github.io/gggq6t/">Leetbook 初级算法</a></li><li><a href="http://www.b5mang.com/hasSubtree.html">二叉树系列-二叉树子结构</a></li></ul></div></div><is-f class="φcc φv φs"><!----><ul class="φcg"><li class="φce"><strong class="φcf">Author<span>:</span></strong><p class="φcd">Mvbbb</p></li><li class="φce"><strong class="φcf">Link<span>:</span></strong><p class="φcd"><a href="https://mvbbb.github.io/zhme42/" title="力扣-二叉树">https://mvbbb.github.io/zhme42/</a></p></li><li class="φce"><strong class="φcf">Copyright<span>:</span></strong><p class="φcd">Attribution-NonCommercial-NoDerivatives 4.0 International (<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener" target="_blank">CC BY-NC-ND 4.0</a>)</p></li><!----></ul><!----></is-f><!----><!----><!----></article><footer class="φgb φh"><div class="φgg"><is-m class="φet"><a class="φeu φs φq" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></is-m><is-m class="φet"><a class="φeu φs φq" href="/tags/%E5%9B%9E%E6%BA%AF">回溯</a></is-m><is-m class="φet"><a class="φeu φs φq" href="/tags/%E6%A0%91">树</a></is-m><is-m class="φet"><a class="φeu φs φq" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">算法与数据结构</a></is-m><is-m class="φet"><a class="φeu φs φq" href="/tags/%E9%80%92%E5%BD%92">递归</a></is-m><!----></div><!----><div class="φgc"><a class="φgd φgf φu" href="/iixrxk">排序算法</a><!----><a class="φgd φge φu" href="/gggq6t">Leetbook 初级算法</a><!----></div><!----></footer><is-e class="φbz φh"><div issnippet="" class="φbh"><div id="tcomment"></div>


</div><!----><!----><!----><!----></is-e><!----><!----><!----></is-s><!----></main><!----></div></div></div><is-g class="φch"><div class="φcq"><span class="φbg icon-up"></span><span class="φbg icon-down"></span><!----><span class="φbg icon-toc"></span><!----><span class="φbg icon-search"></span><!----></div><div class="φcj φck"><svg class="φcp"><defs><filter id="dp"><feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur></filter></defs><circle filter="url(#dp)" fill="rgba(0,0,0,.3)" cx="50%" cy="52%" r="44%"></circle><circle cx="50%" cy="50%" r="44%" class="φcl φbb"></circle><circle cx="50%" cy="50%" r="48%" class="φco φba" stroke-dasharray="0% 314.15926%"></circle><!----><g class="φcm"><circle r=".2rem" cx="0" cy="-.8rem"></circle><circle r=".2rem"></circle><circle r=".2rem" cx="0" cy=".8rem"></circle></g><!----></svg></div></is-g><is-n class="φev φf"><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">1 </span><!----><span class="φfc">遍历树叶</span></a><div class="φex"><a class="φfa φu"><span class="φfb φd">1.1 </span><!----><span class="φfc">题目描述</span></a><!----></div><div class="φex"><a class="φfa φu"><span class="φfb φd">1.2 </span><!----><span class="φfc">思路</span></a><!----></div><!----><!----><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">2 </span><!----><span class="φfc">先序遍历顺序建立二叉树链表</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">3 </span><!----><span class="φfc">复制二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">4 </span><!----><span class="φfc">计算二叉树的深度</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">5 </span><!----><span class="φfc">统计二叉树中结点的个数</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">6 </span><!----><span class="φfc">二叉树的可视化</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">7 </span><!----><span class="φfc">二叉树的后序遍历</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">8 </span><!----><span class="φfc">二叉树的最大深度</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">9 </span><!----><span class="φfc">翻转二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">10 </span><!----><span class="φfc">二叉树的层序遍历</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">11 </span><!----><span class="φfc">二叉搜索树的范围和</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">12 </span><!----><span class="φfc">N 叉树的后序遍历</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">13 </span><!----><span class="φfc">N 叉树的前序遍历</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">14 </span><!----><span class="φfc">将有序数组转换为二叉搜索树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">15 </span><!----><span class="φfc">*特定深度节点链表</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">16 </span><!----><span class="φfc">二叉树的中序遍历</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">17 </span><!----><span class="φfc">祖父节点值为偶数的节点和</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">18 </span><!----><span class="φfc">根据前序和后序遍历构造二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">19 </span><!----><span class="φfc">二叉搜索树中的众数</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">20 </span><!----><span class="φfc">*恢复二叉搜索树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">21 </span><!----><span class="φfc">路径总和</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">22 </span><!----><span class="φfc">*二叉树的最近公共祖先</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">23 </span><!----><span class="φfc">*出现次数最多的子树元素和</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">24 </span><!----><span class="φfc">二叉搜索树的第 k 大节点</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">25 </span><!----><span class="φfc">从上到下打印二叉树 II</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">26 </span><!----><span class="φfc">平衡二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">27 </span><!----><span class="φfc">从上到下打印二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">28 </span><!----><span class="φfc">*前序和中序序列构造二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">29 </span><!----><span class="φfc">二叉树的右视图</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">30 </span><!----><span class="φfc">*把二叉搜索树转换为累加树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">31 </span><!----><span class="φfc">*二叉树的直径</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">32 </span><!----><span class="φfc">*左子叶之和</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">33 </span><!----><span class="φfc">叶子相似的树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">34 </span><!----><span class="φfc">二叉树的堂兄弟节点</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">35 </span><!----><span class="φfc">验证二叉搜索树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">36 </span><!----><span class="φfc">填充每个节点的下一个右侧节点指针</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">37 </span><!----><span class="φfc">*二叉搜索树迭代器</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">38 </span><!----><span class="φfc">*树的子结构</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">39 </span><!----><span class="φfc">二叉树的最小深度</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">40 </span><!----><span class="φfc">斐波那契数列</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">41 </span><!----><span class="φfc">最大二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">42 </span><!----><span class="φfc">合并二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">43 </span><!----><span class="φfc">*对称二叉树</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">44 </span><!----><span class="φfc">*路径总和 &nbsp;Ⅲ</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">45 </span><!----><span class="φfc">二叉搜索树中的搜索</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">46 </span><!----><span class="φfc">二叉搜索树中的插入操作</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">47 </span><!----><span class="φfc">*二叉树展开为链表</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">48 </span><!----><span class="φfc">*二叉树的所有路径</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">49 </span><!----><span class="φfc">找树左下角的值</span></a><!----></div><div class="φex φey φn"><a class="φfa φu"><span class="φfb φd">50 </span><!----><span class="φfc">推荐文章</span></a><!----></div><!----></is-n><!----><!----></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js"></script><script src="/runtime.b15aa7186c559b492b7d.js"></script><script src="/polyfills.824ff89b5f3ca4543a31.js"></script><script src="/main.03652fc423a687c817e8.js"></script><!-- hexo injector body_end end -->

</body></html>